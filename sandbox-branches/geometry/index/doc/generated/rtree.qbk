[/ Generated by doxygen_xml2qbk, don't change, will be overwritten automatically]
[/ Generated from xml/classboost_1_1geometry_1_1index_1_1rtree.xml]
[section:boost_geometry_index_rtree boost::geometry::index::rtree]

'''<indexterm><primary>boost</primary></indexterm><indexterm><primary>geometry</primary></indexterm><indexterm><primary>index</primary></indexterm><indexterm><primary>rtree</primary></indexterm>'''
The R-tree spatial index. 

[heading Description]
The R-tree spatial index. This is self-balancing spatial index capable to store various types of Values and balancing algorithms.

[heading Parameters]
The user must pass a type defining the Parameters which will be used in rtree creation process. This type is used e.g. to specify balancing algorithm with specific parameters like min and max number of elements in node.




Predefined algorithms with compile-time parameters are: 

* [^bgi::linear<MinElements, MaxElements>], 
* [^bgi::quadratic<MinElements, MaxElements>], 
* [^bgi::rstar<MinElements, MaxElements, OverlapCostThreshold = 0, ReinsertedElements = MaxElements * 0.3>].






Predefined algorithms with run-time parameters are: 

* [^bgi::runtime::linear], 
* [^bgi::runtime::quadratic], 
* [^bgi::runtime::rstar].



[heading Translator]
The Translator translates from Value to Indexable each time r-tree requires it. Which means that this operation is done for each Value access. Therefore the Translator should return the Indexable by const reference instead of a value. Default translator can translate all types adapted to Point or Box concepts (called Indexables). It also handles [^std::pair<Indexable, T>] and [^boost::tuple<Indexable, ...>]. For example, if [^std::pair<Box, int>] is stored in the container, the default translator translates from [^std::pair<Box, int> const&] to [^Box const&].

[heading Header]
`#include <boost/geometry/extensions/index/rtree/rtree.hpp>`

[heading Synopsis]
``template<typename Value,
         typename Parameters,
         typename Translator = translator::def<Value>,
         typename Allocator = std::allocator<Value>>
class rtree
{
  // ...
};
``

[heading Template parameter(s)]
[table
[[Parameter] [Description]]
[[`Value`][The type of objects stored in the container. ]]
[[`Parameters`][Compile-time parameters. ]]
[[`Translator`][The type of the translator which translates from Value to Indexable. ]]
[[`Allocator`][The allocator used to allocate/deallocate memory, construct/destroy nodes and Values. ]]
]

[heading Typedef(s)]
[table
[[Type] [Description]]
[[`value_type`][The type of Value stored in the container. ]]
[[`parameters_type`][R-tree parameters type. ]]
[[`translator_type`][Value to Indexable Translator type. ]]
[[`allocator_type`][The type of allocator used by the container. ]]
[[`size_type`][Unsigned integral type used by the container. ]]
[[`indexable_type`][The Indexable type to which Value is translated. ]]
[[`box_type`][The Box type used by the R-tree. ]]
]

[heading Constructor(s) and destructor]
[table
[[Function][Description]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member0 `rtree()`]][The constructor. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member1 `rtree(parameters_type, translator_type const &, allocator_type)`]][The constructor. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member2 `rtree(Iterator, Iterator)`]][The constructor. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member3 `rtree(Range const &)`]][The constructor. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member4 `~rtree()`]][The destructor. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member5 `rtree(rtree const &)`]][The copy constructor. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member6 `rtree(rtree const &, allocator_type const &)`]][The copy constructor. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member7 `rtree(rtree &&)`]][The moving constructor. ]]
]

[heading Member(s)]
[table
[[Function][Description]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member8 `operator=(const rtree &)`]][The assignment operator. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member9 `operator=(rtree &&)`]][The moving assignment. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member10 `swap(rtree &)`]][Swaps contents of two rtrees. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member11 `insert(value_type const &)`]][Insert a value to the index. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member12 `insert(Iterator, Iterator)`]][Insert a range of values to the index. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member13 `insert(Range const &)`]][Insert a range of values to the index. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member14 `remove(value_type const &)`]][Remove a value from the container. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member15 `remove(Iterator, Iterator)`]][Remove a range of values from the container. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member16 `remove(Range const &)`]][Remove a range of values from the container. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member17 `spatial_query(Predicates const &, OutIter)`]][Finds values meeting spatial predicates, e.g. intersecting some Box. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member18 `nearest_query(DistancesPredicates const &, value_type &)`]][Finds one value meeting distances predicates, e.g. nearest to some Point. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member19 `nearest_query(DistancesPredicates const &, Predicates const &, value_type &)`]][Finds one value meeting distances predicates and spatial predicates, e.g. nearest to some Point and intersecting some Box. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member20 `nearest_query(DistancesPredicates const &, size_t, OutIter)`]][Finds k values meeting distances predicates, e.g. k nearest values to some Point. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member21 `nearest_query(DistancesPredicates const &, size_t, Predicates const &, OutIter)`]][Finds k values meeting distances predicates and spatial predicates, e.g. k nearest values to some Point and intersecting some Box. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member22 `size()`]][Returns the number of stored values. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member23 `empty()`]][Query if the container is empty. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member24 `clear()`]][Removes all values stored in the container. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member25 `box()`]][Returns the box containing all values stored in the container. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member26 `count(ValueOrIndexable const &)`]][Count Values or Indexables stored in the container. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member27 `parameters()`]][Returns parameters. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member28 `translator()`]][Returns the translator object. ]]
[[[link geometry_index.r_tree.reference.boost_geometry_index_rtree.member29 `get_allocator()`]][Returns allocator used by the rtree. ]]
]

[section:member0 rtree()]
The constructor. 

[heading Synopsis]
``rtree(parameters_type parameters = parameters_type(), translator_type const & translator = translator_type())``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `parameters_type` ][ `parameters` ][The parameters object. ]]
[[ `translator_type const &` ][ `translator` ][The translator object.]]
]
[heading Throws]
If allocator default constructor throws. 

[endsect]

[section:member1 rtree(parameters_type, translator_type const &, allocator_type)]
The constructor. 

[heading Synopsis]
``rtree(parameters_type parameters,
      translator_type const & translator,
      allocator_type allocator)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `parameters_type` ][ `parameters` ][The parameters object. ]]
[[ `translator_type const &` ][ `translator` ][The translator object. ]]
[[ `allocator_type` ][ `allocator` ][The allocator object.]]
]
[heading Throws]
If allocator copy constructor throws. 

[endsect]

[section:member2 rtree(Iterator, Iterator)]
The constructor. 

[heading Synopsis]
``template<typename Iterator>
rtree(Iterator first,
      Iterator last,
      parameters_type parameters = parameters_type(),
      translator_type const & translator = translator_type(),
      allocator_type allocator = allocator_type())``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `Iterator` ][ `first` ][The beginning of the range of Values. ]]
[[ `Iterator` ][ `last` ][The end of the range of Values. ]]
[[ `parameters_type` ][ `parameters` ][The parameters object. ]]
[[ `translator_type const &` ][ `translator` ][The translator object. ]]
[[ `allocator_type` ][ `allocator` ][The allocator object.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When memory allocation for Node fails. 



[endsect]

[section:member3 rtree(Range const &)]
The constructor. 

[heading Synopsis]
``template<typename Range>
rtree(Range const & rng,
      parameters_type parameters = parameters_type(),
      translator_type const & translator = translator_type(),
      allocator_type allocator = allocator_type())``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `Range const &` ][ `rng` ][The range of Values. ]]
[[ `parameters_type` ][ `parameters` ][The parameters object. ]]
[[ `translator_type const &` ][ `translator` ][The translator object. ]]
[[ `allocator_type` ][ `allocator` ][The allocator object.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When memory allocation for Node fails. 



[endsect]

[section:member4 ~rtree()]
The destructor. 

[heading Synopsis]
``~rtree()``

[heading Throws]
Nothing. 

[endsect]

[section:member5 rtree(rtree const &)]
The copy constructor. 

[heading Description]
It uses parameters, translator and allocator from the source tree.[heading Synopsis]
``rtree(rtree const & src)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `rtree const &` ][ `src` ][The rtree which content will be copied.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor throws. 
* If allocation throws. 
* When memory allocation for Node fails. 



[endsect]

[section:member6 rtree(rtree const &, allocator_type const &)]
The copy constructor. 

[heading Description]
It uses Parameters and translator from the source tree.[heading Synopsis]
``rtree(rtree const & src, allocator_type const & allocator)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `rtree const &` ][ `src` ][The rtree which content will be copied. ]]
[[ `allocator_type const &` ][ `allocator` ][The allocator which will be used.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor throws. 
* If allocation throws. 
* When memory allocation for Node fails. 



[endsect]

[section:member7 rtree(rtree &&)]
The moving constructor. 

[heading Description]
It uses parameters, translator and allocator from the source tree.[heading Synopsis]
``rtree(rtree && src)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `rtree &&` ][ `src` ][The rtree which content will be moved.]]
]
[heading Throws]
If allocator move constructor throws. 

[endsect]

[section:member8 operator=(const rtree &)]
The assignment operator. 

[heading Description]
It uses parameters and translator from the source tree.[heading Synopsis]
``rtree & operator=(const rtree & src)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `const rtree &` ][ `src` ][The rtree which content will be copied.]]
]
[heading Throws]


* If Value copy constructor throws. 
* If allocation throws. 
* When nodes allocation fails. 



[endsect]

[section:member9 operator=(rtree &&)]
The moving assignment. 

[heading Description]
It uses parameters and translator from the source tree.[heading Synopsis]
``rtree & operator=(rtree && src)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `rtree &&` ][ `src` ][The rtree which content will be moved.]]
]
[heading Throws]
Only if allocators aren't equal. 

* If Value copy constructor throws. 
* If allocation throws. 
* When nodes allocation fails. 



[endsect]

[section:member10 swap(rtree &)]
Swaps contents of two rtrees. 

[heading Description]
Parameters, translator and allocators are swapped as well.[heading Synopsis]
``void swap(rtree & other)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `rtree &` ][ `other` ][The rtree which content will be swapped with this rtree content.]]
]
[heading Throws]
If allocators swap throws. 

[endsect]

[section:member11 insert(value_type const &)]
Insert a value to the index. 

[heading Synopsis]
``void insert(value_type const & value)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `value_type const &` ][ `value` ][The value which will be stored in the container.]]
]
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When nodes allocation fails.



[warning This operation is not thread safe. If it throws, the R-tree may be left in an inconsistent state, elements must not be inserted or removed, methods may return invalid data. ]

[endsect]

[section:member12 insert(Iterator, Iterator)]
Insert a range of values to the index. 

[heading Synopsis]
``template<typename Iterator>
void insert(Iterator first, Iterator last)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `Iterator` ][ `first` ][The beginning of the range of values. ]]
[[ `Iterator` ][ `last` ][The end of the range of values.]]
]
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When nodes allocation fails.



[warning This operation is not thread safe. If it throws, the R-tree may be left in an inconsistent state, elements must not be inserted or removed, methods may return invalid data. ]

[endsect]

[section:member13 insert(Range const &)]
Insert a range of values to the index. 

[heading Synopsis]
``template<typename Range>
void insert(Range const & rng)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `Range const &` ][ `rng` ][The range of values.]]
]
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When nodes allocation fails.



[warning This operation is not thread safe. If it throws, the R-tree may be left in an inconsistent state, elements must not be inserted or removed, methods may return invalid data. ]

[endsect]

[section:member14 remove(value_type const &)]
Remove a value from the container. 

[heading Description]
In contrast to the [^std::set] or [^std::map][^erase()] method this method removes only one value from the container.[heading Synopsis]
``size_type remove(value_type const & value)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `value_type const &` ][ `value` ][The value which will be removed from the container.]]
]
[heading Returns]
1 if the value was removed, 0 otherwise.
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When nodes allocation fails.



[warning This operation is not thread safe. If it throws, the R-tree may be left in an inconsistent state, elements must not be inserted or removed, methods may return invalid data. ]

[endsect]

[section:member15 remove(Iterator, Iterator)]
Remove a range of values from the container. 

[heading Description]
In contrast to the [^std::set] or [^std::map][^erase()] method it doesn't take iterators pointing to values stored in this container. It removes values equal to these passed as a range. Furthermore this method removes only one value for each one passed in the range, not all equal values.[heading Synopsis]
``template<typename Iterator>
size_type remove(Iterator first, Iterator last)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `Iterator` ][ `first` ][The beginning of the range of values. ]]
[[ `Iterator` ][ `last` ][The end of the range of values.]]
]
[heading Returns]
The number of removed values.
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When nodes allocation fails.



[warning This operation is not thread safe. If it throws, the R-tree may be left in an inconsistent state, elements must not be inserted or removed, methods may return invalid data. ]

[endsect]

[section:member16 remove(Range const &)]
Remove a range of values from the container. 

[heading Description]
In contrast to the [^std::set] or [^std::map][^erase()] method it removes values equal to these passed as a range. Furthermore, this method removes only one value for each one passed in the range, not all equal values.[heading Synopsis]
``template<typename Range>
size_type remove(Range const & rng)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `Range const &` ][ `rng` ][The range of values.]]
]
[heading Returns]
The number of removed values.
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws. 
* When nodes allocation fails.



[warning This operation is not thread safe. If it throws, the R-tree may be left in an inconsistent state, elements must not be inserted or removed, methods may return invalid data. ]

[endsect]

[section:member17 spatial_query(Predicates const &, OutIter)]
Finds values meeting spatial predicates, e.g. intersecting some Box. 

[heading Description]
[*Spatial predicates] may be a [^Geometry]. In this case Values intersecting the [^Geometry] are returned.

It may be generated by one of the functions listed below: 

* [^bgi::covered_by(geometry)], 
* [^bgi::disjoint(geometry)], 
* [^bgi::intersects(geometry)] - default, 
* [^bgi::overlaps(geometry)], 
* [^bgi::within(geometry)], 
* [^!bgi::covered_by(geometry)], 
* [^!bgi::disjoint(geometry)], 
* [^!bgi::intersects(geometry)], 
* [^!bgi::overlaps(geometry)], 
* [^!bgi::within(geometry)]
* [^bgi::value(func)].


Those predicates may be passed together in [^std::pair<]...> or [^boost::tuple<]...>.[heading Synopsis]
``template<typename Predicates, typename OutIter>
size_type spatial_query(Predicates const & pred, OutIter out_it)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `Predicates const &` ][ `pred` ][The spatial predicates or a Geometry. ]]
[[ `OutIter` ][ `out_it` ][The output iterator of the result range. E.g. an iterator generated by std::back_inserter(container)]]
]
[heading Returns]
The number of values found.
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If OutIter dereference or increment throws. 



[endsect]

[section:member18 nearest_query(DistancesPredicates const &, value_type &)]
Finds one value meeting distances predicates, e.g. nearest to some Point. 

[heading Description]
[*Distances predicates] may be a [^Point]. In this the case the Value closest to [^Point] is returned.

It is possible to define how distance to Value is calculated. This is done by passing PointRelation. It can be generated by following functions: 

* bgi::to_nearest(Point) - default, 
* bgi::to_centroid(Point), 
* bgi::to_furthest(Point).


It is possible to define define distances bounds, for example that some distance must be between min_distance and max_distance. This is done by passing DistancesPredicates which can be generated by following functions: 

* bgi::unbounded(PointRelation) - default, 
* bgi::min_bounded(PointRelation, MinRelation), 
* bgi::max_bounded(PointRelation, MaxRelation), 
* bgi::bounded(PointRelation, MinRelation, MaxRelation).


MinRelation and MaxRelation describes bounds and can be generated by following functions: 

* bgi::to_nearest(some_distance), 
* bgi::to_centroid(some_distance), 
* bgi::to_furthest(some_distance).

[heading Synopsis]
``template<typename DistancesPredicates>
size_type nearest_query(DistancesPredicates const & dpred, value_type & v)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `DistancesPredicates const &` ][ `dpred` ][The distances predicates or a Point.]]
[[ `value_type &` ][ `v` ][The reference to the object which will contain the result.]]
]
[heading Returns]
The number of values found.
[heading Throws]
If Value copy constructor or copy assignment throws. 

[endsect]

[section:member19 nearest_query(DistancesPredicates const &, Predicates const &, value_type &)]
Finds one value meeting distances predicates and spatial predicates, e.g. nearest to some Point and intersecting some Box. 

[heading Description]
[*Distances predicates] may be a [^Point]. In this the case the Value closest to [^Point] is returned.

It is possible to define how distance to Value is calculated. This is done by passing PointRelation. It can be generated by following functions: 

* bgi::to_nearest(Point) - default, 
* bgi::to_centroid(Point), 
* bgi::to_furthest(Point).


It is possible to define define distances bounds, for example that some distance must be between min_distance and max_distance. This is done by passing DistancesPredicates which can be generated by following functions: 

* bgi::unbounded(PointRelation) - default, 
* bgi::min_bounded(PointRelation, MinRelation), 
* bgi::max_bounded(PointRelation, MaxRelation), 
* bgi::bounded(PointRelation, MinRelation, MaxRelation).


MinRelation and MaxRelation describes bounds and can be generated by following functions: 

* bgi::to_nearest(some_distance), 
* bgi::to_centroid(some_distance), 
* bgi::to_furthest(some_distance).

[*Spatial predicates] may be a [^Geometry]. In this case Values intersecting the [^Geometry] are returned.

It may be generated by one of the functions listed below: 

* [^bgi::covered_by(geometry)], 
* [^bgi::disjoint(geometry)], 
* [^bgi::intersects(geometry)] - default, 
* [^bgi::overlaps(geometry)], 
* [^bgi::within(geometry)], 
* [^!bgi::covered_by(geometry)], 
* [^!bgi::disjoint(geometry)], 
* [^!bgi::intersects(geometry)], 
* [^!bgi::overlaps(geometry)], 
* [^!bgi::within(geometry)]
* [^bgi::value(func)].


Those predicates may be passed together in [^std::pair<]...> or [^boost::tuple<]...>.[heading Synopsis]
``template<typename DistancesPredicates, typename Predicates>
size_type nearest_query(DistancesPredicates const & dpred,
                        Predicates const & pred,
                        value_type & v)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `DistancesPredicates const &` ][ `dpred` ][The distances predicates or a Point. ]]
[[ `Predicates const &` ][ `pred` ][The spatial predicates or a Geometry ]]
[[ `value_type &` ][ `v` ][The reference to the object which will contain the result.]]
]
[heading Returns]
The number of values found.
[heading Throws]
If Value copy constructor or copy assignment throws. 

[endsect]

[section:member20 nearest_query(DistancesPredicates const &, size_t, OutIter)]
Finds k values meeting distances predicates, e.g. k nearest values to some Point. 

[heading Description]
[*Distances predicates] may be a [^Point]. In this the case the Value closest to [^Point] is returned.

It is possible to define how distance to Value is calculated. This is done by passing PointRelation. It can be generated by following functions: 

* bgi::to_nearest(Point) - default, 
* bgi::to_centroid(Point), 
* bgi::to_furthest(Point).


It is possible to define define distances bounds, for example that some distance must be between min_distance and max_distance. This is done by passing DistancesPredicates which can be generated by following functions: 

* bgi::unbounded(PointRelation) - default, 
* bgi::min_bounded(PointRelation, MinRelation), 
* bgi::max_bounded(PointRelation, MaxRelation), 
* bgi::bounded(PointRelation, MinRelation, MaxRelation).


MinRelation and MaxRelation describes bounds and can be generated by following functions: 

* bgi::to_nearest(some_distance), 
* bgi::to_centroid(some_distance), 
* bgi::to_furthest(some_distance).

[heading Synopsis]
``template<typename DistancesPredicates, typename OutIter>
size_type nearest_query(DistancesPredicates const & dpred,
                        size_t k,
                        OutIter out_it)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `DistancesPredicates const &` ][ `dpred` ][The distances predicates or a Point. ]]
[[ `size_t` ][ `k` ][The max number of values. ]]
[[ `OutIter` ][ `out_it` ][The output iterator of the result range. E.g. a back_insert_iterator.]]
]
[heading Returns]
The number of values found.
[heading Throws]
If Value copy constructor or copy assignment throws. If OutIter dereference or increment throws. 

[endsect]

[section:member21 nearest_query(DistancesPredicates const &, size_t, Predicates const &, OutIter)]
Finds k values meeting distances predicates and spatial predicates, e.g. k nearest values to some Point and intersecting some Box. 

[heading Description]
[*Distances predicates] may be a [^Point]. In this the case the Value closest to [^Point] is returned.

It is possible to define how distance to Value is calculated. This is done by passing PointRelation. It can be generated by following functions: 

* bgi::to_nearest(Point) - default, 
* bgi::to_centroid(Point), 
* bgi::to_furthest(Point).


It is possible to define define distances bounds, for example that some distance must be between min_distance and max_distance. This is done by passing DistancesPredicates which can be generated by following functions: 

* bgi::unbounded(PointRelation) - default, 
* bgi::min_bounded(PointRelation, MinRelation), 
* bgi::max_bounded(PointRelation, MaxRelation), 
* bgi::bounded(PointRelation, MinRelation, MaxRelation).


MinRelation and MaxRelation describes bounds and can be generated by following functions: 

* bgi::to_nearest(some_distance), 
* bgi::to_centroid(some_distance), 
* bgi::to_furthest(some_distance).

[*Spatial predicates] may be a [^Geometry]. In this case Values intersecting the [^Geometry] are returned.

It may be generated by one of the functions listed below: 

* [^bgi::covered_by(geometry)], 
* [^bgi::disjoint(geometry)], 
* [^bgi::intersects(geometry)] - default, 
* [^bgi::overlaps(geometry)], 
* [^bgi::within(geometry)], 
* [^!bgi::covered_by(geometry)], 
* [^!bgi::disjoint(geometry)], 
* [^!bgi::intersects(geometry)], 
* [^!bgi::overlaps(geometry)], 
* [^!bgi::within(geometry)]
* [^bgi::value(func)].


Those predicates may be passed together in [^std::pair<]...> or [^boost::tuple<]...>.[heading Synopsis]
``template<typename DistancesPredicates,
         typename Predicates,
         typename OutIter>
size_type nearest_query(DistancesPredicates const & dpred,
                        size_t k,
                        Predicates const & pred,
                        OutIter out_it)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `DistancesPredicates const &` ][ `dpred` ][The distances predicates or a Point ]]
[[ `size_t` ][ `k` ][The max number of values. ]]
[[ `Predicates const &` ][ `pred` ][The spatial predicates or a Geometry. ]]
[[ `OutIter` ][ `out_it` ][The output iterator of the result range. E.g. a back_insert_iterator.]]
]
[heading Returns]
The number of values found.
[heading Throws]
If Value copy constructor or copy assignment throws. If OutIter dereference or increment throws. 

[endsect]

[section:member22 size()]
Returns the number of stored values. 

[heading Synopsis]
``size_type size()``

[heading Returns]
The number of stored values.
[heading Throws]
Nothing. 

[endsect]

[section:member23 empty()]
Query if the container is empty. 

[heading Synopsis]
``bool empty()``

[heading Returns]
true if the container is empty.
[heading Throws]
Nothing. 

[endsect]

[section:member24 clear()]
Removes all values stored in the container. 

[heading Synopsis]
``void clear()``

[heading Throws]
Nothing. 

[endsect]

[section:member25 box()]
Returns the box containing all values stored in the container. 

[heading Description]
Returns the box containing all values stored in the container. If the container is empty the result of [^geometry::assign_inverse()] is returned.[heading Synopsis]
``box_type box()``

[heading Returns]
The box containing all values stored in the container or an invalid box if there are no values in the container.
[heading Throws]
Nothing. 

[endsect]

[section:member26 count(ValueOrIndexable const &)]
Count Values or Indexables stored in the container. 

[heading Description]
For indexable_type it returns the number of values which indexables equals the parameter. For value_type it returns the number of values which equals the parameter.[heading Synopsis]
``template<typename ValueOrIndexable>
size_type count(ValueOrIndexable const & vori)``

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[ `ValueOrIndexable const &` ][ `vori` ][The value or indexable which will be counted.]]
]
[heading Returns]
The number of values found.
[heading Throws]
Nothing. 

[endsect]

[section:member27 parameters()]
Returns parameters. 

[heading Synopsis]
``parameters_type const & parameters()``

[heading Returns]
The parameters object.
[heading Throws]
Nothing. 

[endsect]

[section:member28 translator()]
Returns the translator object. 

[heading Synopsis]
``translator_type const & translator()``

[heading Returns]
The translator object.
[heading Throws]
Nothing. 

[endsect]

[section:member29 get_allocator()]
Returns allocator used by the rtree. 

[heading Synopsis]
``allocator_type get_allocator()``

[heading Returns]
The allocator.
[heading Throws]
If allocator copy constructor throws. 

[endsect]

[endsect]

