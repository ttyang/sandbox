[/ Generated by doxygen_xml2qbk, don't change, will be overwritten automatically]
[/ Generated from xml/group__rtree__functions.xml]
[section:group__rtree__functions Functions related to the rtree]
[heading Functions]
[table
[[Function][Description]]
[[[link group__rtree__functions_1gac0ac9ed0e01f7494a5a3059e75d3c5cc `insert(rtree<...> &, Value const &)`]][Insert a value to the index. ]]
[[[link group__rtree__functions_1gaf8f4fa09c12b96ace3bbb38823a9191b `insert(rtree<...> &, Iterator, Iterator)`]][Insert a range of values to the index. ]]
[[[link group__rtree__functions_1ga97ec330c1c021a1ac2d896a488c2eb9c `insert(rtree<...> &, Range const &)`]][Insert a range of values to the index. ]]
[[[link group__rtree__functions_1gad40492a5b99c3eebbd51901574762527 `remove(rtree<...> &, Value const &)`]][Remove a value from the container. ]]
[[[link group__rtree__functions_1ga0219361de8b15c539af3f9bd027938ce `remove(rtree<...> &, Iterator, Iterator)`]][Remove a range of values from the container. ]]
[[[link group__rtree__functions_1ga5885d6c90a91f238f72ab9b5ef24daf9 `remove(rtree<...> &, Range const &)`]][Remove a range of values from the container. ]]
[[[link group__rtree__functions_1ga86e0808522ef6682b72b310a3891b276 `query(rtree<...> const &, Predicates const &, OutIter)`]][Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box. ]]
[[[link group__rtree__functions_1ga0c65d7b29b1edf72f1d236ccf211f63c `clear(rtree<...> &)`]][Remove all values from the index. ]]
[[[link group__rtree__functions_1gaec0b88a9d8b408753e3069134f1598c7 `size(rtree<...> const &)`]][Get the number of values stored in the index. ]]
[[[link group__rtree__functions_1ga459e3d404fec7cbd66794714cbdd129e `empty(rtree<...> const &)`]][Query if there are no values stored in the index. ]]
[[[link group__rtree__functions_1gae10fbc3d536235b89aa3cb3641768bca `bounds(rtree<...> const &)`]][Get the box containing all stored values or an invalid box if the index has no values. ]]
]

[#group__rtree__functions_1gac0ac9ed0e01f7494a5a3059e75d3c5cc]
[section insert(rtree<...> &, Value const &)]
Insert a value to the index. 

[heading Description]
It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1af6d5bd81e46cb4ff89277c753133664c rtree::insert(value_type const&)]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``>`
`void boost::geometry::index::insert``(``rtree< Value, Options, Translator, Allocator > &` `tree``,` `Value const &` `v``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > &`][ `tree` ][The spatial index. ]]
[[`Value const &`][ `v` ][The value which will be stored in the index. ]]
]
[endsect]

[#group__rtree__functions_1gaf8f4fa09c12b96ace3bbb38823a9191b]
[section insert(rtree<...> &, Iterator, Iterator)]
Insert a range of values to the index. 

[heading Description]
It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1a5263a3faac7b4f0090d4ad1d44cc540d rtree::insert(Iterator, Iterator)]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``,`
         `typename Iterator``>`
`void boost::geometry::index::insert``(``rtree< Value, Options, Translator, Allocator > &` `tree``,`
                                    `Iterator` `first``,`
                                    `Iterator` `last``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > &`][ `tree` ][The spatial index. ]]
[[`Iterator`][ `first` ][The beginning of the range of values. ]]
[[`Iterator`][ `last` ][The end of the range of values. ]]
]
[endsect]

[#group__rtree__functions_1ga97ec330c1c021a1ac2d896a488c2eb9c]
[section insert(rtree<...> &, Range const &)]
Insert a range of values to the index. 

[heading Description]
It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1abb624abd9268b41e815d40342b2634c2 rtree::insert(Range const&)]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``,`
         `typename Range``>`
`void boost::geometry::index::insert``(``rtree< Value, Options, Translator, Allocator > &` `tree``,` `Range const &` `rng``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > &`][ `tree` ][The spatial index. ]]
[[`Range const &`][ `rng` ][The range of values. ]]
]
[endsect]

[#group__rtree__functions_1gad40492a5b99c3eebbd51901574762527]
[section remove(rtree<...> &, Value const &)]
Remove a value from the container. 

[heading Description]
Remove a value from the container. In contrast to the [^`std::set`] or [^`std::map erase()`] method this function removes only one value from the container.

It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1af6ca6909354a997f89411ef40ea5688a rtree::remove(value_type const&)]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``>`
`rtree<Value, Options, Translator, Allocator>::size_type boost::geometry::index::remove``(``rtree< Value, Options, Translator, Allocator > &` `tree``,` `Value const &` `v``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > &`][ `tree` ][The spatial index. ]]
[[`Value const &`][ `v` ][The value which will be removed from the index.]]
]
[heading Returns]
1 if value was removed, 0 otherwise. 
[endsect]

[#group__rtree__functions_1ga0219361de8b15c539af3f9bd027938ce]
[section remove(rtree<...> &, Iterator, Iterator)]
Remove a range of values from the container. 

[heading Description]
Remove a range of values from the container. In contrast to the [^`std::set`] or [^`std::map erase()`] method it doesn't take iterators pointing to values stored in this container. It removes values equal to these passed as a range. Furthermore this function removes only one value for each one passed in the range, not all equal values.

It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1a6e9123114697d65b16ebc49cd5371fbd rtree::remove(Iterator, Iterator)]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``,`
         `typename Iterator``>`
`rtree<Value, Options, Translator, Allocator>::size_type boost::geometry::index::remove``(``rtree< Value, Options, Translator, Allocator > &` `tree``,`
                                                                                       `Iterator` `first``,`
                                                                                       `Iterator` `last``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > &`][ `tree` ][The spatial index. ]]
[[`Iterator`][ `first` ][The beginning of the range of values. ]]
[[`Iterator`][ `last` ][The end of the range of values.]]
]
[heading Returns]
The number of removed values. 
[endsect]

[#group__rtree__functions_1ga5885d6c90a91f238f72ab9b5ef24daf9]
[section remove(rtree<...> &, Range const &)]
Remove a range of values from the container. 

[heading Description]
Remove a range of values from the container. In contrast to the [^`std::set`] or [^`std::map erase()`] method it removes values equal to these passed as a range. Furthermore this method removes only one value for each one passed in the range, not all equal values.

It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1a5a57bb93b0b2d7ea1c659e925f918e9c rtree::remove(Range const&)]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``,`
         `typename Range``>`
`rtree<Value, Options, Translator, Allocator>::size_type boost::geometry::index::remove``(``rtree< Value, Options, Translator, Allocator > &` `tree``,` `Range const &` `rng``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > &`][ `tree` ][The spatial index. ]]
[[`Range const &`][ `rng` ][The range of values.]]
]
[heading Returns]
The number of removed values. 
[endsect]

[#group__rtree__functions_1ga86e0808522ef6682b72b310a3891b276]
[section query(rtree<...> const &, Predicates const &, OutIter)]
Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box. 

[heading Description]
This query function performs spatial and k-nearest neighbor searches. It allows to pass a set of predicates. Values will be returned only if all predicates are met.

[*Spatial predicates]

The simplest form of spatial predicate is a [^`Geometry`]. In this case Values intersecting the [^`Geometry`] are returned. More spatial predicates may be generated by one of the functions listed below: 

* [^[link group__predicates_1ga0a613a7f1d18ac33955bfdc2c5777c61 boost::geometry::index::covered_by()]], 
* [^[link group__predicates_1ga351bb3b82e019ff45adf789385b8007d boost::geometry::index::disjoint()]], 
* [^[link group__predicates_1ga7301c50e0272976b9f1434536383e6d0 boost::geometry::index::intersects()]] - default, 
* [^[link group__predicates_1ga5511236f56be1defcccbf11e742ccd88 boost::geometry::index::overlaps()]], 
* [^[link group__predicates_1gabf9c4e76dd8a09a4c476f2f8fa8a0e4d boost::geometry::index::within()]],


It is possible to negate spatial predicates: 

* [^`! `[link group__predicates_1ga0a613a7f1d18ac33955bfdc2c5777c61 boost::geometry::index::covered_by()]], 
* [^`! `[link group__predicates_1ga351bb3b82e019ff45adf789385b8007d boost::geometry::index::disjoint()]], 
* [^`! `[link group__predicates_1ga7301c50e0272976b9f1434536383e6d0 boost::geometry::index::intersects()]], 
* [^`! `[link group__predicates_1ga5511236f56be1defcccbf11e742ccd88 boost::geometry::index::overlaps()]], 
* [^`! `[link group__predicates_1gabf9c4e76dd8a09a4c476f2f8fa8a0e4d boost::geometry::index::within()]]

[*Value predicate]

This is a special kind of predicate which allows to pass a user-defined functor which checks if Value should be returned by the query. It's generated by: 

* [^[link group__predicates_1ga8acb81106fce01da72f310184ab4d9ce boost::geometry::index::value()]].

[*Nearest predicate]

If the nearest predicate is passed a k-nearest neighbor search will be performed. This query will result in returning k values to the output iterator. Only one nearest predicate may be passed to the query. It may be generated by: 

* [^[link group__predicates_1gae80a2c204673a8b11c4fc137cfff6556 boost::geometry::index::nearest()]].

[*Connecting predicates]

Predicates may be passed together connected with [^`operator&&()`].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``,`
         `typename Predicates``,`
         `typename OutIter``>`
`rtree<Value, Options, Translator, Allocator>::size_type boost::geometry::index::query``(``rtree< Value, Options, Translator, Allocator > const &` `tree``,`
                                                                                      `Predicates const &` `predicates``,`
                                                                                      `OutIter` `out_it``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > const &`][ `tree` ][]]
[[`Predicates const &`][ `predicates` ][Predicates. ]]
[[`OutIter`][ `out_it` ][The output iterator, e.g. generated by std::back_inserter().]]
]
[heading Returns]
The number of values found. 
[heading Example]

``
// return elements intersecting box
bgi::query(tree, box, std::back_inserter(result));
// return elements intersecting poly but not within box
bgi::query(tree, bgi::intersects(poly) && !bgi::within(box), std::back_inserter(result));
// return elements overlapping box and meeting my_fun value predicate
bgi::query(tree, bgi::overlaps(box) && bgi::value(my_fun), std::back_inserter(result));
// return 5 elements nearest to pt and elements are intersecting box
bgi::query(tree, bgi::nearest(pt, 5) && bgi::intersects(box), std::back_inserter(result));
// return 5 elements which centroids are nearest to pt and elements aren't within box
bgi::query(tree, bgi::nearest(bgi::to_centroid(pt), 5) && !bgi::within(box), std::back_inserter(result));
``


[heading Throws]
If Value copy constructor or copy assignment throws.

[warning Only one [^[link group__predicates_1gae80a2c204673a8b11c4fc137cfff6556 nearest()]] perdicate may be passed to the query.]

[endsect]

[#group__rtree__functions_1ga0c65d7b29b1edf72f1d236ccf211f63c]
[section clear(rtree<...> &)]
Remove all values from the index. 

[heading Description]
It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1ae6027e42d28a4bf93e74b055c79e6b09 rtree::clear()]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``>`
`void boost::geometry::index::clear``(``rtree< Value, Options, Translator, Allocator > &` `tree``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > &`][ `tree` ][The spatial index. ]]
]
[endsect]

[#group__rtree__functions_1gaec0b88a9d8b408753e3069134f1598c7]
[section size(rtree<...> const &)]
Get the number of values stored in the index. 

[heading Description]
It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1a89561a834563f2ed6fc782bad16143fd rtree::size()]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``>`
`size_t boost::geometry::index::size``(``rtree< Value, Options, Translator, Allocator > const &` `tree``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > const &`][ `tree` ][The spatial index.]]
]
[heading Returns]
The number of values stored in the index. 
[endsect]

[#group__rtree__functions_1ga459e3d404fec7cbd66794714cbdd129e]
[section empty(rtree<...> const &)]
Query if there are no values stored in the index. 

[heading Description]
It calls [^[link classboost_1_1geometry_1_1index_1_1rtree_1ae889567443b0ba0dbdb975564c55804c rtree::empty()]].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``>`
`bool boost::geometry::index::empty``(``rtree< Value, Options, Translator, Allocator > const &` `tree``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > const &`][ `tree` ][The spatial index.]]
]
[heading Returns]
true if there are no values in the index. 
[endsect]

[#group__rtree__functions_1gae10fbc3d536235b89aa3cb3641768bca]
[section bounds(rtree<...> const &)]
Get the box containing all stored values or an invalid box if the index has no values. 

[heading Description]
It calls [^`rtree::envelope()`].[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Options``,`
         `typename Translator``,`
         `typename Allocator``>`
`rtree<Value, Options, Translator, Allocator>::bounds_type const& boost::geometry::index::bounds``(``rtree< Value, Options, Translator, Allocator > const &` `tree``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`rtree< Value, Options, Translator, Allocator > const &`][ `tree` ][The spatial index.]]
]
[heading Returns]
The box containing all stored values or an invalid box. 
[endsect]

[endsect]

