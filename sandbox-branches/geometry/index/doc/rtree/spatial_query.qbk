[/============================================================================
  Boost.Geometry Index

  Copyright (c) 2011-2012 Adam Wulkiewicz.

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section Spatial queries]

Spatial queries returns `Value`s which meets some predicates. For instance it may be used to
retrieve Values intersecting some area or are within some other area. Names of predicates
corresponds to names of __boost_geometry__ algorithms. The examples of some
basic queries may be found in the table below. The query region and result `Value`s are orange.

[table
[[intersects (default)] [covered_by] [disjoint] [overlaps] [within]]
[[[$../images/intersects.png]] [[$../images/within.png]] [[$../images/disjoint.png]] [[$../images/overlaps.png]] [[$../images/within.png]]]
]

[section Basic queries]

There are three ways to perform a spatial query. Following queries returns
`__value__`s intersecting some box_region.

Method call

 std::vector<__value__> returned_values;
 __box__ box_region(...);
 rt.spatial_query(box_region, std::back_inserter(returned_values));

Function call

 std::vector<__value__> returned_values;
 __box__ box_region(...);
 index::spatial_query(rt, box_region, std::back_inserter(returned_values));

Use of pipe operator generating a range

 __box__ box_region(...);
 BOOST_FOREACH(__value__ & v, rt | index::adaptors::spatial_queried(box_region))
   ; // do something with v
[endsect]

[section Spatial predicates]

To explicitly define one of the predicates one may pass it to the `spatial_query()` as
the first argument instead of `Box`.

 rt.spatial_query(box, std::back_inserter(result));                    // default case - intersects
 rt.spatial_query(index::intersects(box), std::back_inserter(result)); // the same as default
 rt.spatial_query(index::covered_by(box), std::back_inserter(result));
 rt.spatial_query(index::disjont(box), std::back_inserter(result));
 rt.spatial_query(index::overlaps(box), std::back_inserter(result));
 rt.spatial_query(index::within(box), std::back_inserter(result));

All predicates may be negated, e.g.:

 rt.spatial_query(!index::intersects(box), std::back_inserter(result));
 // the same as
 rt.spatial_query(index::disjoint(box), std::back_inserter(result));

[endsect]

[section Connecting predicates]

It's possible to use some number of predicates in one time by passing `std::pair<Pred1, Pred2>`
or `boost::tuple<Pred1, Pred2, Pred3, ...>`. These predicates are connected by logical AND.
Passing all predicates together not only makes possible to construct advanced queries but is also
faster than separate calls because the tree is traversed only once. Traversing is continued and
`Value`s are returned only if all predicates are met. Predicates are checked left-to-right so placing
most restictive predicates first should accelerate the search even more.

 rt.spatial_query(
   std::make_pair(
     index::intersects(box1), !index::within(box2) ),
   std::back_inserter(result));

 rt.spatial_query(
   boost::make_tuple(
     index::intersects(box1), !index::within(box2), index::overlaps(box3) ),
   std::back_inserter(result));

[endsect]

[section Value predicate]

There is also a unique predicate `index::value(...)` taking user-defined function/functor
which checks if `__value__` should be returned by the query.

 bool fun(__value__ const& v)
 {
   return v.is_red();
 }

 // ...

 rt.spatial_query(
   boost::make_pair(
     index::intersects(box), index::value(fun) ),
   std::back_inserter(result));

[endsect]

[endsect] [/ Spatial queries /]
