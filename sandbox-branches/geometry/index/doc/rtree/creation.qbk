[/============================================================================
  Boost.Geometry Index

  Copyright (c) 2011-2012 Adam Wulkiewicz.

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section Creation and modification]

[section Template parameters]

__rtree__ has 4 parameters:

 rtree<Value, Parameters, Translator, Allocator>

* `__value__` - type of object which will be stored in the container.
* `Parameters` - compile-time parameters, e.g. inserting/splitting
  algorithm with min and max nodes' elements numbers.
* `__translator__` - type of object translating `Value` objects to
  `__indexable__` objects (`__point__` or `__box__`) which __rtree__ can handle.
* `Allocator` - the allocator.

[endsect]

[section Values, Indexables and default Translator]

__rtree__ may store `__value__`s of any type as long the `__translator__`
is passed as parameter. It knows how to interpret those `__value__`s
and extract an object understandable by the __rtree__. Those objects are called
`__indexable__`s. Each type adapted to `__point__` or `__box__` concept is an `__indexable__`.
Default `__translator__` `index::translator::def<__value__>`
is able to handle `__point__`, `__box__` or `std::pair<...>` `__value__`s.

* `__indexable__ = __point__ | __box__`
* `__value__ = Indexable | std::pair<__indexable__, T>`

If comparison of two `__value__`s is required, the default translator compares
both components of the `std::pair<...>`. If the second one is a `Geometry`,
`geometry::equals()` function is used. For other types it uses `operator==()`.

Examples of `__value__` types:

 geometry::model::point<...>
 geometry::model::point_xy<...>
 geometry::model::box<...>
 std::pair<geometry::model::box<...>, size_t>

[endsect]

[section Inserting and splitting algorithms]

`__value__`s may be inserted to the __rtree__ in many various ways. Final internal structure
of the __rtree__ depends on algorithms used in the insertion process. The most important is
nodes' splitting algorithm. Currently, three well-known types of R-trees may be created.

Linear - classic __rtree__ using splitting algorithm of linear complexity

 index::rtree< __value__, index::linear<32, 8> > rt;

Quadratic - classic __rtree__ using splitting algorithm of quadratic complexity

 index::rtree< __value__, index::quadratic<32, 8> > rt;

R*-tree - splitting algorithm minimizing nodes' overlap with forced reinsertions
 
 index::rtree< __value__, index::rstar<32, 8> > rt;

[endsect]

[section Inserting and splitting algorithms (run-time)]

By default splitting algorithm parameters are passed to the __rtree__ in compile time.
To use run-time versions of the __rtree__ one may pass parameters defined in index::runtime
namespace.

 // linear
 index::rtree<__value__, index::runtime::linear> rt(index::runtime::linear(32, 8));
 // quadratic
 index::rtree<__value__, index::runtime::quadratic> rt(index::runtime::quadratic(32, 8));
 // rstar
 index::rtree<__value__, index::runtime::rstar> rt(index::runtime::rstar(32, 8));

[endsect]

[section Copying and moving]

The __rtree__ is copyable and movable container. Move semantics is implemented using Boost.Move library
which also supports compilers not supporting rvalue references.

 index::rtree< __value__, index::quadratic<32, 8> > rt1;
 // copy constructor
 index::rtree< __value__, index::quadratic<32, 8> > rt2;
 // copy assignment
 rt2 = r1;
 // move constructor
 index::rtree< __value__, index::quadratic<32, 8> > rt3(boost::move(rt1));
 // move assignment
 rt3 = boost::move(rt2);

[endsect]

[section Inserting and removing Values]

Following code creates an __rtree__ using quadratic algorithm.

 using namespace boost::geometry;
 typedef std::pair<Box, int> __value__;
 index::rtree< __value__, index::quadratic<32, 8> > rt;

To insert or remove __value__'s by method calls one may use the following
code.

 __value__ v = std::make_pair(__box__(...), 0);
 rt.insert(v);
 rt.remove(v);

To insert or remove __value__'s by function calls one may use the following
code.

 __value__ v = std::make_pair(__box__(...), 0);
 index::insert(rt, v);
 index::remove(rt, v);

[endsect]

[endsect] [/ Creation and modification /]
