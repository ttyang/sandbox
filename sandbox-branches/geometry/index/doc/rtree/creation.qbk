[/============================================================================
  Boost.Geometry Index

  Copyright (c) 2011-2012 Adam Wulkiewicz.

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section R-tree creation]

[section R-tree template parameters]

__rtree__ has 4 parameters:

 rtree<Value, Parameters, Translator, Allocator>

* `Value` - type of object which will be stored in the container.
* `Parameters` - compile-time parameters, e.g. inserting/splitting
  algorithm with min and max nodes' elements numbers.
* `Translator` - type of object translating `Value` objects to
  `Indexable` objects (`__point__` or `__box__`) which __rtree__ can handle.
* `Allocator` - the allocator.

[endsect]

[section Values, Indexables and default Translator]

__rtree__ may store `__value__`s of any type as long the `__translator__`
is passed as parameter. It knows how to interpret those `__value__`s
and extract an object understandable by the __rtree__. Those objects are called
`__indexable__`s. Each type adapted to `__point__` or `__box__` concept is an `__indexable__`.
Default `__translator__` `index::translator::def<Value>`
is able to handle `__point__`, `__box__`, `std::pair<...>`, pointer, iterator
or smart pointer.

* `__indexable__ = __point__ | __box__`
* `BasicValue = Indexable | std::pair<__indexable__, T> | std::pair<T, __indexable__>`
* `__value__ = BasicValue | BasicValue* | Iterator<BasicValue> | SmartPtr<BasicValue>`

Examples of `__value__` types:

 geometry::model::point<...>
 geometry::model::point_xy<...>
 geometry::model::box<...>
 std::pair<geometry::model::box<...>, size_t>

[endsect]

[section Inserting and splitting algorithms]

`__value__`s may be inserted to the __rtree__ in many various ways. Final internal structure
of the __rtree__ depends on algorithms used in the insertion process. The most important is
nodes' splitting algorithm. Currently, three well-known types of R-trees may be created.

Linear - classic __rtree__ using splitting algorithm of linear complexity

 index::rtree< __value__, index::linear<32, 8> > rt;

Quadratic - classic __rtree__ using splitting algorithm of quadratic complexity

 index::rtree< __value__, index::quadratic<32, 8> > rt;

R*-tree - splitting algorithm minimizing nodes' overlap with forced reinsertions
 
 index::rtree< __value__, index::rstar<32, 8> > rt;

[endsect]

[section Inserting and removing Values]

Following code creates an __rtree__ using quadratic algorithm.

 using namespace boost::geometry;
 typedef std::pair<Box, int> __value__;
 index::rtree< __value__, index::quadratic<32, 8> > rt;

To insert or remove __value__'s by method calls one may use the following
code.

 __value__ v = std::make_pair(__box__(...), 0);
 rt.insert(v);
 rt.remove(v);

To insert or remove __value__'s by function calls one may use the following
code.

 __value__ v = std::make_pair(__box__(...), 0);
 index::insert(rt, v);
 index::remove(rt, v);

[endsect]

[endsect] [/ R-tree creation /]
