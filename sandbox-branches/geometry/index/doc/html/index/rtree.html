<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>R-tree</title>
<link rel="stylesheet" href="http://www.boost.org/doc/libs/release/doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Geometry.Index">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Geometry.Index">
<link rel="prev" href="../index.html" title="Chapter&#160;1.&#160;Boost.Geometry.Index">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="http://www.boost.org/doc/libs/release/boost.png"></td>
<td align="center"><a href="http://www.boost.org/doc/libs/release/index.html">Home</a></td>
<td align="center"><a href="http://www.boost.org/doc/libs/release/libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="http://www.boost.org/doc/libs/release/more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="http://www.boost.org/doc/libs/release/doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="http://www.boost.org/doc/libs/release/doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="http://www.boost.org/doc/libs/release/doc/src/images/home.png" alt="Home"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="index.rtree"></a>R-tree</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="rtree.html#id821333">Introduction</a></span></dt>
<dt><span class="section"><a href="rtree.html#id821353">R-tree creation</a></span></dt>
<dt><span class="section"><a href="rtree.html#id821613">Inserting and removing Values</a></span></dt>
<dt><span class="section"><a href="rtree.html#id821638">Spatial queries</a></span></dt>
<dt><span class="section"><a href="rtree.html#id829402">Nearest neighbors queries</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="id821333"></a>Introduction</h3></div></div></div>
<p>
R-tree is a self-balancing search tree with nodes stored with their axis aligned
bounding boxes. Each node's box describes the space occupied by children nodes.
At the bottom of the structure, there are leaf-nodes which contains values
(geometric objects representations). Minimal and maximal numbers of values/children
which may be stored inside the node are user defined.
</p>
<p>
In order to use the R-tree one must include folowing file.
</p>
<pre class="programlisting">
#include &lt;boost/geometry/extensions/index/rtree/rtree.hpp&gt;
</pre>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="id821353"></a>R-tree creation</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="rtree.html#id821359">Quick start</a></span></dt>
<dt><span class="section"><a href="rtree.html#id821381">R-tree template parameters</a></span></dt>
<dt><span class="section"><a href="rtree.html#id821454">Values, Indexables and default Translator</a></span></dt>
<dt><span class="section"><a href="rtree.html#id821567">Inserting and splitting algorithms</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id821359"></a>Quick start</h4></div></div></div>
<p>
In order to create a R-tree object storing values of type
<code class="computeroutput">std::pair&lt;Box, int&gt;</code> one may use the following code
</p>
<pre class="programlisting">
using namespace boost::geometry;
typedef std::pair&lt;Box, int&gt; Value;
index::rtree&lt; Value, index::quadratic&lt;32, 8&gt; &gt; rt;
</pre>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id821381"></a>R-tree template parameters</h4></div></div></div>
<p>
R-tree has 4 parameters:
</p>
<pre class="programlisting">
rtree&lt;Value, Parameters, Translator, Allocator&gt;
</pre>
<p>
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<code class="computeroutput">Value</code> - type of object which will be stored in the container.
</li>
<li class="listitem">
<code class="computeroutput">Parameters</code> - compile-time parameters, e.g. inserting/splitting
algorithm with min and max nodes' elements numbers.
</li>
<li class="listitem">
<code class="computeroutput">Translator</code> - type of object translating <code class="computeroutput">Value</code> objects
to <code class="computeroutput">Indexable</code> objects (<code class="computeroutput">Point</code> or <code class="computeroutput">Box</code>) which
R-tree can handle.
</li>
<li class="listitem">
<code class="computeroutput">Allocator</code> - the allocator.
</li>
</ul></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id821454"></a>Values, Indexables and default Translator</h4></div></div></div>
<p>
R-tree may store <code class="computeroutput">Value</code>s of any type as long as there is passed
the <code class="computeroutput">Translator</code> which knows how to interpret those <code class="computeroutput">Value</code>s
and extract an object understandable by the R-tree. Those objects are called
<code class="computeroutput">Indexables</code> and they are simply of type adapted to <code class="computeroutput">Point</code>
or <code class="computeroutput">Box</code> concept. Default translator <code class="computeroutput">index::translator::def&lt;Value&gt;</code>
is able to handle <code class="computeroutput">Point</code>, <code class="computeroutput">Box</code>, <code class="computeroutput">std::pair&lt;...&gt;</code>,
pointer, iterator or smart pointer.
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><code class="computeroutput">Indexable = Point | Box</code></li>
<li class="listitem"><code class="computeroutput">BasicValue = Indexable | std::pair&lt;Indexable, T&gt; | std::pair&lt;T, Indexable&gt;</code></li>
<li class="listitem"><code class="computeroutput">Value = BasicValue | BasicValue* | Iterator&lt;BasicValue&gt; | SmartPtr&lt;BasicValue&gt;</code></li>
</ul></div>
<p>
Examples of <code class="computeroutput">Value</code> types:
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><code class="computeroutput">geometry::model::point&lt;...&gt;</code></li>
<li class="listitem"><code class="computeroutput">geometry::model::point_xy&lt;...&gt;</code></li>
<li class="listitem"><code class="computeroutput">geometry::model::box&lt;...&gt;</code></li>
<li class="listitem"><code class="computeroutput">std::pair&lt;geometry::model::box&lt;...&gt;, size_t&gt;</code></li>
</ul></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id821567"></a>Inserting and splitting algorithms</h4></div></div></div>
<p>
<code class="computeroutput">Value</code>s may be inserted to the R-tree in many various ways. Final structure of nodes depends
on algorithms used in the process, especially nodes' splitting algorithm. Currently, three
well-known types of R-trees may be created.
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
Linear - classic R-tree using splitting algorithm of linear complexity
<pre class="programlisting">
index::rtree&lt; Value, index::linear&lt;32, 8&gt; &gt; rt;
</pre>
</li>
<li class="listitem">
Quadratic - classic R-tree using splitting algorithm of quadratic complexity
<pre class="programlisting">
index::rtree&lt; Value, index::quadratic&lt;32, 8&gt; &gt; rt;
</pre>
</li>
<li class="listitem">
R*-tree - splitting algorithm minimizing nodes' overlap with forced reinsertions
<pre class="programlisting">
index::rtree&lt; Value, index::rstar&lt;32, 8&gt; &gt; rt;
</pre>
</li>
</ul></div>
<p>
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="id821613"></a>Inserting and removing Values</h3></div></div></div>
<p>
Create
</p>
<pre class="programlisting">
using namespace boost::geometry;
typedef std::pair&lt;Box, int&gt; Value;
index::rtree&lt; Value, index::quadratic&lt;32, 8&gt; &gt; rt;
</pre>
<p>
Insert and remove by method call
</p>
<pre class="programlisting">
Value v = std::make_pair(Box(...), 0);
rt.insert(v);
rt.remove(v);
</pre>
<p>
or by function call
</p>
<pre class="programlisting">
Value v = std::make_pair(Box(...), 0);
index::insert(rt, v);
index::remove(rt, v);
</pre>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="id821638"></a>Spatial queries</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="rtree.html#id821644">Basic queries</a></span></dt>
<dt><span class="section"><a href="rtree.html#id821693">Spatial predicates</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id821644"></a>Basic queries</h4></div></div></div>
<p>
There are three ways to perform a spatial query. Following queries returns
<code class="computeroutput">Value</code>s intersecting some box_region.
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
Method call
<pre class="programlisting">
std::vector&lt;Value&gt; returned_values;
Box box_region(...);
rt.query(box_region, std::back_inserter(returned_values));
</pre>
</li>
<li class="listitem">
Function call
<pre class="programlisting">
std::vector&lt;Value&gt; returned_values;
Box box_region(...);
index::query(rt, box_region, std::back_inserter(returned_values));
</pre>
</li>
<li class="listitem">
Use of <code class="computeroutput">operator |</code> (as with ranges)
<pre class="programlisting">
Box box_region(...);
BOOST_FOREACH(Value &amp;v, rt | index::query_filtered(box_region))
  ;// do something with v
</pre>
</li>
</ul></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id821693"></a>Spatial predicates</h4></div></div></div>
<p>
It is possible to define other relations between queried <code class="computeroutput">Value</code>s and region/regions
of interest. Names of predicates corresponds to names of Boost.Geometry algorithms.
</p>
<pre class="programlisting">
rt.query(box, std::back_inserter(result)); // default case - intersects
rt.query(index::intersects(box), std::back_inserter(result)); // same as default
rt.query(index::covered_by(box), std::back_inserter(result));
rt.query(index::disjont(box), std::back_inserter(result));
rt.query(index::overlaps(box), std::back_inserter(result));
rt.query(index::within(box), std::back_inserter(result));
</pre>
<p>
All predicates may be negated, e.g.:
</p>
<pre class="programlisting">
rt.query(index::not_intersects(box), std::back_inserter(result));
// or
rt.query(!index::intersects(box), std::back_inserter(result));
// the same as
rt.query(index::disjoint(box), std::back_inserter(result));
</pre>
<p>
It's possible to use some number of predicates by passing <code class="computeroutput">std::pair&lt;Pred1, Pred2&gt;</code>
</p>
<pre class="programlisting">
rt.query(
  std::make_pair(index::intersects(box1), !index::within(box2))
  , std::back_inserter(result));
</pre>
<p>
or <code class="computeroutput">boost::tuple&lt;Pred1, Pred2, Pred3, ...&gt;</code>
</p>
<pre class="programlisting">
rt.query(
  boost::make_tuple(index::intersects(box1), !index::within(box2), index::overlaps(box3))
  , std::back_inserter(result));
</pre>
<p>
There is special predicate <code class="computeroutput">index::value(Fun)</code> taking user-defined function/functor
which checks if <code class="computeroutput">Value</code> should be returned by the query.
</p>
<pre class="programlisting">
bool fun(Value const&amp; v)
{
  return v.is_red();
}

// ...

rt.query(
  boost::make_pair(index::intersects(box), index::value(fun))
  , std::back_inserter(result));
</pre>
<p>
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="id829402"></a>Nearest neighbors queries</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="rtree.html#id829408">k nearest neighbors</a></span></dt>
<dt><span class="section"><a href="rtree.html#id829471">One nearest neighbor</a></span></dt>
<dt><span class="section"><a href="rtree.html#id829507">Distances predicates</a></span></dt>
<dt><span class="section"><a href="rtree.html#id829546">Using spatial predicates</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id829408"></a>k nearest neighbors</h4></div></div></div>
<p>
There are three ways of performing knn queries. Following queries returns
k <code class="computeroutput">Value</code>s closest to some point in space. For <code class="computeroutput">Box</code>es
<code class="computeroutput">Indexable</code>s closest point of a <code class="computeroutput">Box</code> is taken into
account by default.
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
Method call
<pre class="programlisting">
std::vector&lt;Value&gt; returned_values;
Point pt(...);
rt.nearest(pt, k, std::back_inserter(returned_values));
</pre>
</li>
<li class="listitem">
Function call
<pre class="programlisting">
std::vector&lt;Value&gt; returned_values;
Point pt(...);
index::nearest(rt, pt, k, std::back_inserter(returned_values));
</pre>
</li>
<li class="listitem">
Use of <code class="computeroutput">operator |</code><pre class="programlisting">
Point pt(...);
BOOST_FOREACH(Value &amp;v, rt | index::nearest_filtered(pt, k))
  ;// do something with v
</pre>
</li>
</ul></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id829471"></a>One nearest neighbor</h4></div></div></div>
<p>
Another type of nearest neighbor query is searching for the one closest <code class="computeroutput">Value</code>.
If it is found, 1 is returned by the method or function. This kind of query
has only two forms.
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
Method call
<pre class="programlisting">
Value returned_value;
Point pt(...);
size_t n = rt.nearest(pt, returned_value);
</pre>
</li>
<li class="listitem">
Function call
<pre class="programlisting">
Value returned_value;
Point pt(...);
size_t n = index::nearest(rt, pt, returned_value);
</pre>
</li>
</ul></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id829507"></a>Distances predicates</h4></div></div></div>
<p>
It is possible to define if calculated distance between query point and <code class="computeroutput">Value</code> should be
greater, lesser or between some other distances. Those are called <code class="computeroutput">DistancesPredicate</code>s and
may be defined as follows.
</p>
<pre class="programlisting">
std::vector&lt;Value&gt; returned_values;
Point pt(...);

/* default - without bounds */
index::nearest(rt, pt, k, std::back_inserter(returned_values));

/* same as default */
index::nearest(rt, index::unbounded(pt), k, std::back_inserter(returned_values));

/* distance must be greater than or equal to 10 */
index::nearest(rt, index::min_bounded(pt, 10), k, std::back_inserter(returned_values));

/* distance must be lesser than or equal to 500 */
index::nearest(rt, index::max_bounded(pt, 500), k, std::back_inserter(returned_values));

/* distance must be between 10 and 500 */
index::nearest(rt, index::bounded(pt, 10, 500), k, std::back_inserter(returned_values));

</pre>
<p>
</p>
<p>
Furthermore, it's possible to define if the closest, furthest or centroidal point of the
non-point <code class="computeroutput">Indexable</code> should be taken into account in the routine calculating distance.
</p>
<pre class="programlisting">
std::vector&lt;Value&gt; returned_values;
Point pt(...);

/* default - distance between Indexable's closest point and a query point
must be greater than 10 */
index::nearest(rt, index::min_bounded(pt, 10), k, std::back_inserter(returned_values));

/* same as default - distance between Indexable's closest point and a query point
must be greater than 10 */
index::nearest(rt, index::min_bounded(pt, index::near(10)), k, std::back_inserter(returned_values));

/* distance between Indexable's furthest point and a query point
must be greater than 10 */
index::nearest(rt, index::min_bounded(pt, index::far(10)), k, std::back_inserter(returned_values));

/* distance between Indexable's centroid and a query point
must be greater than 10 */
index::nearest(rt, index::min_bounded(pt, index::centroid(10)), k, std::back_inserter(returned_values));
</pre>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id829546"></a>Using spatial predicates</h4></div></div></div>
<p>
It is possible to use spatial predicates described before in nearest neighbors queries.
</p>
<pre class="programlisting">
Value returned_value;
std::vector&lt;Value&gt; returned_values;

Point pt(...);
Box b(...);

size_t n1 = rt.nearest(index::bounded(pt, index::far(1), 10), index::intersects(b), returned_value);

size_t n2 = index::nearest(rt, pt, k, index::within(b), std::back_inserter(returned_values));

BOOST_FOREACH(Value &amp;v, rt | index::nearest_filtered(pt, k, index::covered_by(b)))
  ;// do something with v
</pre>
<p>
</p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2008 Federico J. Fernandez<br>Copyright &#169; 2011 Adam Wulkiewicz<p>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <code class="filename">LICENSE_1_0.txt</code> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="http://www.boost.org/doc/libs/release/doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="http://www.boost.org/doc/libs/release/doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="http://www.boost.org/doc/libs/release/doc/src/images/home.png" alt="Home"></a>
</div>
</body>
</html>
