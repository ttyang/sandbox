#line 27 BOOST_PP_STRINGIZE ( BOOST_GENERIC_DETAIL_NARY_CAT ( BOOST_GENERIC_PREPROCESSED_, ROOT, eric/std_ , BOOST_GENERIC_PREPROCESSED_HEADER_NAME, pp ) )
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "The BOOST_GENERIC_CONCEPT macro must be invoked at global scope. " "To make a concept inside a namespace, use a namespace parameter." ); } namespace boost { namespace generic { namespace std_concept { template< typename X > class RandomAccessIterator; namespace boost_generic_concept_impl_detail { struct boost_generic_detail_concept_implRandomAccessIterator { struct boost_generic_detail_tag { static bool const is_auto_concept = 0 == 1; }; template< typename X > struct boost_generic_detail_params; template< class BoostGenericDetailConceptAndParams > struct boost_generic_detail_params_from_concept; template< typename X > struct boost_generic_detail_params_from_concept < RandomAccessIterator < X > > { typedef boost_generic_detail_params < X > type; }; template< class, class, class, class = void > struct boost_generic_detail_requires_are_valid_0 : ::std::false_type {}; template< class BoostGenericDetailConceptMap , typename X , class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_0 < BoostGenericDetailConceptMap , boost_generic_detail_params < X > , BoostGenericDetailTypenames , typename ::boost::generic::detail::always_void < BidirectionalIterator<X>, LessThanComparable<X> >::type > : ::boost::generic::detail::concepts_are_modeled < BoostGenericDetailConceptMap , BidirectionalIterator<X>, LessThanComparable<X> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailEnabler = void > struct boost_generic_detail_first_passsubscript_reference { typedef ::boost::generic::detail::dummy_type_< 3 > type; }; template< class BoostGenericDetailConceptMap > struct boost_generic_detail_first_passsubscript_reference < BoostGenericDetailConceptMap , typename ::boost::generic::detail::always_void < typename BoostGenericDetailConceptMap:: subscript_reference >::type > { typedef typename BoostGenericDetailConceptMap:: subscript_reference type; }; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_1 : ::std::integral_constant< bool, false > {}; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_1 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < MoveConstructible < subscript_reference > >::type > : ::boost::generic::detail::concept_is_valid < MoveConstructible < subscript_reference > > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_1 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_0 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_1 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_2 : ::std::integral_constant< bool, false > {}; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_2 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < Convertible<subscript_reference, const typename BidirectionalIterator<X>::value_type&> >::type > : ::boost::generic::detail::concept_is_valid < Convertible<subscript_reference, const typename BidirectionalIterator<X>::value_type&> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_2 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_1 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_2 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailConceptMap , typename X > struct boost_generic_detail_first_pass { typedef typename boost_generic_detail_first_passsubscript_reference < BoostGenericDetailConceptMap >::type subscript_reference ; }; template< class, class, class > struct boost_generic_detail_deduce_0subscript_reference { typedef ::boost::generic::detail::no_deduction type; }; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_1 { typedef ::boost::generic::detail::dummy_type type; }; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_1 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ::std::declval< X& >() += ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) ) >::type > { typedef decltype ( ::std::declval< X& >() += ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_1 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_1 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_funs_deduce_1subscript_reference; template< typename X , class BoostGenericDetailAugsubscript_reference, class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_funs_deduce_1subscript_reference < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < BoostGenericDetailAugsubscript_reference, BoostGenericDetailOtherTypenames... > > { typedef BoostGenericDetailAugsubscript_reference subscript_reference; static ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > boost_generic_detail_fun_deducer( ... ); template< class subscript_reference > static ::boost::generic::detail::type_< subscript_reference > boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < X& > ); }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_this_deduce_1subscript_reference : ::boost::mpl::identity < decltype( boost_generic_detail_impl_funs_deduce_1subscript_reference< BoostGenericDetailParams, BoostGenericDetailTypenames >:: boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename boost_generic_detail_return_type_1 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > ::type >() ) ) >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_this_deduce_1subscript_reference : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_impl_this_deduce_1subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deduce_1subscript_reference : ::boost::generic::detail::deduction_result < typename boost_generic_detail_deduce_0subscript_reference< BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::type , boost_generic_detail_this_deduce_1subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_2 { typedef ::boost::generic::detail::dummy_type type; }; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_2 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ::std::declval< const X& >() + ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) ) >::type > { typedef decltype ( ::std::declval< const X& >() + ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_2 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_2 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_funs_deduce_2subscript_reference; template< typename X , class BoostGenericDetailAugsubscript_reference, class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_funs_deduce_2subscript_reference < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < BoostGenericDetailAugsubscript_reference, BoostGenericDetailOtherTypenames... > > { typedef BoostGenericDetailAugsubscript_reference subscript_reference; static ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > boost_generic_detail_fun_deducer( ... ); template< class subscript_reference > static ::boost::generic::detail::type_< subscript_reference > boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < X > ); }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_this_deduce_2subscript_reference : ::boost::mpl::identity < decltype( boost_generic_detail_impl_funs_deduce_2subscript_reference< BoostGenericDetailParams, BoostGenericDetailTypenames >:: boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename boost_generic_detail_return_type_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > ::type >() ) ) >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_this_deduce_2subscript_reference : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_impl_this_deduce_2subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deduce_2subscript_reference : ::boost::generic::detail::deduction_result < typename boost_generic_detail_deduce_1subscript_reference< BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::type , boost_generic_detail_this_deduce_2subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_3 { typedef ::boost::generic::detail::dummy_type type; }; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_3 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ::std::declval< typename BidirectionalIterator<X>::difference_type >() + ::std::declval< const X& >() ) ) >::type > { typedef decltype ( ::std::declval< typename BidirectionalIterator<X>::difference_type >() + ::std::declval< const X& >() ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_3 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_3 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_funs_deduce_3subscript_reference; template< typename X , class BoostGenericDetailAugsubscript_reference, class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_funs_deduce_3subscript_reference < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < BoostGenericDetailAugsubscript_reference, BoostGenericDetailOtherTypenames... > > { typedef BoostGenericDetailAugsubscript_reference subscript_reference; static ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > boost_generic_detail_fun_deducer( ... ); template< class subscript_reference > static ::boost::generic::detail::type_< subscript_reference > boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < X > ); }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_this_deduce_3subscript_reference : ::boost::mpl::identity < decltype( boost_generic_detail_impl_funs_deduce_3subscript_reference< BoostGenericDetailParams, BoostGenericDetailTypenames >:: boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename boost_generic_detail_return_type_3 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > ::type >() ) ) >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_this_deduce_3subscript_reference : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_impl_this_deduce_3subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deduce_3subscript_reference : ::boost::generic::detail::deduction_result < typename boost_generic_detail_deduce_2subscript_reference< BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::type , boost_generic_detail_this_deduce_3subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_4 { typedef ::boost::generic::detail::dummy_type type; }; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_4 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ::std::declval< X& >() -= ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) ) >::type > { typedef decltype ( ::std::declval< X& >() -= ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_4 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_4 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_funs_deduce_4subscript_reference; template< typename X , class BoostGenericDetailAugsubscript_reference, class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_funs_deduce_4subscript_reference < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < BoostGenericDetailAugsubscript_reference, BoostGenericDetailOtherTypenames... > > { typedef BoostGenericDetailAugsubscript_reference subscript_reference; static ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > boost_generic_detail_fun_deducer( ... ); template< class subscript_reference > static ::boost::generic::detail::type_< subscript_reference > boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < X& > ); }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_this_deduce_4subscript_reference : ::boost::mpl::identity < decltype( boost_generic_detail_impl_funs_deduce_4subscript_reference< BoostGenericDetailParams, BoostGenericDetailTypenames >:: boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename boost_generic_detail_return_type_4 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > ::type >() ) ) >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_this_deduce_4subscript_reference : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_impl_this_deduce_4subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deduce_4subscript_reference : ::boost::generic::detail::deduction_result < typename boost_generic_detail_deduce_3subscript_reference< BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::type , boost_generic_detail_this_deduce_4subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_5 { typedef ::boost::generic::detail::dummy_type type; }; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_5 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ::std::declval< const X& >() - ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) ) >::type > { typedef decltype ( ::std::declval< const X& >() - ::std::declval< typename BidirectionalIterator<X>::difference_type >() ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_5 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_5 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_funs_deduce_5subscript_reference; template< typename X , class BoostGenericDetailAugsubscript_reference, class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_funs_deduce_5subscript_reference < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < BoostGenericDetailAugsubscript_reference, BoostGenericDetailOtherTypenames... > > { typedef BoostGenericDetailAugsubscript_reference subscript_reference; static ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > boost_generic_detail_fun_deducer( ... ); template< class subscript_reference > static ::boost::generic::detail::type_< subscript_reference > boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < X > ); }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_this_deduce_5subscript_reference : ::boost::mpl::identity < decltype( boost_generic_detail_impl_funs_deduce_5subscript_reference< BoostGenericDetailParams, BoostGenericDetailTypenames >:: boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename boost_generic_detail_return_type_5 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > ::type >() ) ) >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_this_deduce_5subscript_reference : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_impl_this_deduce_5subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deduce_5subscript_reference : ::boost::generic::detail::deduction_result < typename boost_generic_detail_deduce_4subscript_reference< BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::type , boost_generic_detail_this_deduce_5subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_6 { typedef ::boost::generic::detail::dummy_type type; }; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_6 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ::std::declval< const X& >() - ::std::declval< const X& >() ) ) >::type > { typedef decltype ( ::std::declval< const X& >() - ::std::declval< const X& >() ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_6 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_6 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_funs_deduce_6subscript_reference; template< typename X , class BoostGenericDetailAugsubscript_reference, class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_funs_deduce_6subscript_reference < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < BoostGenericDetailAugsubscript_reference, BoostGenericDetailOtherTypenames... > > { typedef BoostGenericDetailAugsubscript_reference subscript_reference; static ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > boost_generic_detail_fun_deducer( ... ); template< class subscript_reference > static ::boost::generic::detail::type_< subscript_reference > boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename BidirectionalIterator<X>::difference_type > ); }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_this_deduce_6subscript_reference : ::boost::mpl::identity < decltype( boost_generic_detail_impl_funs_deduce_6subscript_reference< BoostGenericDetailParams, BoostGenericDetailTypenames >:: boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename boost_generic_detail_return_type_6 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > ::type >() ) ) >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_this_deduce_6subscript_reference : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_impl_this_deduce_6subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deduce_6subscript_reference : ::boost::generic::detail::deduction_result < typename boost_generic_detail_deduce_5subscript_reference< BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::type , boost_generic_detail_this_deduce_6subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_7 { typedef ::boost::generic::detail::dummy_type type; }; template< typename X , class subscript_reference , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_7 < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < subscript_reference , BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ::std::declval< const X& >() [::std::declval< typename BidirectionalIterator<X>::difference_type >()] ) ) >::type > { typedef decltype ( ::std::declval< const X& >() [::std::declval< typename BidirectionalIterator<X>::difference_type >()] ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_7 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_7 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_funs_deduce_7subscript_reference; template< typename X , class BoostGenericDetailAugsubscript_reference, class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_funs_deduce_7subscript_reference < boost_generic_detail_params < X > , ::boost::generic::detail::type_list < BoostGenericDetailAugsubscript_reference, BoostGenericDetailOtherTypenames... > > { typedef BoostGenericDetailAugsubscript_reference subscript_reference; static ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > boost_generic_detail_fun_deducer( ... ); template< class subscript_reference > static ::boost::generic::detail::type_< subscript_reference > boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < subscript_reference > ); }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_impl_this_deduce_7subscript_reference : ::boost::mpl::identity < decltype( boost_generic_detail_impl_funs_deduce_7subscript_reference< BoostGenericDetailParams, BoostGenericDetailTypenames >:: boost_generic_detail_fun_deducer ( ::boost::generic::detail::type_ < typename boost_generic_detail_return_type_7 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > ::type >() ) ) >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_this_deduce_7subscript_reference : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_impl_this_deduce_7subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::generic::detail::type_< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deduce_7subscript_reference : ::boost::generic::detail::deduction_result < typename boost_generic_detail_deduce_6subscript_reference< BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::type , boost_generic_detail_this_deduce_7subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_deducesubscript_reference : boost_generic_detail_deduce_7subscript_reference < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > {}; template< class, class > struct boost_generic_detail_is_valid_; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class = void > struct boost_generic_detail_parent_concepts { typedef ::std::false_type boost_generic_detail_parent_sub_succeeded; }; template< class BoostGenericDetailConceptMap , typename X > struct boost_generic_detail_parent_concepts < BoostGenericDetailConceptMap , boost_generic_detail_params < X > , typename ::boost::generic::detail::always_void < BidirectionalIterator<X>, LessThanComparable<X> >::type > : virtual boost::generic::detail::completed_concept_map_bases < BoostGenericDetailConceptMap , BidirectionalIterator<X>, LessThanComparable<X> > { typedef ::std::true_type boost_generic_detail_parent_sub_succeeded; }; template< class BoostGenericDetailConceptMap , typename X > struct boost_generic_detail_completed_concept_map : boost_generic_detail_parent_concepts < BoostGenericDetailConceptMap , boost_generic_detail_params < X > > { private: typedef boost_generic_detail_first_pass < BoostGenericDetailConceptMap , X > boost_generic_detail_typename_deducers; typedef boost_generic_detail_completed_concept_map RandomAccessIterator; public: typedef typename ::boost::mpl::eval_if_c < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_typename_deducers:: subscript_reference >::value , boost_generic_detail_deducesubscript_reference < BoostGenericDetailConceptMap , boost_generic_detail_params < X > , ::boost::generic::detail::type_list < typename boost_generic_detail_typename_deducers:: subscript_reference, void********** > > , ::boost::mpl::identity < typename boost_generic_detail_typename_deducers:: subscript_reference > >::type subscript_reference; private: template< class, class > friend struct boost_generic_detail_is_valid_; typedef boost_generic_detail_completed_concept_map boost_generic_detail_completed_concept_map_; typedef boost_generic_detail_params < X > boost_generic_detail_params_; typedef ::boost::generic::detail::type_list < typename boost_generic_detail_completed_concept_map_:: subscript_reference, void > boost_generic_detail_typenames; public: struct boost_generic_detail_is_valid : ::boost::generic::detail::and_ < typename boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded , boost_generic_detail_requires_are_valid_2< boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames > , ::boost::generic::detail::is_not_deduction_error< subscript_reference > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_1 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_return_type_1 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type , X& > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_2 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_return_type_2 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type , X > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_3 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_return_type_3 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type , X > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_4 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_return_type_4 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type , X& > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_5 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_return_type_5 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type , X > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_6 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_return_type_6 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type , typename BidirectionalIterator<X>::difference_type > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_7 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_return_type_7 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type , subscript_reference > > {}; }; template< class, class > struct boost_generic_detail_completed_concept_map_from_concept; template< class BoostGenericDetailConceptMap , typename X > struct boost_generic_detail_completed_concept_map_from_concept < BoostGenericDetailConceptMap , RandomAccessIterator < X > > { typedef boost_generic_detail_completed_concept_map < BoostGenericDetailConceptMap , X > type; }; template< typename X , class BoostGenericDetailConceptMap > struct boost_generic_detail_is_valid_ < RandomAccessIterator < X > , BoostGenericDetailConceptMap > : boost_generic_detail_completed_concept_map < BoostGenericDetailConceptMap , X >::boost_generic_detail_is_valid {}; template< class BoostGenericDetailConceptAndParams , class BoostGenericDetailConceptMap = typename ::boost_generic_concept_map_detail::concept_map_ < BoostGenericDetailConceptAndParams > ::boost_generic_concept_map_impl > struct boost_generic_detail_is_valid : boost_generic_detail_is_valid_ < BoostGenericDetailConceptAndParams , BoostGenericDetailConceptMap >::type {}; }; } typedef boost_generic_concept_impl_detail:: boost_generic_detail_concept_implRandomAccessIterator RandomAccessIteratorBoostGenericDetailImpl; template< typename X > class RandomAccessIterator : boost_generic_concept_impl_detail:: boost_generic_detail_concept_implRandomAccessIterator:: boost_generic_detail_completed_concept_map < typename ::boost_generic_concept_map_detail::concept_map_ < RandomAccessIterator < X > > ::boost_generic_concept_map_impl , X > { typedef boost_generic_concept_impl_detail:: boost_generic_detail_concept_implRandomAccessIterator boost_generic_detail_concept_impl; typedef typename boost_generic_detail_concept_impl::template boost_generic_detail_completed_concept_map < typename ::boost_generic_concept_map_detail::concept_map_ < RandomAccessIterator < X > > ::boost_generic_concept_map_impl , X > boost_generic_detail_completed_concept_map; typedef boost_generic_detail_concept_impl::boost_generic_detail_params < X > boost_generic_detail_params; struct parent_concept_asserts_substitution_failure { struct instantiate; }; struct parent_concept_asserts { struct instantiate; static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < BidirectionalIterator<X>, LessThanComparable<X> >() ) >::type::value , "This message should never be seen." ); }; typedef typename ::std::conditional < boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded::value , parent_concept_asserts , parent_concept_asserts_substitution_failure >::type::instantiate parent_concept_asserts_; static_assert( boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded::value , "parameters unable to be substituted into parent concepts " "(guess: doing so may form a reference to void)." ); public: typedef typename boost_generic_detail_completed_concept_map:: subscript_reference subscript_reference; private: typedef ::boost::generic::detail::type_list < subscript_reference , void > boost_generic_detail_typenames; static_assert ( ::boost::generic::detail::is_not_same < typename RandomAccessIterator :: subscript_reference , ::boost::generic::detail::no_deduction >::value , "typename '" "subscript_reference" "' was not explicitly satisfied and cannot be deduced." ); static_assert ( ::boost::generic::detail::is_not_same < typename RandomAccessIterator :: subscript_reference , ::boost::generic::detail::ambiguous_deduction >::value , "typename '" "subscript_reference" "' was not explicitly satisfied and deduction results in ambiguity." ); static_assert ( ::boost::mpl::or_ < ::boost::is_same < typename RandomAccessIterator :: subscript_reference , ::boost::generic::detail::no_deduction > , ::boost::is_same < typename RandomAccessIterator :: subscript_reference , ::boost::generic::detail::ambiguous_deduction > , ::boost::generic::detail::concept_is_valid < MoveConstructible < typename RandomAccessIterator :: subscript_reference > > >::value , "typename '" "subscript_reference" "' does not model '" "MoveConstructible" "'." ); static_assert ( ::boost::generic::detail::concept_is_valid < Convertible<subscript_reference, const typename BidirectionalIterator<X>::value_type&> >::value , "requires " "Convertible<subscript_reference, const typename BidirectionalIterator<X>::value_type&>" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_1 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "X&" " operator " "+=" "( " "X& , typename BidirectionalIterator<X>::difference_type" " )" ); static_assert ( ::boost::mpl::or_ < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_1 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_1 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type , X& > >::value , "the return type of " "operator " "+=" "( " "X& , typename BidirectionalIterator<X>::difference_type" " )" " is not convertible to " "X&" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_2 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "X" " operator " "+" "( " "const X& x , typename BidirectionalIterator<X>::difference_type n" " )" ); static_assert ( ::boost::mpl::or_ < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_2 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_2 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type , X > >::value , "the return type of " "operator " "+" "( " "const X& x , typename BidirectionalIterator<X>::difference_type n" " )" " is not convertible to " "X" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_3 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "X" " operator " "+" "( " "typename BidirectionalIterator<X>::difference_type n , const X& x" " )" ); static_assert ( ::boost::mpl::or_ < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_3 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_3 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type , X > >::value , "the return type of " "operator " "+" "( " "typename BidirectionalIterator<X>::difference_type n , const X& x" " )" " is not convertible to " "X" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_4 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "X&" " operator " "-=" "( " "X& , typename BidirectionalIterator<X>::difference_type" " )" ); static_assert ( ::boost::mpl::or_ < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_4 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_4 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type , X& > >::value , "the return type of " "operator " "-=" "( " "X& , typename BidirectionalIterator<X>::difference_type" " )" " is not convertible to " "X&" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_5 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "X" " operator " "-" "( " "const X& x , typename BidirectionalIterator<X>::difference_type n" " )" ); static_assert ( ::boost::mpl::or_ < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_5 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_5 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type , X > >::value , "the return type of " "operator " "-" "( " "const X& x , typename BidirectionalIterator<X>::difference_type n" " )" " is not convertible to " "X" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_6 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "typename BidirectionalIterator<X>::difference_type" " operator " "-" "( " "const X& , const X&" " )" ); static_assert ( ::boost::mpl::or_ < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_6 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_6 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type , typename BidirectionalIterator<X>::difference_type > >::value , "the return type of " "operator " "-" "( " "const X& , const X&" " )" " is not convertible to " "typename BidirectionalIterator<X>::difference_type" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_7 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "subscript_reference" " operator " "operator_" "( " "const X& x , typename BidirectionalIterator<X>::difference_type n" " )" ); static_assert ( ::boost::mpl::or_ < ::boost::generic::detail::is_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_7 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_convertible_or_target_is_void < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_7 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type , subscript_reference > >::value , "the return type of " "operator " "operator_" "( " "const X& x , typename BidirectionalIterator<X>::difference_type n" " )" " is not convertible to " "subscript_reference" ); }; } } } namespace boost { namespace generic { namespace detail { template< typename X > struct is_concept < ::boost:: generic:: std_concept:: RandomAccessIterator < X > > : mpl::true_ {}; template< typename X > struct concept_impl_of < ::boost:: generic:: std_concept:: RandomAccessIterator < X > > { static bool const is_specialized = false; static bool const is_auto = 0 ; typedef ::boost:: generic:: std_concept:: boost_generic_concept_impl_detail:: boost_generic_detail_concept_implRandomAccessIterator type; }; } } }
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template< class T > struct concept_map_ < boost::generic::std_concept::RandomAccessIterator < T* > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { typedef T value_type; typedef std::ptrdiff_t difference_type; typedef T& reference; typedef T* pointer; typedef T* postincrement_result; typedef T* postdecrement_result; typedef T& subscript_reference; }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::RandomAccessIterator < T* > >() ) instantiate_; }; }; }
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template< class T > struct concept_map_ < boost::generic::std_concept::RandomAccessIterator < const T* > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { typedef T value_type; typedef std::ptrdiff_t difference_type; typedef const T& reference; typedef const T* pointer; typedef const T* postincrement_result; }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::RandomAccessIterator < const T* > >() ) instantiate_; }; }; }
#undef BOOST_GENERIC_PREPROCESSED_HEADER_NAME
