#line 24 BOOST_PP_STRINGIZE ( BOOST_GENERIC_DETAIL_NARY_CAT ( BOOST_GENERIC_PREPROCESSED_, ROOT, eric/std_ , BOOST_GENERIC_PREPROCESSED_HEADER_NAME, pp ) )
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "The BOOST_GENERIC_CONCEPT macro must be invoked at global scope. " "To make a concept inside a namespace, use a namespace parameter." ); } namespace boost { namespace generic { namespace std_concept { template< bool X > class True; namespace boost_generic_concept_impl_detail { struct boost_generic_detail_concept_implTrue { struct boost_generic_detail_tag { static bool const is_auto_concept = 0 == 1; }; template< bool X > struct boost_generic_detail_params; template< class BoostGenericDetailConceptAndParams > struct boost_generic_detail_params_from_concept; template< bool X > struct boost_generic_detail_params_from_concept < True < X > > { typedef boost_generic_detail_params < X > type; }; template< class, class, class > struct boost_generic_detail_requires_are_valid_0 : ::boost::mpl::true_ {}; template< class BoostGenericDetailConceptMap , bool X > struct boost_generic_detail_first_pass { }; template< class, class > struct boost_generic_detail_is_valid_; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class = void > struct boost_generic_detail_parent_concepts { typedef ::std::false_type boost_generic_detail_parent_sub_succeeded; }; template< class BoostGenericDetailConceptMap , bool X > struct boost_generic_detail_parent_concepts < BoostGenericDetailConceptMap , boost_generic_detail_params < X > , typename ::boost::generic::detail::always_void < >::type > { typedef ::std::true_type boost_generic_detail_parent_sub_succeeded; }; template< class BoostGenericDetailConceptMap , bool X > struct boost_generic_detail_completed_concept_map : boost_generic_detail_parent_concepts < BoostGenericDetailConceptMap , boost_generic_detail_params < X > > { private: typedef boost_generic_detail_first_pass < BoostGenericDetailConceptMap , X > boost_generic_detail_typename_deducers; typedef boost_generic_detail_completed_concept_map True; public: private: template< class, class > friend struct boost_generic_detail_is_valid_; typedef boost_generic_detail_completed_concept_map boost_generic_detail_completed_concept_map_; typedef boost_generic_detail_params < X > boost_generic_detail_params_; typedef ::boost::generic::detail::type_list < void > boost_generic_detail_typenames; public: struct boost_generic_detail_is_valid : ::boost::generic::detail::and_ < typename boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded , boost_generic_detail_requires_are_valid_0< boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames > > {}; }; template< class, class > struct boost_generic_detail_completed_concept_map_from_concept; template< class BoostGenericDetailConceptMap , bool X > struct boost_generic_detail_completed_concept_map_from_concept < BoostGenericDetailConceptMap , True < X > > { typedef boost_generic_detail_completed_concept_map < BoostGenericDetailConceptMap , X > type; }; template< bool X , class BoostGenericDetailConceptMap > struct boost_generic_detail_is_valid_ < True < X > , BoostGenericDetailConceptMap > : boost_generic_detail_completed_concept_map < BoostGenericDetailConceptMap , X >::boost_generic_detail_is_valid {}; template< class BoostGenericDetailConceptAndParams , class BoostGenericDetailConceptMap = typename ::boost_generic_concept_map_detail::concept_map_ < BoostGenericDetailConceptAndParams > ::boost_generic_concept_map_impl > struct boost_generic_detail_is_valid : boost_generic_detail_is_valid_ < BoostGenericDetailConceptAndParams , BoostGenericDetailConceptMap >::type {}; }; } typedef boost_generic_concept_impl_detail:: boost_generic_detail_concept_implTrue TrueBoostGenericDetailImpl; template< bool X > class True : boost_generic_concept_impl_detail:: boost_generic_detail_concept_implTrue:: boost_generic_detail_completed_concept_map < typename ::boost_generic_concept_map_detail::concept_map_ < True < X > > ::boost_generic_concept_map_impl , X > { typedef boost_generic_concept_impl_detail:: boost_generic_detail_concept_implTrue boost_generic_detail_concept_impl; typedef typename boost_generic_detail_concept_impl::template boost_generic_detail_completed_concept_map < typename ::boost_generic_concept_map_detail::concept_map_ < True < X > > ::boost_generic_concept_map_impl , X > boost_generic_detail_completed_concept_map; typedef boost_generic_detail_concept_impl::boost_generic_detail_params < X > boost_generic_detail_params; struct parent_concept_asserts_substitution_failure { struct instantiate; }; struct parent_concept_asserts { struct instantiate; }; typedef typename ::std::conditional < boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded::value , parent_concept_asserts , parent_concept_asserts_substitution_failure >::type::instantiate parent_concept_asserts_; static_assert( boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded::value , "parameters unable to be substituted into parent concepts " "(guess: doing so may form a reference to void)." ); public: private: typedef ::boost::generic::detail::type_list < void > boost_generic_detail_typenames; }; } } } namespace boost { namespace generic { namespace detail { template< bool X > struct is_concept < ::boost:: generic:: std_concept:: True < X > > : mpl::true_ {}; template< bool X > struct concept_impl_of < ::boost:: generic:: std_concept:: True < X > > { static bool const is_specialized = false; static bool const is_auto = 0 ; typedef ::boost:: generic:: std_concept:: boost_generic_concept_impl_detail:: boost_generic_detail_concept_implTrue type; }; } } }
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::True < true > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::True < true > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::True < true > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::True < true >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::True < true > > () ) >::type::value , "This message should never be seen." );
#undef BOOST_GENERIC_PREPROCESSED_HEADER_NAME
