#line 45 BOOST_PP_STRINGIZE ( BOOST_GENERIC_DETAIL_NARY_CAT ( BOOST_GENERIC_PREPROCESSED_, ROOT, eric/std_ , BOOST_GENERIC_PREPROCESSED_HEADER_NAME, pp ) )
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "The BOOST_GENERIC_CONCEPT macro must be invoked at global scope. " "To make a concept inside a namespace, use a namespace parameter." ); } namespace boost { namespace generic { namespace std_concept { template< typename T > class ArithmeticLike; namespace boost_generic_concept_impl_detail { struct boost_generic_detail_concept_implArithmeticLike { struct boost_generic_detail_tag { static bool const is_auto_concept = 0 == 1; }; template< typename T > struct boost_generic_detail_params; template< class BoostGenericDetailConceptAndParams > struct boost_generic_detail_params_from_concept; template< typename T > struct boost_generic_detail_params_from_concept < ArithmeticLike < T > > { typedef boost_generic_detail_params < T > type; }; template< class, class, class, class = void > struct boost_generic_detail_requires_are_valid_0 : ::std::false_type {}; template< class BoostGenericDetailConceptMap , typename T , class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_0 < BoostGenericDetailConceptMap , boost_generic_detail_params < T > , BoostGenericDetailTypenames , typename ::boost::generic::detail::always_void < Regular<T>, LessThanComparable<T>, HasUnaryPlus<T>, HasNegate<T>, HasPlus<T, T>, HasMinus<T, T>, HasMultiply<T, T>, HasDivide<T, T>, HasPreincrement<T>, HasPostincrement<T>, HasPredecrement<T>, HasPostdecrement<T>, HasPlusAssign<T, const T&>, HasMinusAssign<T, const T&>, HasMultiplyAssign<T, const T&>, HasDivideAssign<T, const T&> >::type > : ::boost::generic::detail::concepts_are_modeled < BoostGenericDetailConceptMap , Regular<T>, LessThanComparable<T>, HasUnaryPlus<T>, HasNegate<T>, HasPlus<T, T>, HasMinus<T, T>, HasMultiply<T, T>, HasDivide<T, T>, HasPreincrement<T>, HasPostincrement<T>, HasPredecrement<T>, HasPostdecrement<T>, HasPlusAssign<T, const T&>, HasMinusAssign<T, const T&>, HasMultiplyAssign<T, const T&>, HasDivideAssign<T, const T&> > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_1 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_1 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < Convertible<typename HasUnaryPlus<T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < Convertible<typename HasUnaryPlus<T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_1 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_0 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_1 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_2 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_2 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < Convertible<typename HasNegate<T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < Convertible<typename HasNegate<T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_2 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_1 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_2 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_3 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_3 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < Convertible<typename HasPlus<T, T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < Convertible<typename HasPlus<T, T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_3 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_2 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_3 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_4 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_4 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < Convertible<typename HasMinus<T, T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < Convertible<typename HasMinus<T, T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_4 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_3 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_4 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_5 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_5 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < Convertible<typename HasMultiply<T, T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < Convertible<typename HasMultiply<T, T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_5 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_4 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_5 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_6 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_6 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < Convertible<typename HasDivide<T, T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < Convertible<typename HasDivide<T, T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_6 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_5 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_6 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_7 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_7 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasPreincrement<T>::result_type, T&> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasPreincrement<T>::result_type, T&> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_7 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_6 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_7 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_8 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_8 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasPostincrement<T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasPostincrement<T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_8 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_7 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_8 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_9 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_9 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasPredecrement<T>::result_type, T&> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasPredecrement<T>::result_type, T&> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_9 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_8 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_9 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_10 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_10 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasPostdecrement<T>::result_type, T> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasPostdecrement<T>::result_type, T> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_10 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_9 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_10 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_11 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_11 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasPlusAssign<T, const T&>::result_type, T&> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasPlusAssign<T, const T&>::result_type, T&> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_11 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_10 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_11 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_12 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_12 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasMinusAssign<T, const T&>::result_type, T&> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasMinusAssign<T, const T&>::result_type, T&> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_12 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_11 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_12 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_13 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_13 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasMultiplyAssign<T,const T&>::result_type, T&> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasMultiplyAssign<T,const T&>::result_type, T&> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_13 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_12 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_13 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailParams, class BoostGenericDetailTypenames , class = void > struct boost_generic_detail_impl_requires_are_valid_14 : ::std::integral_constant< bool, false > {}; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_impl_requires_are_valid_14 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < SameType<typename HasDivideAssign<T, const T&>::result_type, T&> >::type > : ::boost::generic::detail::concept_is_valid < SameType<typename HasDivideAssign<T, const T&>::result_type, T&> > {}; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams, class BoostGenericDetailTypenames > struct boost_generic_detail_requires_are_valid_14 : ::boost::mpl::and_ < boost_generic_detail_requires_are_valid_13 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames > , boost_generic_detail_impl_requires_are_valid_14 < BoostGenericDetailParams, BoostGenericDetailTypenames > > {}; template< class BoostGenericDetailConceptMap , typename T > struct boost_generic_detail_first_pass { }; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_1 { typedef ::boost::generic::detail::dummy_type type; }; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_1 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ( ::boost::generic::detail::constructor_fun < T , ::boost::generic::detail::type_list < ::std::intmax_t > >() ) ) ) >::type > { typedef decltype ( ( ::boost::generic::detail::constructor_fun < T , ::boost::generic::detail::type_list < ::std::intmax_t > >() ) ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_1 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_0 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_1 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_2 { typedef ::boost::generic::detail::dummy_type type; }; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_2 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ( ::boost::generic::detail::constructor_fun < T , ::boost::generic::detail::type_list < ::std::uintmax_t > >() ) ) ) >::type > { typedef decltype ( ( ::boost::generic::detail::constructor_fun < T , ::boost::generic::detail::type_list < ::std::uintmax_t > >() ) ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_2 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_0 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_2 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class BoostGenericDetailParams , class BoostGenericDetailTypenames , class BoostGenericDetailEnabler = void > struct boost_generic_detail_return_type_impl_3 { typedef ::boost::generic::detail::dummy_type type; }; template< typename T , class... BoostGenericDetailOtherTypenames > struct boost_generic_detail_return_type_impl_3 < boost_generic_detail_params < T > , ::boost::generic::detail::type_list < BoostGenericDetailOtherTypenames... > , typename ::boost::generic::detail::always_void < decltype ( ( ( ::boost::generic::detail::constructor_fun < T , ::boost::generic::detail::type_list < long double > >() ) ) ) >::type > { typedef decltype ( ( ::boost::generic::detail::constructor_fun < T , ::boost::generic::detail::type_list < long double > >() ) ) type; }; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class BoostGenericDetailTypenames > struct boost_generic_detail_return_type_3 : ::boost::mpl::if_c < boost_generic_detail_requires_are_valid_0 < BoostGenericDetailConceptMap , BoostGenericDetailParams, BoostGenericDetailTypenames >::value , boost_generic_detail_return_type_impl_3 < BoostGenericDetailParams, BoostGenericDetailTypenames > , ::boost::mpl::identity< ::boost::generic::detail::dummy_type > >::type {}; template< class, class > struct boost_generic_detail_is_valid_; template< class BoostGenericDetailConceptMap , class BoostGenericDetailParams , class = void > struct boost_generic_detail_parent_concepts { typedef ::std::false_type boost_generic_detail_parent_sub_succeeded; }; template< class BoostGenericDetailConceptMap , typename T > struct boost_generic_detail_parent_concepts < BoostGenericDetailConceptMap , boost_generic_detail_params < T > , typename ::boost::generic::detail::always_void < Regular<T>, LessThanComparable<T>, HasUnaryPlus<T>, HasNegate<T>, HasPlus<T, T>, HasMinus<T, T>, HasMultiply<T, T>, HasDivide<T, T>, HasPreincrement<T>, HasPostincrement<T>, HasPredecrement<T>, HasPostdecrement<T>, HasPlusAssign<T, const T&>, HasMinusAssign<T, const T&>, HasMultiplyAssign<T, const T&>, HasDivideAssign<T, const T&> >::type > : virtual boost::generic::detail::completed_concept_map_bases < BoostGenericDetailConceptMap , Regular<T>, LessThanComparable<T>, HasUnaryPlus<T>, HasNegate<T>, HasPlus<T, T>, HasMinus<T, T>, HasMultiply<T, T>, HasDivide<T, T>, HasPreincrement<T>, HasPostincrement<T>, HasPredecrement<T>, HasPostdecrement<T>, HasPlusAssign<T, const T&>, HasMinusAssign<T, const T&>, HasMultiplyAssign<T, const T&>, HasDivideAssign<T, const T&> > { typedef ::std::true_type boost_generic_detail_parent_sub_succeeded; }; template< class BoostGenericDetailConceptMap , typename T > struct boost_generic_detail_completed_concept_map : boost_generic_detail_parent_concepts < BoostGenericDetailConceptMap , boost_generic_detail_params < T > > { private: typedef boost_generic_detail_first_pass < BoostGenericDetailConceptMap , T > boost_generic_detail_typename_deducers; typedef boost_generic_detail_completed_concept_map ArithmeticLike; public: private: template< class, class > friend struct boost_generic_detail_is_valid_; typedef boost_generic_detail_completed_concept_map boost_generic_detail_completed_concept_map_; typedef boost_generic_detail_params < T > boost_generic_detail_params_; typedef ::boost::generic::detail::type_list < void > boost_generic_detail_typenames; public: struct boost_generic_detail_is_valid : ::boost::generic::detail::and_ < typename boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded , boost_generic_detail_requires_are_valid_14< boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_1 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_2 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > , ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_return_type_3 < boost_generic_detail_completed_concept_map , boost_generic_detail_params_, boost_generic_detail_typenames >::type > > {}; }; template< class, class > struct boost_generic_detail_completed_concept_map_from_concept; template< class BoostGenericDetailConceptMap , typename T > struct boost_generic_detail_completed_concept_map_from_concept < BoostGenericDetailConceptMap , ArithmeticLike < T > > { typedef boost_generic_detail_completed_concept_map < BoostGenericDetailConceptMap , T > type; }; template< typename T , class BoostGenericDetailConceptMap > struct boost_generic_detail_is_valid_ < ArithmeticLike < T > , BoostGenericDetailConceptMap > : boost_generic_detail_completed_concept_map < BoostGenericDetailConceptMap , T >::boost_generic_detail_is_valid {}; template< class BoostGenericDetailConceptAndParams , class BoostGenericDetailConceptMap = typename ::boost_generic_concept_map_detail::concept_map_ < BoostGenericDetailConceptAndParams > ::boost_generic_concept_map_impl > struct boost_generic_detail_is_valid : boost_generic_detail_is_valid_ < BoostGenericDetailConceptAndParams , BoostGenericDetailConceptMap >::type {}; }; } typedef boost_generic_concept_impl_detail:: boost_generic_detail_concept_implArithmeticLike ArithmeticLikeBoostGenericDetailImpl; template< typename T > class ArithmeticLike : boost_generic_concept_impl_detail:: boost_generic_detail_concept_implArithmeticLike:: boost_generic_detail_completed_concept_map < typename ::boost_generic_concept_map_detail::concept_map_ < ArithmeticLike < T > > ::boost_generic_concept_map_impl , T > { typedef boost_generic_concept_impl_detail:: boost_generic_detail_concept_implArithmeticLike boost_generic_detail_concept_impl; typedef typename boost_generic_detail_concept_impl::template boost_generic_detail_completed_concept_map < typename ::boost_generic_concept_map_detail::concept_map_ < ArithmeticLike < T > > ::boost_generic_concept_map_impl , T > boost_generic_detail_completed_concept_map; typedef boost_generic_detail_concept_impl::boost_generic_detail_params < T > boost_generic_detail_params; struct parent_concept_asserts_substitution_failure { struct instantiate; }; struct parent_concept_asserts { struct instantiate; static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < Regular<T>, LessThanComparable<T>, HasUnaryPlus<T>, HasNegate<T>, HasPlus<T, T>, HasMinus<T, T>, HasMultiply<T, T>, HasDivide<T, T>, HasPreincrement<T>, HasPostincrement<T>, HasPredecrement<T>, HasPostdecrement<T>, HasPlusAssign<T, const T&>, HasMinusAssign<T, const T&>, HasMultiplyAssign<T, const T&>, HasDivideAssign<T, const T&> >() ) >::type::value , "This message should never be seen." ); }; typedef typename ::std::conditional < boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded::value , parent_concept_asserts , parent_concept_asserts_substitution_failure >::type::instantiate parent_concept_asserts_; static_assert( boost_generic_detail_completed_concept_map ::boost_generic_detail_parent_sub_succeeded::value , "parameters unable to be substituted into parent concepts " "(guess: doing so may form a reference to void)." ); public: private: typedef ::boost::generic::detail::type_list < void > boost_generic_detail_typenames; static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_1 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "explicit " "T" "::" "T" "( " "::std::intmax_t" " )" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_2 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "explicit " "T" "::" "T" "( " "::std::uintmax_t" " )" ); static_assert ( ::boost::generic::detail::is_not_dummy_type < typename boost_generic_detail_concept_impl ::template boost_generic_detail_return_type_3 < boost_generic_detail_completed_concept_map , boost_generic_detail_params, boost_generic_detail_typenames >::type >::value , "requires " "explicit " "T" "::" "T" "( " "long double" " )" ); static_assert ( ::boost::generic::detail::concept_is_valid < Convertible<typename HasUnaryPlus<T>::result_type, T> >::value , "requires " "Convertible<typename HasUnaryPlus<T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < Convertible<typename HasNegate<T>::result_type, T> >::value , "requires " "Convertible<typename HasNegate<T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < Convertible<typename HasPlus<T, T>::result_type, T> >::value , "requires " "Convertible<typename HasPlus<T, T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < Convertible<typename HasMinus<T, T>::result_type, T> >::value , "requires " "Convertible<typename HasMinus<T, T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < Convertible<typename HasMultiply<T, T>::result_type, T> >::value , "requires " "Convertible<typename HasMultiply<T, T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < Convertible<typename HasDivide<T, T>::result_type, T> >::value , "requires " "Convertible<typename HasDivide<T, T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasPreincrement<T>::result_type, T&> >::value , "requires " "SameType<typename HasPreincrement<T>::result_type, T&>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasPostincrement<T>::result_type, T> >::value , "requires " "SameType<typename HasPostincrement<T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasPredecrement<T>::result_type, T&> >::value , "requires " "SameType<typename HasPredecrement<T>::result_type, T&>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasPostdecrement<T>::result_type, T> >::value , "requires " "SameType<typename HasPostdecrement<T>::result_type, T>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasPlusAssign<T, const T&>::result_type, T&> >::value , "requires " "SameType<typename HasPlusAssign<T, const T&>::result_type, T&>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasMinusAssign<T, const T&>::result_type, T&> >::value , "requires " "SameType<typename HasMinusAssign<T, const T&>::result_type, T&>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasMultiplyAssign<T,const T&>::result_type, T&> >::value , "requires " "SameType<typename HasMultiplyAssign<T,const T&>::result_type, T&>" ); static_assert ( ::boost::generic::detail::concept_is_valid < SameType<typename HasDivideAssign<T, const T&>::result_type, T&> >::value , "requires " "SameType<typename HasDivideAssign<T, const T&>::result_type, T&>" ); }; } } } namespace boost { namespace generic { namespace detail { template< typename T > struct is_concept < ::boost:: generic:: std_concept:: ArithmeticLike < T > > : mpl::true_ {}; template< typename T > struct concept_impl_of < ::boost:: generic:: std_concept:: ArithmeticLike < T > > { static bool const is_specialized = false; static bool const is_auto = 0 ; typedef ::boost:: generic:: std_concept:: boost_generic_concept_impl_detail:: boost_generic_detail_concept_implArithmeticLike type; }; } } }
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < float > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < float > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < float > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < float >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < float > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < double > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < double > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < double > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < double >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < double > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < long double > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < long double > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < long double > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < long double >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < long double > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < signed char > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < signed char > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < signed char > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < signed char >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < signed char > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < short int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < short int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < short int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < short int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < short int > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < int > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < long int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < long int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < long int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < long int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < long int > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < long long int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < long long int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < long long int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < long long int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < long long int > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < unsigned char > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < unsigned char > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < unsigned char > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < unsigned char >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < unsigned char > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < unsigned short int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < unsigned short int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < unsigned short int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < unsigned short int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < unsigned short int > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < unsigned int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < unsigned int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < unsigned int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < unsigned int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < unsigned int > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < unsigned long int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < unsigned long int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < unsigned long int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < unsigned long int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < unsigned long int > > () ) >::type::value , "This message should never be seen." );
namespace boost_generic_detail_scope_checker { static_assert ( ::boost_generic_detail_scope_checker::boost_generic_detail_is_same_fun < boost_generic_detail_global_scope_check , ::boost_generic_detail_scope_checker ::boost_generic_detail_global_scope_check >::value , "Concept maps must be defined at global scope." ); } namespace boost_generic_concept_map_detail { template<> struct concept_map_ < boost::generic::std_concept::ArithmeticLike < unsigned long long int > >{ static bool const is_auto_concept_definition = false, is_usable = true; struct boost_generic_concept_map_impl { }; template< class BoostGenericDetailDummy = void > struct instantiate { typedef decltype ( ::boost::generic::detail::instantiate_with_dummy < BoostGenericDetailDummy , boost::generic::std_concept::ArithmeticLike < unsigned long long int > >() ) instantiate_; }; }; } static_assert ( ::boost::generic::detail::concept_is_valid < boost::generic::std_concept::ArithmeticLike < unsigned long long int > > ::value , "Concept map does not satisfy the following requirements: " "boost::generic::std_concept::ArithmeticLike < unsigned long long int >" ); static_assert ( ::boost::mpl::identity < decltype ( ::boost::generic::detail::instantiate < boost::generic::std_concept::ArithmeticLike < unsigned long long int > > () ) >::type::value , "This message should never be seen." );
#undef BOOST_GENERIC_PREPROCESSED_HEADER_NAME
