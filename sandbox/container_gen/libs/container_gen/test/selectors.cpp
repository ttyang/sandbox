// Copyright (C) 2012-2013 Cromwell D. Enage
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#define BOOST_TYPEOF_COMPLIANT

#include <boost/config.hpp>
#include <boost/mpl/bool.hpp>
#include <boost/mpl/int.hpp>
#include <boost/container_gen/selectors.hpp>
#include <boost/container_gen/c_str_cmp_selectors.hpp>
#include <boost/container_gen/is_compare_selector.hpp>
#include <boost/container_gen/is_hasher_selector.hpp>
#include <boost/container_gen/is_allocator_selector.hpp>
#include <boost/container_gen/is_container_selector.hpp>
#include <boost/container_gen/is_reversible_selector.hpp>
#include <boost/container_gen/is_random_access_selector.hpp>
#include <boost/container_gen/is_associative_selector.hpp>
#include <boost/container_gen/is_unique_assoc_selector.hpp>
#include <boost/container_gen/is_multiple_assoc_selector.hpp>
#include <boost/container_gen/is_hashed_assoc_selector.hpp>
#include <boost/container_gen/is_flat_assoc_selector.hpp>
#include <boost/container_gen/is_ptr_selector.hpp>
#include <boost/container_gen/is_queue_selector.hpp>
#include <boost/container_gen/is_stack_selector.hpp>
#include <boost/container_gen/is_std_heap_selector.hpp>
#include <boost/container_gen/is_heap_selector.hpp>
#include <boost/container_gen/is_iteratable_heap_selector.hpp>
#include <boost/container_gen/is_order_iter_heap_selector.hpp>
#include <boost/container_gen/is_mutable_heap_selector.hpp>
#include <boost/container_gen/has_stable_iters_selector.hpp>
#include <boost/container_gen/is_tr1_selector.hpp>
#include <boost/container_gen/is_recursive_selector.hpp>

#if defined BOOST_MPL_CFG_NO_HAS_XXX || defined BOOST_TYPEOF_EMULATION
#include <boost/typeof/std/vector.hpp>
#include <boost/typeof/std/deque.hpp>
#include <boost/typeof/std/list.hpp>
#include <boost/typeof/std/set.hpp>
#include <boost/typeof/std/map.hpp>
#include <boost/typeof/std/stack.hpp>
#include <boost/typeof/std/queue.hpp>
#include <boost/typeof/boost/ptr_container/ptr_vector.hpp>
#include <boost/typeof/boost/ptr_container/ptr_deque.hpp>
#include <boost/typeof/boost/ptr_container/ptr_list.hpp>
#include <boost/typeof/boost/ptr_container/ptr_set.hpp>
#include <boost/typeof/boost/ptr_container/ptr_map.hpp>

#if !defined BOOST_MSVC
#include <boost/typeof/std/tr1/array.hpp>
#include <boost/typeof/boost/array.hpp>
#include <boost/typeof/boost/ptr_container/ptr_array.hpp>
#endif

#if defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
#include <boost/typeof/std/slist.hpp>
#include <boost/typeof/std/hash_set.hpp>
#include <boost/typeof/std/hash_map.hpp>
#else
#include <boost/typeof/std/tr1/unordered_set.hpp>
#include <boost/typeof/std/tr1/unordered_map.hpp>
#include <boost/typeof/boost/unordered/unordered_set.hpp>
#include <boost/typeof/boost/unordered/unordered_map.hpp>
#include <boost/typeof/boost/ptr_container/ptr_unordered_set.hpp>
#include <boost/typeof/boost/ptr_container/ptr_unordered_map.hpp>
#include <boost/typeof/boost/container/vector.hpp>
#include <boost/typeof/boost/container/stable_vector.hpp>
#include <boost/typeof/boost/container/deque.hpp>
#include <boost/typeof/boost/container/list.hpp>
#include <boost/typeof/boost/container/slist.hpp>
#include <boost/typeof/boost/container/set.hpp>
#include <boost/typeof/boost/container/map.hpp>
#include <boost/typeof/boost/container/flat_set.hpp>
#include <boost/typeof/boost/container/flat_map.hpp>
#include <boost/typeof/boost/heap/policies.hpp>
#include <boost/typeof/boost/heap/priority_queue.hpp>
#include <boost/typeof/boost/heap/d_ary_heap.hpp>
#include <boost/typeof/boost/heap/binomial_heap.hpp>
#include <boost/typeof/boost/heap/fibonacci_heap.hpp>
#include <boost/typeof/boost/heap/pairing_heap.hpp>
#include <boost/typeof/boost/heap/skew_heap.hpp>
#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
#endif  // BOOST_MPL_CFG_NO_HAS_XXX, BOOST_TYPEOF_EMULATION

#include <boost/mpl/assert.hpp>
#include <boost/mpl/aux_/test.hpp>

//[test__is_compare_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_compare_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::skew_heapS>
    ));
//<-
#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT((
        boost::is_compare_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_compare_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_compare_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_compare_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_compare_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_compare_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_hasher_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_hasher_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::skew_heapS>
    ));
//<-
#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hasher_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hasher_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hasher_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_allocator_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_allocator_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::skew_heapS>
    ));
//<-
#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_allocator_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_allocator_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_allocator_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_container_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::vecS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::dequeS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::setS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::mapS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::multisetS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::stackS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::queueS>));
    BOOST_MPL_ASSERT((boost::is_container_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_container_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_container_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_reversible_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::vecS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::dequeS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_reversible_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::setS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::mapS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::multisetS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT((boost::is_reversible_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_reversible_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_reversible_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_reversible_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_reversible_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_reversible_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_random_access_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT((boost::is_random_access_selector<boost::vecS>));
    BOOST_MPL_ASSERT((boost::is_random_access_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_random_access_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_random_access_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_random_access_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_random_access_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_random_access_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_random_access_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_random_access_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_associative_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::setS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::mapS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::multisetS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT((boost::is_associative_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_associative_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_associative_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_unique_associative_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_unique_associative_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::c_str_greater_than_selector
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<
            boost::std_flat_allocator_selector
        >
    ));
}
//]

//[test__is_multiple_associative_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_multiple_associative_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::c_str_less_than_selector
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::c_str_greater_than_selector
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<
            boost::std_flat_allocator_selector
        >
    ));
}
//]

//[test__is_hashed_associative_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_hashed_associative_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::c_str_greater_than_selector
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<
            boost::std_flat_allocator_selector
        >
    ));
}
//]

//[test__is_flat_associative_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_flat_associative_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_flat_associative_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_flat_associative_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_flat_associative_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_flat_associative_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_ptr_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT((boost::is_ptr_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT((boost::is_ptr_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT((boost::is_ptr_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT((boost::is_ptr_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT((boost::is_ptr_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT((boost::is_ptr_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT((boost::is_ptr_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_ptr_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT((
        boost::is_ptr_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_ptr_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_ptr_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_ptr_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::skew_heapS>
    ));
//<-
#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_queue_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::stackS>));
    BOOST_MPL_ASSERT((boost::is_queue_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_queue_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_queue_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_stack_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT((boost::is_stack_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_stack_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_stack_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_std_heap_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_std_heap_selector<boost::queueS>));
    BOOST_MPL_ASSERT((boost::is_std_heap_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_std_heap_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_heap_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::listS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::slistS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::multimapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::hash_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::hash_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::hash_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::hash_multimapS>));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_heap_selector<boost::std_heapS>));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_heap_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_heap_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_heap_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_heap_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_heap_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_heap_selector<boost::skew_heapS>
    ));
//<-
#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_iteratable_heap_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_iteratable_heap_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_iteratable_heap_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_iteratable_heap_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_iteratable_heap_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_iteratable_heap_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_iteratable_heap_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__is_order_iteratable_heap_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_order_iteratable_heap_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_order_iteratable_heap_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_order_iteratable_heap_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_order_iteratable_heap_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_order_iteratable_heap_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::c_str_less_than_selector
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::c_str_greater_than_selector
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<
            boost::std_flat_allocator_selector
        >
    ));
}
//]

//[test__is_mutable_heap_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_mutable_heap_selector<
//<-
//            boost::d_ary_heap_selector<boost::heap::mutable_<true>,int_<4> >
//->
            boost::d_ary_heap_selector<
                boost::heap::mutable_<true>
              , boost::heap::arity<4>
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_mutable_heap_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_mutable_heap_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_mutable_heap_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::skew_heapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_mutable_heap_selector<
            boost::skew_heap_selector<boost::heap::mutable_<true> >
        >
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_mutable_heap_selector<boost::std_flat_allocator_selector>
    ));
}
//]

//[test__has_stable_iterators_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::listS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || \
    !defined BOOST_NO_SLIST
//->
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::slistS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::multimapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION || defined BOOST_HAS_HASH
//->
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::hash_multimapS>
    ));
//<-
#endif
//->
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::std_heapS>
    ));
//<-
#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::skew_heapS>
    ));
//<-
#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
//->
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::c_str_greater_than_selector
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::has_stable_iterators_selector<
            boost::std_flat_allocator_selector
        >
    ));
}
//]

#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

//[test__is_tr1_selector
MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::slistS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_dequeS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_listS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::stackS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::std_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::vector_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::deque_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::list_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_tr1_selector<
            boost::hash_set_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_tr1_selector<
            boost::hash_map_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_tr1_selector<
            boost::hash_multiset_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_tr1_selector<
            boost::hash_multimap_selector<
//<-
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
//->
                true_
//<-
#endif
//->
            >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::skew_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT((
        boost::is_tr1_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<boost::std_flat_allocator_selector>
    ));
}
//]

#endif  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

MPL_TEST_CASE()
{
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::vecS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::dequeS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::listS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::setS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::mapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::multisetS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::multimapS>));
    BOOST_MPL_ASSERT((boost::is_recursive_selector<boost::ptr_vecS>));
    BOOST_MPL_ASSERT((boost::is_recursive_selector<boost::ptr_dequeS>));
    BOOST_MPL_ASSERT((boost::is_recursive_selector<boost::ptr_listS>));
    BOOST_MPL_ASSERT((boost::is_recursive_selector<boost::ptr_setS>));
    BOOST_MPL_ASSERT((boost::is_recursive_selector<boost::ptr_mapS>));
    BOOST_MPL_ASSERT((boost::is_recursive_selector<boost::ptr_multisetS>));
    BOOST_MPL_ASSERT((boost::is_recursive_selector<boost::ptr_multimapS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::stackS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::queueS>));
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::std_heapS>));
#if defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
#if !defined BOOST_NO_SLIST
    BOOST_MPL_ASSERT_NOT((boost::is_recursive_selector<boost::slistS>));
#endif
#if defined BOOST_HAS_HASH
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::hash_multimapS>
    ));
#endif
#else  // !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::hash_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::ptr_hash_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::ptr_hash_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::ptr_hash_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::ptr_hash_multimapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::vector_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::stable_vecS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::deque_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::list_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::slistS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::set_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::map_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::multiset_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::multimap_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_boost_not_std_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::hash_set_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::hash_map_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::hash_multiset_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<
            boost::hash_multimap_selector<
#if defined BOOST_MPL_CFG_NO_HAS_XXX
                boost::is_tr1_not_boost_arg<true_>
#else
                true_
#endif
            >
        >
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::flat_setS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::flat_mapS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::flat_multisetS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<boost::flat_multimapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::priority_queueS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<
            boost::d_ary_heap_selector<boost::heap::arity<4> >
        >
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::binomial_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::fibonacci_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::pairing_heapS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::skew_heapS>
    ));
#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::equal_to_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::c_str_less_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::c_str_greater_than_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::boost_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::tr1_hash_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::std_allocator_selector>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<boost::std_flat_allocator_selector>
    ));
}

#if !defined BOOST_MSVC
// size_t ambiguity

MPL_TEST_CASE()
{
    typedef boost::array_selector<int_<1> > exArrayS;

    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<exArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<exArrayS>
    ));

    typedef boost::array_selector<int_<1>,true_> exTR1ArrayS;

    BOOST_MPL_ASSERT_NOT((
        boost::is_ptr_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_recursive_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_tr1_selector<exTR1ArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<exTR1ArrayS>
    ));

    typedef boost::ptr_array_selector<int_<1> > exPtrArrayS;

    BOOST_MPL_ASSERT((
        boost::is_ptr_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_random_access_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_associative_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_unique_associative_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_multiple_associative_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_hashed_associative_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_heap_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_iteratable_heap_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_order_iteratable_heap_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::is_recursive_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT_NOT((
        boost::is_tr1_selector<exPtrArrayS>
    ));
    BOOST_MPL_ASSERT((
        boost::has_stable_iterators_selector<exPtrArrayS>
    ));
}

#endif  // BOOST_MSVC

