<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>






<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Contents</title></head><body>

<table style="margin: 0pt; padding: 0pt; width: 100%;" border="0" cellpadding="0" cellspacing="0">
	<tbody><tr>
		<td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top">
		<div style="padding: 5px;" align="center">
			<img src="images/boost.png" border="0" height="86" width="277"><a title="www.boost.org home page" tabindex="2" style="border: medium none ;" href="http://www.boost.org/">
			</a></div>
		<div style="margin: 5px;">
			<h3 class="navbar">Contents</h3>
			<ul>
				<li><a href="index.htm">Boost.Polygon Main Page</a></li>
				<li><a href="gtl_design_overview.htm">Design Overview</a></li>
				<li><a href="gtl_isotropy.htm">Isotropy</a></li>
				<li><a href="gtl_coordinate_concept.htm">Coordinate Concept</a></li>
				<li><a href="gtl_interval_concept.htm">Interval Concept</a></li>
				<li><a href="gtl_point_concept.htm">Point Concept</a></li>
				<li><a href="gtl_rectangle_concept.htm">Rectangle Concept</a></li>
				<li><a href="gtl_polygon_90_concept.htm">Polygon 90 Concept</a></li>
				<li><a href="gtl_polygon_90_with_holes_concept.htm">Polygon 90 
				With Holes Concept</a></li>
				<li><a href="gtl_polygon_45_concept.htm">Polygon 45 Concept</a></li>
				<li><a href="gtl_polygon_45_with_holes_concept.htm">Polygon 45 
				With Holes Concept</a></li>
				<li><a href="gtl_polygon_concept.htm">Polygon Concept</a></li>
				<li><a href="gtl_polygon_with_holes_concept.htm">Polygon With 
				Holes Concept</a></li>
				<li><a href="gtl_polygon_90_set_concept.htm">Polygon 90 Set 
				Concept</a></li>
				<li><a href="gtl_polygon_45_set_concept.htm">Polygon 45 Set 
				Concept</a></li>
				<li><a href="gtl_polygon_set_concept.htm">Polygon Set Concept</a></li>
				<li><a href="gtl_connectivity_extraction_90.htm">Connectivity 
				Extraction 90</a></li>
				<li><a href="gtl_connectivity_extraction_45.htm">Connectivity 
				Extraction 45</a></li>
				<li><a href="gtl_connectivity_extraction.htm">Connectivity 
				Extraction</a></li>
				<li><a href="gtl_property_merge_90.htm">Property Merge 90</a></li>
				<li><a href="gtl_property_merge_45.htm">Property Merge 45</a></li>
				<li><a href="gtl_property_merge.htm">Property Merge</a></li>
				<li><a href="voronoi_unit.htm">Voronoi Main</a></li>
        <li><a href="voronoi_benchmark.htm">Voronoi Benchmark</a></li>

				<li><a href="voronoi_builder.htm">Voronoi Builder</a><br>
				</li>
				<li><a href="voronoi_diagram.htm">Voronoi Diagram</a></li>
        <li><a href="voronoi_robust_fpt.htm">Voronoi Robust FPT</a><br>
        </li>

        <li>Voronoi Predicates</li>

        <li><a href="voronoi_utils.htm">Voronoi Utils</a><br>
        </li>

				
			</ul>
			<h3 class="navbar">Other Resources</h3>
			<ul>
				<li><a href="GTL_boostcon2009.pdf">GTL Boostcon 2009 Paper</a></li>
				<li><a href="GTL_boostcon_draft03.htm">GTL Boostcon 2009 
				Presentation</a></li>
				<li><a href="analysis.htm">Performance Analysis</a></li>
				<li><a href="gtl_tutorial.htm">Layout Versus Schematic Tutorial</a></li>
				<li><a href="gtl_minkowski_tutorial.htm">Minkowski Sum Tutorial</a></li>
				<li><a href="voronoi_diagram_basic_tutorial.htm">Voronoi Basic Tutorial</a></li>
				<li><a href="voronoi_diagram_advanced_tutorial.htm">Voronoi Advanced Tutorial</a></li>
			</ul>
		</div>
		<h3 class="navbar">Polygon Sponsor</h3>
		<div style="padding: 5px;" align="center">
			<img src="images/intlogo.gif" border="0" height="51" width="127"><a title="www.adobe.com home page" tabindex="2" style="border: medium none ;" href="http://www.adobe.com/">
			</a></div>
		</td>
		<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%"><!-- End Header --> 
		<br>
		<p></p>
		<h1>Voronoi Predicates<br>
</h1>In mathematical theory predicate is an operator which returns true or false.<br>
Voronoi predicates contain implementation of a set of geometric
predicates used by Voronoi builder. Except of those it also provides
functors that allow to compute coordinates of centers of inscribed
circles (those correspond to the voronoi vertices) within the given
relative error precision range for both point and segment inputs. This
is a very handy functionality as it allows to improve output precision
simply providing 3rd party IEEE-754 like floating-point types.<br>
      <h1>Geometric Predicates</h1>
The main issues with implementation of any complex geometric
algorithm arise when dealing with robustness of geometric predicates. Usually this
is also the point where commercial projects stand strong agains noncommercial implementations (it's not the case with Voronoi).
For the short example let's consider following code snippet, that could be used to compute orientation of three points:<br>
      <br>
      <span style="font-family: Courier New,Courier,monospace;">double cross_product(double dx1, double dy1, double dx2, double dy2) {</span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">&nbsp; return dx1 * dy2 - dx2 * dy1;</span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">}<br>
      <br>
int main() {<br>
&nbsp; int v = 1 &lt;&lt; 30;&nbsp; // 2 ^ 30<br>
&nbsp; double result = </span><span style="font-family: Courier New,Courier,monospace;">cross_product</span><span style="font-family: Courier New,Courier,monospace;">(v, v - 1, v + 1, v);<br>
&nbsp; printf("%.3f", result);<br>
&nbsp; return 0;<br>
}<br>
      <br>
      </span>The
output of this simple program will be "0.000", while
the correct one is "1.000". In terms of the orientation test this means
that points are collinear instead of being CCW oriented. This is one of
the basic predicates used in any geometric algorithm and taking wrong
output from it may influence the further algorithm exectuion:
corrupting algorithm underlying structures or producing completely
invalid output. Voronoi uses
slightly more complex predicates. To insure that they are robust and
efficient approach that combines two known techniques is used: lazy
arithmetic and multiple
precision computations.<br>
 
      <h1>Lazy Arithmetic</h1>Lazy
arithmetic is based on usage of IEEE-754 floating-point types to
compute expression results. While this approach has a good speed
performance it doesn't produce reliable results all the time (as in the
example above). The way to solve the issue is apart from computing
result of the expression compute the relative error of it also. This will
give us the range of values evaluated result belongs to and based on that we can
come up with two decisions: 1) output the value; 2) recompute the
expression using multi precision types. The way relative errors are
evaluated is explained in the <a href="voronoi_robust_fpt.htm">Voronoi Robust FPT</a> section.<br>
<h1>Multiple Precision arithmetic</h1>In the vast majority of cases
lazy arithmetic approach produces correct result thus furhter
processing is not required. In other cases Voronoi specific or user
provided multiple precision types are used to produce correct result.
However even that doesn't solve all the cases. Multiprecision geometric
predicates could be devided onto two categories:<br>
1) mathematical transformation of the predicate exists that evaluates exact results:<span style="font-family: Courier New,Courier,monospace;"><br>
      <br>
Predicate: A/B + C/D ?&lt; 0;<br>
After math. transform: (A*D + B*C) / (B * D) ?&lt; 0.<br>
      <br>
Predicate: sqrt(A) &lt; 1.2;<br>
After math. transform: A ?&lt; 1.44.<br>
      <br>
      </span>2) the correct result could be produced only by increasing
precision of the multiprecision types and with defined relative error
for the output type:<br>
      <br>
      <span style="font-family: Courier New,Courier,monospace;">Predicate: sqrt(A) + sqrt(B) + sqrt(C) + sqrt(D) + sqrt(E) &lt; 1.2;<br>
Imagine that value of the expression to the left is very close to 1.2.<br>
      </span><br>
      <span style="font-family: Courier New,Courier,monospace;">Predicate: sin(x) &lt; 0.57;<br>
Relativer error of sin function should be known.<br>
      <br>
      </span>Voronoi of points could be implemented using only the
predicates of the first type, however Voronoi of segments could not.
The predicate that doesn't fall into the first category is responsible
for Voronoi circle comparison. However it appears that properly used
this predicate can't corrupt algorithm internal structures and produces
output technically the same as produced in case this predicate falt in
the first category.&nbsp; The main reasons for this are: 1) algorithm
operates with integer coordinate type of input geometries; 2) closely
situated Voronoi vertices are considered to be the same in the output
data structure (this won't influence main targets algorithm is used
for).<span style="font-family: Courier New,Courier,monospace;"><br>
      </span>
</td></tr><tr><td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top"><br>
</td><td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%"><table class="docinfo" id="table2" frame="void" rules="none"><tbody valign="top"><tr><th class="docinfo-name">Copyright:</th>
					<td>Copyright © Intel Corporation 2008-2010.</td>
				</tr>
				<tr class="field">
					<th class="docinfo-name">License:</th>
					<td class="field-body">Distributed under the Boost Software 
					License, Version 1.0. (See accompanying file
					<tt class="literal"><span class="pre">LICENSE_1_0.txt</span></tt> 
					or copy at
					<a class="reference" target="_top" href="http://www.boost.org/LICENSE_1_0.txt">
					http://www.boost.org/LICENSE_1_0.txt</a>)</td>
				</tr>
		</tbody></table>
		</td>
	</tr>
</tbody></table>

</body></html>