<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>








<meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Polygon Usage</title></head><body>

<h1>Voronoi Basic Tutorial<br>
</h1> 
<p>In this tutorial we will cover basic usage of the Boost.Polygon
Voronoi library. In most cases this should cover all you need from the
library. Below we will discuss following topics:<br>
</p>
<ul>
  <li>preparing input geometries;<br>
  </li>
  <li>construction of the Voronoi diagram;</li>
  <li>traversing Voronoi graph;<br>
  </li>
  <li>associating user data with Voronoi primitives;</li>
  <li>rendering Voronoi diagram.</li>
</ul>In the example that goes through this tutorial (<a href="../libs/polygon/voronoi_example/voronoi_basic_tutorial.cpp">voronoi_basic_tutorial.cpp</a>)
we
are going to construct Voronoi diagram of a few points and segments.
On the image below one may see rendered diagram. Primary Voronoi edges
are marked with
black, non-primary with green, input geometries have blue color. In
case you forgot we split each input segment onto three sites (segment
itself and both endpoints), edges that go between those sites are
considered to be non-primary.<br>
<br>
<img style="border: 2px solid ; width: 300px; height: 300px;" alt="" src="images/voronoi4.png"><br>
<br>

And before you start don't forget to:<span style="font-family: Courier New,Courier,monospace;"><br>
<br>
#include "boost/polygon/voronoi.hpp"<br>
using boost::polygon;<br>
</span>
<h2>Preparing Input Geometries</h2>
Before executing the algorithm lets see how the user provided types for
the input geometries might look like:<br>
<br>
<span style="font-family: Courier New,Courier,monospace;">class Point {<br>
public:<br>
&nbsp; Point() {}<br>
&nbsp; Point(int x, int y) { x_ = x; y_ = y; }<br>
<br>
&nbsp; // Those accessors are required!<br>
&nbsp; int x() const { return x_; }<br>
&nbsp; int y() const { return y_; }<br>
<br>
private:<br>
&nbsp; // Don't forget should be castable to the signed int32 type!<br>
&nbsp; int x_;<br>
&nbsp; int y_;<br>
};</span><span style="font-family: Courier New,Courier,monospace;"><br>
<br>
class Segment {<br>
public:<br>
&nbsp; Segment() {}<br>
&nbsp; Segment(int x1, int y1, int x2, int y2) : p0_(x1, y1), p1_(x2, y2) {}<br>
<br>
&nbsp; // Those accessors are required!<br>
&nbsp; Point low() const { return p0_; }<br>
&nbsp; Point high() const { return p1_; }<br>
</span><span style="font-family: Courier New,Courier,monospace;"><br>
private:<br>
&nbsp; Point p0_;<br>
&nbsp; Point p1_;</span><br>
<span style="font-family: Courier New,Courier,monospace;">};<br>
<br>
</span>Once declared we can create sample input:<br>
<br>
<span style="font-family: Courier New,Courier,monospace;">std::vector&lt;Point&gt; points;<br>
points.push_back(Point(0, 0));<br>
points.push_back(Point(1, 6));<br>
std::vector&lt;Segment&gt; segments;<br>
segments.push_back(Segment(-4, 5, 5, -1));<br>
segments.push_back(Segment(3, -11, 13, -1));</span><span style="font-family: Courier New,Courier,monospace;"><br>
</span>
<h2>Construction of the Voronoi Diagram<br>

</h2>



Now let's construct Voronoi diagram of the input set of points and segments:<br>
<br>
<span style="font-family: Courier New,Courier,monospace;">voronoi_diagram&lt;double&gt; vd;<br>
construct_voronoi(points, segments, &amp;vd);<br>
<br>
</span>So brief, isn't that awesome!<br>
<h2>Traversing Voronoi Graph</h2>

At the next step we are going to traverse Voronoi graph and count the
number of visited edges. There are three ways to do that and we are going to cover all of them:<br>
<ul>
  <li>simply iterating over Voronoi edges (counts each edge twice):<br>
    <span style="font-family: Courier New,Courier,monospace;"><br>int iterate_primary_edges1(const voronoi_diagram&lt;double&gt; &amp;vd) {<br>
&nbsp; int result = 0;<br>
&nbsp; for (voronoi_diagram&lt;double&gt;::const_edge_iterator it = vd.edges().begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it != vd.edges().end(); ++it) {<br>
&nbsp;&nbsp;&nbsp; if (it-&gt;is_primary())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++result;<br>
&nbsp; }<br>
&nbsp; return result;<br>
}</span><br>
    <span style="font-family: Courier New,Courier,monospace;">&nbsp;</span><br>
  </li>
  <li>iterating over Voronoi cell and then traversing edges around that cell (counts each edge twice):<br>
    <br>
    <span style="font-family: Courier New,Courier,monospace;">int iterate_primary_edges2(const voronoi_diagram&lt;double&gt; &amp;vd) {<br>
&nbsp; int result = 0;<br>
&nbsp; for (voronoi_diagram&lt;double&gt;::const_cell_iterator it = vd.cells().begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it != vd.cells().end(); ++it) {<br>
&nbsp;&nbsp;&nbsp; const voronoi_diagram&lt;double&gt;::cell_type &amp;cell = *it;<br>
&nbsp;&nbsp;&nbsp; const voronoi_diagram&lt;double&gt;::edge_type *edge = cell.incident_edge();<br>
&nbsp;&nbsp;&nbsp; // This is convenient way to iterate edges around Voronoi cell.<br>
&nbsp;&nbsp;&nbsp; do {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (edge-&gt;is_primary())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++result;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edge = edge-&gt;next();<br>
&nbsp;&nbsp;&nbsp; } while (edge != cell.incident_edge());<br>
&nbsp; }<br>
&nbsp; return result;<br>
}</span><br>
    <br>
  </li>
  
  <li>iterating over Voronoi
vertices and then traversing edges around that vertex (number of
iterations through each edge is equal to the number of finite endpoints
of the edge):<span style="font-family: Courier New,Courier,monospace;"></span><br>
    <span style="font-family: Courier New,Courier,monospace;">int iterate_primary_edges3(const voronoi_diagram&lt;double&gt; &amp;vd) {<br>
&nbsp; int result = 0;<br>
&nbsp; for (voronoi_diagram&lt;double&gt;::const_vertex_iterator it = vd.vertices().begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it != vd.vertices().end(); ++it) {<br>
&nbsp;&nbsp;&nbsp; const voronoi_diagram&lt;double&gt;::vertex_type &amp;vertex = *it;<br>
&nbsp;&nbsp;&nbsp; const voronoi_diagram&lt;double&gt;::edge_type *edge = vertex.incident_edge();<br>
&nbsp;&nbsp;&nbsp; // This is convenient way to iterate edges around Voronoi vertex.<br>
&nbsp;&nbsp;&nbsp; do {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (edge-&gt;is_primary())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++result;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edge = edge-&gt;rot_next();<br>
&nbsp;&nbsp;&nbsp; } while (edge != vertex.incident_edge());<br>
&nbsp; }<br>
&nbsp; return result;<br>
}</span></li>

</ul>This should give a very nice idea on how to traverse Voronoi
diagram. Notice that while the output from the first two methods should
be the same, it wouldn't for the third one. The reason is that in the
last case we will iterate only once through the edges with a single
finite endpoint and will skip all the edges with no finite endpoints.<br>
<h2>Associating User Data with Voronoi Primitives</h2>

A few simple cases of associating user data with Voronoi primitives are following:<br>
<ul>
  <li>associating number of incident edges with each cell, vertex;</li>
  <li>associating color with each edge;</li>
  <li>using DFS or BFS on the Voronoi graph requires to mark visited edges/vertices/cells.</li>
</ul>
We will consider first example and will try to associate total number of incident edges with each cell.<br>
Note: Each Voronoi primitive contains mutable pointer to void* type, that enables to associate any type of data with it.<br>
<br>
<span style="font-family: Courier New,Courier,monospace;">std::vector&lt;int&gt; counts;</span><br>
<span style="font-family: Courier New,Courier,monospace;">// This is required as reallocation of underlying vector will invalidate all the pointers.<br>
counts.reserve(vd.num_cells());<br>
for (voronoi_diagram&lt;double&gt;::const_cell_iterator it = vd.cells().begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp; it != vd.cells().end(); ++it) {<br>
&nbsp; const voronoi_diagram&lt;double&gt;::cell_type &amp;cell = *it;<br>
&nbsp; const voronoi_diagram&lt;double&gt;::edge_type *edge = cell.incident_edge();<br>
&nbsp; int count = 0;<br>
&nbsp; do {<br>
&nbsp;&nbsp;&nbsp; ++count;<br>
&nbsp;&nbsp;&nbsp; edge = edge-&gt;next();<br>
&nbsp; } while (edge != cell.incident_edge());<br>
&nbsp; counts.push_back(count);<br>
&nbsp; cell.data(&amp;counts.back());<br>
}</span><span style="font-family: Courier New,Courier,monospace;"><br>
</span><br>
Note: In the example above we could not simply use count variable
without a vector, because pointer to it will become invalid as soon as
we leave the scope of enclosing for-loop.<br>
<h2>Rendering Voronoi Diagram</h2>

There are two main issues that don't allow to strictly render resulting
Voronoi diagram using such rendering tools as OpenGL or DirectX.
Those are:<br>
<ul>
  <li>Some of the Voronoi edges are infinite, so should be clipped;</li>
  <li>Some of the Voronoi edge are parabolic arcs, so should be discretized.</li>
</ul>Note: This would be the issues not only for rendering tools.
Basically every task that requires diagram to be represented as a set
of finite segments will fall into this category.<br>
All this functionality is already implemented in the Voronoi utils.
Before clipping edges we should define clipping rectangle. It is
usually handy to choose it so that it wraps all the input geometries
plus some offset.<br>
<span style="font-family: Courier New,Courier,monospace;"><br>
bounding_rectangle&lt;double&gt; bbox;<br>
for (std::vector&lt;Point&gt;::iterator it = points.begin(); it != points.end(); ++it)<br>
&nbsp; bbox.update(it-&gt;x(), it-&gt;y());<br>
for (std::vector&lt;Segment&gt;::iterator it = segments.begin(); it != segments.end(); ++it) {<br>
&nbsp; bbox.update(it-&gt;low().x(), it-&gt;low().y());<br>
&nbsp; bbox.update(it-&gt;high().x(), it-&gt;high().y());<br>
}<br>
// Add 10% offset to the bounding rectangle.<br>
bbox = voronoi_utils&lt;double&gt;::scale(bbox, 1.1);</span><span style="font-family: Courier New,Courier,monospace;"><br>
</span><br>
Lets consider that we have 3rd party library function that draws segments using following prototype:<span style="font-family: Courier New,Courier,monospace;"><br>
<br>
void draw_segment(double x1, double y1, double x2, double y2);<br>
<br>
</span>Then function that renders our diagram edges will have following implementation:<br>
<br>
<span style="font-family: Courier New,Courier,monospace;">void render_diagram(const voronoi_diagram&lt;double&gt; &amp;vd,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const voronoi_utils&lt;double&gt;::brect_type &amp;bbox) {<br>
&nbsp; int visited = 1;<br>
&nbsp; for (voronoi_diagram&lt;double&gt;::const_edge_iterator it = vd.edges().begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it != vd.edges().end(); ++it) {<br>
&nbsp;&nbsp;&nbsp; // We use data pointer to mark visited edges.<br>
&nbsp;&nbsp;&nbsp; it-&gt;data(&amp;visited);<br>
&nbsp;&nbsp;&nbsp; // Don't render the same edge twice.<br>
&nbsp;&nbsp;&nbsp; if (it-&gt;twin()-&gt;data()) continue;<br>
&nbsp;&nbsp;&nbsp; voronoi_utils&lt;double&gt;::point_set_type polyline;<br>
&nbsp;&nbsp;&nbsp; if (it-&gt;is_linear())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; voronoi_utils&lt;double&gt;::clip(*it, bbox, polyline);<br>
&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parabolic edges are always finite.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; voronoi_utils&lt;double&gt;::discretize(*it, 1E-1, polyline);<br>
&nbsp;&nbsp;&nbsp; // Note: discretized edges may also lie outside of the bbox.<br>
&nbsp;&nbsp;&nbsp; // So user might do additional clipping before rendering each such edge.&nbsp; <br>
&nbsp;&nbsp;&nbsp; for (int i = 1; i &lt; polyline.size(); ++i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_segment(polyline[i-1].x(), polyline[i-1].y(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
polyline[i].x(), polyline[i].y());<br>
&nbsp; }<br>
}<br>
<br>
</span><a href="../libs/polygon/voronoi_example/voronoi_visualizer.cpp">voronoi_visualizer.cpp</a>
contains a simple fully featured implementation of the Voronoi diagram
renderer using Qt libraries. It was used to generate all the .png
drawings under voronoi_example directory.<span style="text-decoration: underline;"><br>
</span><span style="font-family: Courier New,Courier,monospace;">
<br>
</span>I hope the reader managed to get to this point and found the
Basic tutorial to be useful (in the end it's not so basic). Worth
to notice that construction of the Voronoi diagram takes only two lines
of code, everything else is about initializing input data structures,
traversing Voronoi graph, associating data with diagram primitives and
using <a href="voronoi_utils.htm">Voronoi utilities</a>. In
default mode Voronoi diagram operates with signed int (32 bit) input
coordinate type and double (64 bit) output coordinate type. In <a href="voronoi_advanced_tutorial.htm">Voronoi Advanced Tutorial</a> we explain why this is enough in 95% of problems and how to configure algorithm coordinate types for the other 5%.<br>
<span style="font-family: Courier New,Courier,monospace;"></span><br>
<table class="docinfo" id="table1" frame="void" rules="none">
	<colgroup>
		<col class="docinfo-name"><col class="docinfo-content">
	</colgroup>
	<tbody valign="top">
		<tr>
			<th class="docinfo-name">Copyright:</th>
			<td>Copyright © Intel Corporation 2008-2010.</td>
		</tr>
		<tr class="field">
			<th class="docinfo-name">License:</th>
			<td class="field-body">Distributed under the Boost Software License, 
			Version 1.0. (See accompanying file <tt class="literal">
			<span class="pre">LICENSE_1_0.txt</span></tt> or copy at
			<a class="reference" target="_top" href="http://www.boost.org/LICENSE_1_0.txt">
			http://www.boost.org/LICENSE_1_0.txt</a>)</td>
		</tr>
</tbody></table>

</body></html>