<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>





  
  <meta http-equiv="Content-Language" content="en-us">

  
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Voronoi Main</title>
  

  
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta http-equiv="content-type" content="text/html; charset=utf-8"></head><body>
<table style="margin: 0pt; padding: 0pt; width: 100%;" border="0" cellpadding="0" cellspacing="0">

  <tbody>
    <tr>
      <td style="background-color: rgb(238, 238, 238);" valign="top" nowrap="1">
      <div style="padding: 5px;" align="center"> <img src="images/boost.png" border="0" height="86" width="277"><a title="www.boost.org home page" tabindex="2" style="border: medium none ;" href="http://www.boost.org/"> </a></div>
      <div style="margin: 5px;">
      <h3 class="navbar">Contents</h3>
      <ul>
        <li><a href="index.htm">Boost.Polygon Main Page</a></li>
        <li><a href="gtl_design_overview.htm">Design Overview</a></li>
        <li><a href="gtl_isotropy.htm">Isotropy</a></li>
        <li><a href="gtl_coordinate_concept.htm">Coordinate Concept</a></li>
        <li><a href="gtl_interval_concept.htm">Interval Concept</a></li>
        <li><a href="gtl_point_concept.htm">Point Concept</a></li>
        <li><a href="gtl_rectangle_concept.htm">Rectangle Concept</a></li>
        <li><a href="gtl_polygon_90_concept.htm">Polygon 90 Concept</a></li>
        <li><a href="gtl_polygon_90_with_holes_concept.htm">Polygon 90
With Holes Concept</a></li>
        <li><a href="gtl_polygon_45_concept.htm">Polygon 45 Concept</a></li>
        <li><a href="gtl_polygon_45_with_holes_concept.htm">Polygon 45
With Holes Concept</a></li>
        <li><a href="gtl_polygon_concept.htm">Polygon Concept</a></li>
        <li><a href="gtl_polygon_with_holes_concept.htm">Polygon With
Holes Concept</a></li>
        <li><a href="gtl_polygon_90_set_concept.htm">Polygon 90 Set
Concept</a></li>
        <li><a href="gtl_polygon_45_set_concept.htm">Polygon 45 Set
Concept</a></li>
        <li><a href="gtl_polygon_set_concept.htm">Polygon Set Concept</a></li>
        <li><a href="gtl_connectivity_extraction_90.htm">Connectivity
Extraction 90</a></li>
        <li><a href="gtl_connectivity_extraction_45.htm">Connectivity
Extraction 45</a></li>
        <li><a href="gtl_connectivity_extraction.htm">Connectivity
Extraction</a></li>
        <li><a href="gtl_property_merge_90.htm">Property Merge 90</a></li>
        <li><a href="gtl_property_merge_45.htm">Property Merge 45</a></li>
        <li><a href="gtl_property_merge.htm">Property Merge</a></li>
        <li>Voronoi Main Page<br>
        </li>
        <li><a href="voronoi_benchmark.htm">Voronoi Benchmark</a></li>
        <li><a href="voronoi_builder.htm">Voronoi Builder</a><br>
        </li>
        <li><a href="voronoi_diagram.htm">Voronoi Diagram</a></li>
        <li><a href="voronoi_predicates.htm">Voronoi Predicates</a></li>
        <li><a href="voronoi_robust_fpt.htm">Voronoi Robust FPT</a><br>
        </li>
        <li><a href="voronoi_utils.htm">Voronoi Utils</a><br>
        </li>
      </ul>
      <h3 class="navbar">Other Resources</h3>
      <ul>
        <li><a href="GTL_boostcon2009.pdf">GTL Boostcon 2009 Paper</a></li>
        <li><a href="GTL_boostcon_draft03.htm">GTL Boostcon 2009
Presentation</a></li>
        <li><a href="analysis.htm">Performance Analysis</a></li>
        <li><a href="gtl_tutorial.htm">Layout Versus Schematic Tutorial</a></li>
        <li><a href="gtl_minkowski_tutorial.htm">Minkowski Sum Tutorial</a></li>
        <li><a href="voronoi_basic_tutorial.htm">Voronoi Basic Tutorial</a></li>
        <li><a href="voronoi_advanced_tutorial.htm">Voronoi Advanced
Tutorial</a></li>
      </ul>
      </div>
      <h3 class="navbar">Polygon Sponsor</h3>
      <div style="padding: 5px;" align="center"> <img src="images/intlogo.gif" border="0" height="51" width="127"><a title="www.adobe.com home page" tabindex="2" style="border: medium none ;" href="http://www.adobe.com/"> </a></div>
      </td>
      <td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%"><!-- End Header --> <br>
      
      <h1>THE BOOST.POLYGON VORONOI LIBRARY<br>
      </h1>
      <img style="width: 900px; height: 300px;" alt="" src="images/voronoi3.png"><br>
The Boost.Polygon Voronoi library provides functionality to construct <a href="voronoi_diagram.htm">Voronoi diagram</a>
of a set of points and linear segments in 2D space with the following
set of
limitations:<br>
      <ul>
        <li>coordinates of the input points and endpoints of the
segments
should be of integer type;</li>
        <li>input segments should not intersect
except their endpoints.</li>
      </ul>
While the first restriction is permanent (it
allows to give warranties about the output precision and
algorithm execution),
the second one may be resolved using the Boost.Polygon functionality.
Strong sides of the
library and main benefits comparing to the other implementations are
discussed in the following paragraphs.<span style="font-weight: bold;"></span><br>
      <h2>Robustness and Efficiency</h2>
Lets explain a bit those terms. The efficiency is simply measured by
the time it takes the algorithm to execute. The robustness is a bit
more harder to explain.&nbsp; But those of you who had experience with
the following situations would understand what it doesn't mean:
the application segfaults randomly, the algorithm output contains
degeneracies, the algorithm produces wrong output (e.g. point is considered to be outside of the polygon,
while should be inside). In other words robust implementation doesn't
fail and produces expected output in 100% of cases, thus user can rely
on
it. Robustness is the weak place of the most non-commercial
implementations of any complex geometric algorithm. The main issues of
that could be divided onto two main categories: memory management
issues, numeric stability issues. Our implementation avoids the
first type of issues using pure STL data structures, thus you won't find
any operator new in the code. The second category of problems is
resolved using multiprecision <a href="voronoi_predicates.htm">geometric
predicates</a>.
Even for commercial implementations usage of such predicates usually
results in a huge performance slowdown. Here is another strong side of
the Boost.Polygon
Voronoi library: we avoid multiprecision computations in 95% of cases
using
extremely fast floating-point predicates. Yes, those are not always
exact, but we developed the <a href="voronoi_robust_fpt.htm">relative
error arithmetic apparatus</a> to identify them and switch to the
higher precision predicates when required.<br>
      <h2>Precision of the Output Structures<br>
      </h2>
One of the extremely important results of using two types of predicates
is that library efficiently computes relatively precise coordinates of
the output geometries. Here we will explain a bit what exactly
"relatively precise" means and how the received output may differ from
the theoretically correct one (here and after we assume that output
coordinate type is the IEEE-754 floating-point type).<br>
      <br>
Voronoi implementation guaranties that the relative error of the
coordinates of the output
geometries is always not higher than 64 machine epsilons (6
bits of mantissa), while in many cases it is slightly less. That also
means that using floating-point type with the larger mantissa will
produce the output coordinates with more precise bits. Lets consider
the following example: the output Voronoi
vertex has double (53-bit mantissa) x-coordinate equal to 1.0, then the
absolute error is at most 2^-53 * 2^6 = 2^-47 and the exact value of
x-coordinate lies in the range [1.0 - 2^-47, 1.0 + 2^-47]. For
x-coordinate equal to 2^31, the absolute error will be at most 2^-53 *
2^31 * 2^6 = 2^-16 and the exact value of x-coordinate lies in the
range
[2^31 - 2^-16, 2^31 + 2^16]. For the output Voronoi vertex with long
double
(64-bit mantissa) x-coordinate equal to 2^31, the absolute error will
be at most 2^-64 * 2 ^31 * 2^6 = 2^-27 and the exact value of
x-coordinate
lies in the range [2^31-2^-27, 2^31+2^-27]. If you'd like to become
master of the absolute and relative error try this <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">article</a>.<br>
      <br>
During the finalization step the implementation unites Voronoi vertices whose both
coordinates are situated within the relative error range equal to 128
machine epsilons and removes any Voronoi edges between them. That is
the only case that might cause differences between the algorithm output
topology and theoretically precise one.&nbsp; Now lets see what is the practical
impact of this. Consider following example: we are going to construct
Voronoi diagram of our Solar System. The radius of our solar system is
approximately 2^42 metres, and we are going to snap it to the integer
grid of [-2^42; 2^42] x [-2^42; 2^42].&nbsp; Lets choose the long double
(64 bit mantissa) output coordinate type, then the maximum absolute error
for the output geometries within our Solar System will be on its boundaries
and equal to 2^-64 * 2^42 * 2^6 = 2^-18 metres. In the output we are going to
consider vertices with both coordinates that are within 2^-17 metres (8
micrometres) distance to be equal. Come on that distance is equal to
the size of a bacteria. Can you even see those?<br>
      <h2>Fully Functional with Segment Inputs</h2>
There are not many implementations of the Voronoi diagram construction
algorithm that could
handle segment inputs, even considering the commercial libraries.
Support of the
segments allows to discretize any input geometry (circle, ellipse,
parabola). Of course as the result those might have floating-point
coordinates, but that is resolved using scaling and snapping to the
integer grid. This functionality is very handy as allows to compute
the medial axis transform of the arbitrary set of input geometries. So
one may start
using it for the next generation pattern recognition or computer vision
project.<br>
      <h2>Basic and Advanced Usage Cases</h2>
The main library header <span style="font-family: Courier New,Courier,monospace;">voronoi.hpp</span>
defines the following static functions:<br>
      <br>
      <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; font-family: Courier New,Courier,monospace;">template
&lt;typename PC, typename VD&gt;<br>
static inline void construct_voronoi(<br>
&nbsp; const PC &amp;points, VD *output)<br>
            </td>
            <td style="vertical-align: top;">Constructs Voronoi diagram of a set of points.<br>
Coordinates of the input geometries should belong to the [-2^31,
2^31-1] integer range.<br>
PC is a container of points that model point concept.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; font-family: Courier New,Courier,monospace;">template
&lt;typename SC, typename VD&gt;<br>
static inline void construct_voronoi_segments(<br>
&nbsp; const SC &amp;segments, VD *output)<br>
            </td>
            <td style="vertical-align: top;">Constructs Voronoi diagram of a set of segments.<br>
Coordinates of the input geometries should belong to the [-2^31,
2^31-1] integer range.<br>
SC is a container of segments that supports forward iterator.<br>
Segment object should provide low(), high() public methods to retrieve
endpoints of a segment.<br>
This method is deprecated and will be changed to the concept model the first method conforms.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; font-family: Courier New,Courier,monospace;">template
&lt;typename PC, typename SC, typename VD&gt;<br>
static inline void construct_voronoi(<br>
&nbsp; const PC &amp;points, const SC &amp;segments, VD
*output)<br>
            </td>
            <td style="vertical-align: top;">Constructs Voronoi
diagram of a set of points and segments.<br>
Coordinates of the input geometries should belong to the [-2^31,
2^31-1] integer range.<br>

Segment object should provide low(), high() public methods to retrieve
endpoints of a segment.<br>
This method is depricated and will be changed to the concept model the first method conforms.<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
For the users that don't want to go into the details of the library
this
means that it's possible to construct Voronoi diagram with the
following two lines of code (if this doesn't work for you read <a href="voronoi_builder.htm">Voronoi builder</a> documentation page):<br>
      <br>
      <span style="font-family: Courier New,Courier,monospace;">voronoi_diagram&lt;double&gt;
vd;</span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">construct_voronoi(points,
segments, &amp;vd);</span><br>
      <br>
Isn't that simple? The library also provides the clear interfaces to
      <a href="voronoi_basic_tutorial.htm">associate user data</a> with the output geometries, efficiently <a href="voronoi_diagram.htm">traverse Voronoi graph</a> and utilities to
      <a href="voronoi_utils.htm">visualize output primitives</a> (e.g.
discretization of the parabolic edges, clipping of the linear edges).
More details on those are covered in the <a href="voronoi_basic_tutorial.htm">basic Voronoi tutorial</a>. Advanced usage of the library with the configuration of the coordinate
types is explained in the <a href="voronoi_advanced_tutorial.htm">advanced
Voronoi tutorial</a>.<br>
      <h2>No Third Party Dependencies<br>
      </h2>
Yes, the library doesn't depend on any 3rd party code. The code depends only on the Boost libraries and STL.
All the required multiprecision types functionality is implemented as
part of the library and is not exposed to the user.<br>
      <h2>Extensible for the User Provided Coordinate Types</h2>
Our implementation is coordinate type agnostic. That means that as soon
as user provides types that satisfy set of restrictions of the <a href="voronoi_builder.htm">Voronoi builder</a> coordinate type traits
and implements the library required methods no changes are required
neither
from the algorithm, nor from the implementation of the predicates. So it's
possible to
construct Voronoi diagram for the 256-bit integer input coordinate type
and
512-bit output floating-point type without making any changes to the
internal code.<br>
      <h2>Bright Future<br>
      </h2>
Below one may find the list of the main directions for the future
development of the library.<br>
High-priority tasks that already have approximate implementation plan
are following (some of those may be proposed as future GSoC projects):<br>
      <ul>
        <li>Implementing Delaunay triangulation data structure.<br>
Note: only data structure needs to be implemented that properly
processes events provided by the Voronoi builder.</li>
        <li>Implementing medial axis transform data structure.<br>
Note: in general case the Voronoi diagram has completely the same
geometry
as the medial axis (they are 100% equal), however for many applications
user is not interested in the Voronoi edges inside the hole regions.
The main point
of this data structure is to automatically filter Voronoi edges that
belong to those areas.</li>
        <li>Voronoi
diagram data structure could be used to find K nearest neighbors of N
sites in O(N*K*log(K) + N*log(N)) time. The return value would be a
list of k nearest neighbors for each site.<br>
</li>
        <li>Using the r-tree data structure built on top of the
bounding rectangles around N Voronoi cells to answer the nearest
neighbor queries in log(N) time.<br>
Note: there should be r-tree data structure available soon as part of
the Boost libraries.</li>

        <li>Providing interface to retrieve convex hull of a set of
points and segments from the Voronoi builder once the Voronoi diagram is
constructed in O(N) time.<br>
        </li>
        <li>Closer integration with the interfaces and functionality of
the Boost Polygon Library.<br>
        </li>
      </ul>
High-priority tasks to be considered:<br>
      <ul>
        <li>Dropping the restriction on the non-intersecting input
geometries.</li>
        <li>Integration of the Voronoi diagram structure with the BGL (Boost
Graph Library).</li>
        <li>Support of the other types of distance metrics.</li>
        <li>Construction of the constrained Delaunay triangulation.</li>
        <li>Support of the circle input geometries.</li>
      </ul>
Based on the community suggestions priorities may be changed.<br>
      <h2>Theoretical Research<br>
      </h2>Voronoi
was developed as part of the Google Summer of Code 2010. The
library was actively maintained for the last two years and involved
strong mathematical research in the field of algorithms, data
structures,
relative error arithmetic and numerical robustness. Nowadays one can
often read a scientific article that contains non-practical theoretical
results or implementation with
benchmarks nobody else can reproduce. The opposite story is with
the Boost.Polygon Voronoi library. We provide pure implementation and
benchmarks one may run on
his PC. In case community finds it useful we will incrementally
add more documentation on the theoretical side of our realization. The
authors would like to acknowledge Steven Fortune's article <span style="font-family: Arial,Helvetica,sans-serif;"><span style="font-weight: bold;"></span></span>"<a href="http://dl.acm.org/citation.cfm?id=10549">A Sweepline algorithm
for Voronoi diagrams</a>", that contains the fundamental ideas of the
current implementation.<br>
      </td>
    </tr>
    <tr>
      <td style="background-color: rgb(238, 238, 238);" valign="top" nowrap="1">&nbsp;</td>
      <td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%">
      <table class="docinfo" id="table2" frame="void" rules="none">
        <colgroup> <col class="docinfo-name"><col class="docinfo-content"> </colgroup> <tbody valign="top">
          <tr>
            <th class="docinfo-name">Copyright:</th>
            <td>Copyright © Intel Corporation 2008-2010.</td>
          </tr>
          <tr class="field">
            <th class="docinfo-name">License:</th>
            <td class="field-body">Distributed under the Boost Software
License, Version 1.0. (See accompanying file <tt class="literal"><span class="pre">LICENSE_1_0.txt</span></tt> or copy at <a class="reference" target="_top" href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)</td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
  </tbody>
</table>

</body></html>