<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
































<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Contents</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-type" content="text/html; charset=utf-8"></head><body>

<table style="margin: 0pt; padding: 0pt; width: 100%;" border="0" cellpadding="0" cellspacing="0">
	<tbody><tr>
		<td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top">
		<div style="padding: 5px;" align="center">
			<img src="images/boost.png" border="0" height="86" width="277"><a title="www.boost.org home page" tabindex="2" style="border: medium none ;" href="http://www.boost.org/">
			</a></div>
		<div style="margin: 5px;">
			<h3 class="navbar">Contents</h3>
			<ul>
				<li><a href="index.htm">Boost.Polygon Main Page</a></li>
				<li><a href="gtl_design_overview.htm">Design Overview</a></li>
				<li><a href="gtl_isotropy.htm">Isotropy</a></li>
				<li><a href="gtl_coordinate_concept.htm">Coordinate Concept</a></li>
				<li><a href="gtl_interval_concept.htm">Interval Concept</a></li>
				<li><a href="gtl_point_concept.htm">Point Concept</a></li>
				<li><a href="gtl_rectangle_concept.htm">Rectangle Concept</a></li>
				<li><a href="gtl_polygon_90_concept.htm">Polygon 90 Concept</a></li>
				<li><a href="gtl_polygon_90_with_holes_concept.htm">Polygon 90 
				With Holes Concept</a></li>
				<li><a href="gtl_polygon_45_concept.htm">Polygon 45 Concept</a></li>
				<li><a href="gtl_polygon_45_with_holes_concept.htm">Polygon 45 
				With Holes Concept</a></li>
				<li><a href="gtl_polygon_concept.htm">Polygon Concept</a></li>
				<li><a href="gtl_polygon_with_holes_concept.htm">Polygon With 
				Holes Concept</a></li>
				<li><a href="gtl_polygon_90_set_concept.htm">Polygon 90 Set 
				Concept</a></li>
				<li><a href="gtl_polygon_45_set_concept.htm">Polygon 45 Set 
				Concept</a></li>
				<li><a href="gtl_polygon_set_concept.htm">Polygon Set Concept</a></li>
				<li><a href="gtl_connectivity_extraction_90.htm">Connectivity 
				Extraction 90</a></li>
				<li><a href="gtl_connectivity_extraction_45.htm">Connectivity 
				Extraction 45</a></li>
				<li><a href="gtl_connectivity_extraction.htm">Connectivity 
				Extraction</a></li>
				<li><a href="gtl_property_merge_90.htm">Property Merge 90</a></li>
				<li><a href="gtl_property_merge_45.htm">Property Merge 45</a></li>
				<li><a href="gtl_property_merge.htm">Property Merge</a></li>
				<li>Voronoi Main Page<br>

</li>
        <li><a href="voronoi_benchmark.htm">Voronoi Benchmark</a></li>

				<li><a href="voronoi_builder.htm">Voronoi Builder</a><br>
				</li>
				<li><a href="voronoi_diagram.htm">Voronoi Diagram</a></li>
        <li><a href="voronoi_predicates.htm">Voronoi Predicates</a></li>

        <li><a href="voronoi_robust_fpt.htm">Voronoi Robust FPT</a><br>
        </li>

        

        <li><a href="voronoi_utils.htm">Voronoi Utils</a><br>
        </li>

				
			</ul>
			<h3 class="navbar">Other Resources</h3>
			<ul>
				<li><a href="GTL_boostcon2009.pdf">GTL Boostcon 2009 Paper</a></li>
				<li><a href="GTL_boostcon_draft03.htm">GTL Boostcon 2009 
				Presentation</a></li>
				<li><a href="analysis.htm">Performance Analysis</a></li>
				<li><a href="gtl_tutorial.htm">Layout Versus Schematic Tutorial</a></li>
				<li><a href="gtl_minkowski_tutorial.htm">Minkowski Sum Tutorial</a></li>
				<li><a href="voronoi_basic_tutorial.htm">Voronoi Basic Tutorial</a></li>
				<li><a href="voronoi_advanced_tutorial.htm">Voronoi Advanced Tutorial</a></li>
			</ul>
		</div>
		<h3 class="navbar">Polygon Sponsor</h3>
		<div style="padding: 5px;" align="center">
			<img src="images/intlogo.gif" border="0" height="51" width="127"><a title="www.adobe.com home page" tabindex="2" style="border: medium none ;" href="http://www.adobe.com/">
			</a></div>
		</td>
		<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%"><!-- End Header --> 
		<br>
		<p></p>
      <h1>THE BOOST.POLYGON VORONOI LIBRARY<br>
</h1><img style="width: 900px; height: 300px;" alt="" src="images/voronoi3.png"><br>
The Boost.Polygon Voronoi library provides functionality to construct <a href="voronoi_diagram.htm">Voronoi diagrams</a>
of a set of points and segments in 2D space with the following set of
limitations: 1) coordinates of input points and endpoints of segments
should be of integer type; 2) input segments should not intersect
except their endpoints. While the first restriction is permanent (it
allows to give waranties for algorithm output precision and execution),
the second one may be resolved using Boost.Polygon functionality.
Strong sides of the
library and main benefits comparing to other implementations are
discussed in the following paragraphs.<span style="font-weight: bold;"></span><br>
      
      <h2>Robustness and Efficiency</h2>


Lets explain a bit those terms. The efficiency is simply measured by
the time it takes the algorithm to execute. The robustness is a bit
more harder to explain.&nbsp; But those of you who had experience with
the following situations would understand what it doesn't mean:
application segfaults randomly, the algorithm output contains
degeneracies for some inputs, the algorithm produces wrong output for
some inputs (e.g. point is considered to be outside of the polygon,
while should be inside). In other words robust implementation doesn't
fail and produces valid output in 100% of cases, thus user can rely on
it. Robustness is the weak place of the most non-commercial
implementations of any complex geometric algorithm. The main issues of
that could be devided onto two main categories: memory management
issues, numeric stability issues. Voronoi implementation avoids the
first type of issues using pure STL data structure, thus you won't find
any operator new in the code. The second category of problems is
resolved using multi-precision <a href="voronoi_predicates.htm">geometric predicates</a>.
Even for commercial implementations usage of such predicates usually
results in huge performance slowdown. Here is another strong side of
Voronoi: we avoid multiprecision computations in 95% of cases using
extremely fast floating-point predicates. Yes, those are not always
exact, but we developed <a href="voronoi_robust_fpt.htm">relative error arithmetic apparatus</a> to identify them and switch to higher precision predicates when required.<br>
      
      <h2>Precision of Output Structures<br>

      </h2>

One of the extremely important results of using two types of predicates
is that library efficiently computes relatively precise coordinates of
output geometries. Here we will explain a bit what exactly
"relatively precise" means and how received output may differ from
theoretically correct one (here and after we assume that output
coordinate type is IEEE-754 floating-point type).<br>
<br>
Voronoi implementation guaranties that relative error of the output
geometries coordinates is always not higher then 64 machine epsilons (6
bits of mantissa), while in many cases it is slightly less. That also
means that using floating-point type with larger mantissa will produce
more precise output. Lets consider following example: output Voronoi
vertex has double (53 bit mantissa) x-coordinate equal to 1.0, then
absolute error is at most 2^-53 * 2^6 = 2^-47 and exact value of
x-coordinate lies in the range [1.0 - 2^-47, 1.0 + 2^-47]. For
x-coordinate equal to 2^31, the absolute error will be at most 2^-53 *
2^31 * 2^6 = 2^-16 and exact value of x-coordinate lies in the range
[2^31 - 2^-16, 2^31 + 2^16]. For output Voronoi vertex with long double
(64 bit mantissa) x-coordinate equal to 2^31, the absolute error will
be at most 2^-64 * 2 ^31 * 2^6 = 2^-27 and exact value of x-coordinate
lies in the range [2^31-2^-27, 2^31+2^-27]. If you'd like to become master of absolute and relative errors try this <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">article</a>.<br>
<br>
During finalization step library unites Voronoi vertices whose both
coordinates are situated within relative error range equal to 128
machine epsilons and removes any voronoi edges between them. That is
the only case that might cause differences between algorithm output
topology and the precise one.&nbsp; Now lets see what is the practical
impact of this. Consider following example: we are going to construct
Voronoi diagram of our Solar System. The radius of our solar system is
approximately 2^42 meters, and we are going to snap it to the integer
grid of [-2^42; 2^42] x [-2^42; 2^42].&nbsp; Lets choose long double
(64 bit mantissa) output coordinate type, then maximum absolute error
for output geometries within our solar system will be on its boundary
and equal to 2^-64 * 2^42 * 2^6 = 2^-18. In the output we are going to
consider vertices with both coordinates that are within 2^-17 meters (8
micrometers) distance to be equal. Come on that distance is equal to
the size of bacteria. Can you even see those?<br>
      
      <h2>Fully Functional with Segment Inputs</h2>

There are not many implementations of Voronoi diagrams that could
handle segment inputs, even considering commercial ones. Support of
segments allows to discretize any input geometry (circle, elipse,
parabola). Of course as the result those might have floating-point
coordinates, but that is resolved using scaling and snapping to the
integer grid. This functionality is very handy as allows to compute
medial axis transform of the arbitrary input geometry. So one may start
using it for the next generation pattern recognition or computer vision
project.<br>
      
      <h2>Basic and Advanced Usage Cases</h2>
The main library header <span style="font-family: Courier New,Courier,monospace;">voronoi.hpp</span> defines following static functions:<br>
      <br>
      <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; font-family: Courier New,Courier,monospace;">template &lt;typename PC, typename VD&gt;<br>
static inline void construct_voronoi_points(<br>
&nbsp;&nbsp;&nbsp; const PC &amp;points, VD *output)<br>
            </td>
            <td style="vertical-align: top;">Constructs Voronoi diagram of a set of points into the output data structure.<br>
Coordinates of the input geometries should belong to [-2^31, 2^31-1] integer range.<br>
PC is a container of points that supports forward iterator.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; font-family: Courier New,Courier,monospace;">template &lt;typename SC, typename VD&gt;<br>
static inline void construct_voronoi_segments(<br>
&nbsp;&nbsp;&nbsp; const SC &amp;segments, VD *output)<br>
            </td>
            <td style="vertical-align: top;">Constructs Voronoi diagram of a set of segments into the output data structure.<br>
Coordinates of the input geometries should belong to [-2^31, 2^31-1] integer range.<br>
SC is a container of segments that supports forward iterator.<br>
Segment object should provide low(), high() public methods to retrieve endpoints of a segment.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; font-family: Courier New,Courier,monospace;">template &lt;typename PC, typename SC, typename VD&gt;<br>
static inline void construct_voronoi(<br>
&nbsp;&nbsp;&nbsp; const PC &amp;points, const SC &amp;segments, VD *output)<br>
            </td>
            <td style="vertical-align: top;">Constructs Voronoi diagram of a set of points and segments into the output data structure.<br>
Coordinates of the input geometries should belong to [-2^31, 2^31-1] integer range.<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
For users that don't want to go into the details of the library this
means that it's possible to construct Voronoi diagram with the
following two lines of code:<br>
      <br>
      <span style="font-family: Courier New,Courier,monospace;">voronoi_diagram&lt;double&gt; vd;</span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">construct_voronoi(points, segments, &amp;vd);</span><br>
      <br>
Isn't that simple? The library also provides clear interfaces to associate user data with output geometries, efficiently <a href="voronoi_diagram.htm">traverse Voronoi graph</a> and utilities to <a href="voronoi_utils.htm">visualize output primitives</a> (e.g. discretization of parabolic edges, clipping of linear edges). More details on those is covered in the <a href="voronoi_basic_tutorial.htm">basic Voronoi tutorial</a>.&nbsp; Advanced usage of the library with configuration of the coordinate types is explained in the <a href="voronoi_advanced_tutorial.htm">advanced Voronoi tutorial</a>.<br>

      
      <h2>Extendable for User Provided Coordinate Types</h2>

Voronoi implementation is coordinate type agnostic. That means that as soon as user provided types satisfy set of <a href="voronoi_builder.htm">Voronoi builder</a> coordinate type traits restrictions
and implement library required methods no changes are requied neither
from algorithm, nor from predicates implementation. So it's possible to
construct Voronoi diagram for 256 bit integer input coordinate type and
512 bit output floating-pont type without changing any internal code.<br>

      
      <h2>Bright Future<br>

      </h2>

Below one may find list of main directions for the future development of the library.<br>
      <br>
High-priority tasks that already have approximate implementation plan (some of those may be proposed as future GSoC projects):<br>
      <ul>
        <li>Implementing Delaunay triangulation data structure.<br>
Note: only data structure needs to be implemented that properly processes events provided by Voronoi builder.</li>
        <li>Implementing medial axis transform data structure.<br>
Note: in general case Voronoi diagram has completely the same geometry
as medial axis (they are 100% equal), however for many applications
user is not interested in diagram inside hole regions. The main point
of this data structure is to automatically filter Voronoi edges that
belong to those areas.</li>
        <li>Implementing data structure built on top of Voronoi diagram that allows to execute nearest neighbour queries in O(log N) time.<br>
Note: this would be sort of kd-tree data structure built on top of bounding rectangles around Voronoi cells.</li>
        
        <li>Providing interface to retrieve convex hull of a set of
points and segments from Voronoi builder one's the Voronoi diagram is
constructed in O(N) time.<br>
</li>
        <li>Closer integration with interfaces and functionality of Boost Polygon Library.<br>
        </li>
      </ul>
High-priority tasks to be considered:<br>
      <ul>
        <li>Integration of Voronoi diagram structure with BGL (Boost Graph Library).</li>
        <li>Support of other types of distance metrics.</li>
        <li>Construction of constrained Delaunay triangulation.</li>
        <li>Support of circle input geometries.</li>
        <li>Dropping restriction on non-intersecting input geometries.</li>

      </ul>
Based on the community suggestions priorities may be changed.<br>
      
      <h2>Theoretical Research<br>

      </h2>Voronoi
was developed as part of Google Summer of Code 2010. The
library was actively maintained for the last two years and involved
strong math research in the field of algorithms, data structures,
relative error arithmetic and numerical robustness. Nowadays one can
often read scientific article that contains non-practical theoretical
results or implementation with
benchmarks nobody else can reproduce. The opposite story is with
Voronoi. We provide pure implementation and benchmarks one may run on
his PC. In case community finds it useful we will incrementally
add more documentation on the theoretical side of our realization. The
authors would like to acknowledge Steven Fortune's article <span style="font-family: Arial,Helvetica,sans-serif;"><span style="font-weight: bold;"></span></span>"<a href="http://dl.acm.org/citation.cfm?id=10549">A Sweepline algorithm for Voronoi diagrams</a>", that contains fundamental ideas of the current implementation.<br>



</td>
	</tr>
	<tr>
		<td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top">&nbsp;</td>
		<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%">
		<table class="docinfo" id="table2" frame="void" rules="none">
			<colgroup>
				<col class="docinfo-name"><col class="docinfo-content">
			</colgroup>
			<tbody valign="top">
				<tr>
					<th class="docinfo-name">Copyright:</th>
					<td>Copyright © Intel Corporation 2008-2010.</td>
				</tr>
				<tr class="field">
					<th class="docinfo-name">License:</th>
					<td class="field-body">Distributed under the Boost Software 
					License, Version 1.0. (See accompanying file
					<tt class="literal"><span class="pre">LICENSE_1_0.txt</span></tt> 
					or copy at
					<a class="reference" target="_top" href="http://www.boost.org/LICENSE_1_0.txt">
					http://www.boost.org/LICENSE_1_0.txt</a>)</td>
				</tr>
		</tbody></table>
		</td>
	</tr>
</tbody></table>

</body></html>