<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>



















<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Contents</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-type" content="text/html; charset=utf-8"></head><body>

<table style="margin: 0pt; padding: 0pt; width: 100%;" border="0" cellpadding="0" cellspacing="0">
	<tbody><tr>
		<td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top">
		<div style="padding: 5px;" align="center">
			<img src="images/boost.png" border="0" height="86" width="277"><a title="www.boost.org home page" tabindex="2" style="border: medium none ;" href="http://www.boost.org/">
			</a></div>
		<div style="margin: 5px;">
			<h3 class="navbar">Contents</h3>
			<ul>
				<li><a href="index.htm">Boost.Polygon Main Page</a></li>
				<li><a href="gtl_design_overview.htm">Design Overview</a></li>
				<li><a href="gtl_isotropy.htm">Isotropy</a></li>
				<li><a href="gtl_coordinate_concept.htm">Coordinate Concept</a></li>
				<li><a href="gtl_interval_concept.htm">Interval Concept</a></li>
				<li><a href="gtl_point_concept.htm">Point Concept</a></li>
				<li><a href="gtl_rectangle_concept.htm">Rectangle Concept</a></li>
				<li><a href="gtl_polygon_90_concept.htm">Polygon 90 Concept</a></li>
				<li><a href="gtl_polygon_90_with_holes_concept.htm">Polygon 90 
				With Holes Concept</a></li>
				<li><a href="gtl_polygon_45_concept.htm">Polygon 45 Concept</a></li>
				<li><a href="gtl_polygon_45_with_holes_concept.htm">Polygon 45 
				With Holes Concept</a></li>
				<li><a href="gtl_polygon_concept.htm">Polygon Concept</a></li>
				<li><a href="gtl_polygon_with_holes_concept.htm">Polygon With 
				Holes Concept</a></li>
				<li><a href="gtl_polygon_90_set_concept.htm">Polygon 90 Set 
				Concept</a></li>
				<li><a href="gtl_polygon_45_set_concept.htm">Polygon 45 Set 
				Concept</a></li>
				<li><a href="gtl_polygon_set_concept.htm">Polygon Set Concept</a></li>
				<li><a href="gtl_connectivity_extraction_90.htm">Connectivity 
				Extraction 90</a></li>
				<li><a href="gtl_connectivity_extraction_45.htm">Connectivity 
				Extraction 45</a></li>
				<li><a href="gtl_connectivity_extraction.htm">Connectivity 
				Extraction</a></li>
				<li><a href="gtl_property_merge_90.htm">Property Merge 90</a></li>
				<li><a href="gtl_property_merge_45.htm">Property Merge 45</a></li>
				<li><a href="gtl_property_merge.htm">Property Merge</a></li>
				<li>Voronoi Main Page<br>

</li>
        <li><a href="voronoi_benchmark.htm">Voronoi Benchmark</a></li>

				<li><a href="voronoi_builder.htm">Voronoi Builder</a><br>
				</li>
				<li><a href="voronoi_diagram.htm">Voronoi Diagram</a></li>
        <li><a href="voronoi_robust_fpt.htm">Voronoi Robust FPT</a><br>
        </li>

        <li><a href="voronoi_predicates.htm">Voronoi Predicates</a></li>

        <li><a href="voronoi_utils.htm">Voronoi Utils</a><br>
        </li>

				
			</ul>
			<h3 class="navbar">Other Resources</h3>
			<ul>
				<li><a href="GTL_boostcon2009.pdf">GTL Boostcon 2009 Paper</a></li>
				<li><a href="GTL_boostcon_draft03.htm">GTL Boostcon 2009 
				Presentation</a></li>
				<li><a href="analysis.htm">Performance Analysis</a></li>
				<li><a href="gtl_tutorial.htm">Layout Versus Schematic Tutorial</a></li>
				<li><a href="gtl_minkowski_tutorial.htm">Minkowski Sum Tutorial</a></li>
				<li><a href="voronoi_diagram_basic_tutorial.htm">Voronoi Basic Tutorial</a></li>
				<li><a href="voronoi_diagram_advanced_tutorial.htm">Voronoi Advanced Tutorial</a></li>
			</ul>
		</div>
		<h3 class="navbar">Polygon Sponsor</h3>
		<div style="padding: 5px;" align="center">
			<img src="images/intlogo.gif" border="0" height="51" width="127"><a title="www.adobe.com home page" tabindex="2" style="border: medium none ;" href="http://www.adobe.com/">
			</a></div>
		</td>
		<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%"><!-- End Header --> 
		<br>
		<p></p>
      <h1>Voronoi<br>
</h1>The Boost.Polygon Voronoi library provides functionality to construct <a href="voronoi_diagram.htm">Voronoi diagrams</a>
of a set of points and segments in 2D space with the following set of
limitations: 1) coordinates of input points and endpoints of segments
should be of integer type; 2) input segments should not intersect
except their endpoints. While the first restriction is permanent (it
allows to give waranties for algorithm output precision and execution),
the second one may be waved in the future releases. Strong sides of the
library and main benefits comparing to other implementations are
discussed in the following paragraphs.<br>
      <h1>Robustness and efficiency</h1>
Lets explain a bit those terms. The efficiency is simply measured by
the time it takes the algorithm to execute. The robustness is a bit
more harder to explain.&nbsp; But those of you who had experience with
the following situations would understand what it doesn't mean:
application segfaults randomly, the algorithm output contains
degeneracies for some inputs, the algorithm produces wrong output for
some inputs (e.g. point is considered to be outside of the polygon,
while should be inside). In other words robust implementation doesn't
fail and produces valid output in 100% of cases, thus user can rely on
it. Robustness is the weak place of the most non-commercial
implementations of any complex geometric algorithm. The main issues of
that could be devided onto two main categories: memory management
issues, numeric stability issues. Voronoi implementation avoids the
first type of issues using pure STL data structure, thus you won't find
any operator new in the code. The second category of problems is
resolved using multi-precision <a href="voronoi_predicates.htm">geometric predicates</a>.
Even for commercial implementations usage of such predicates usually
results in huge performance slowdown. Here is another strong side of
Voronoi: we avoid multiprecision computations in 95% of cases using
extremely fast floating-point predicates. Yes, those are not always
exact, but we developed <a href="voronoi_robust_fpt.htm">relative error arithmetic apparatus</a> to identify them and switch to higher precision predicates when required.<br>
      <h1>Precision of output structures<br>
      </h1>

One of the extremely important results of using two types of predicates
is that library efficiently computes relatively precise coordinates of
the output geometries. Here we will explain a bit what exactly
"relatively precise" means and how received output may differ from
theoretically correct one (here and after we assume that output
coordinate type is IEEE-754 floating-point type).<br>
Voronoi implementation guaranties that relative error of the output
geometries coordinates is always not higher then 64 machine epsilons (6
bits of mantissa), while in many cases it is slightly less. That also
means that using floating-point type with larger mantissa will produce
more precise output. Lets consider following example: output Voronoi
vertex has double (53 bit mantissa) x-coordinate equal to 1.0, then
absolute error is at most 2^-53 * 2^6 = 2^-47 and exact value of
x-coordinate lies in the range [1.0 - 2^-47, 1.0 + 2^-47]. For
x-coordinate equal to 2^31, the absolute error will be at most 2^-53 *
2^31 * 2^6 = 2^-16 and exact value of x-coordinate lies in the range
[2^31 - 2^-16, 2^31 + 2^16]. For output Voronoi vertex with long double
(64 bit mantissa) x-coordinate equal to 2^31, the absolute error will
be at most 2^-64 * 2 ^31 * 2^6 = 2^-27 and exact value of x-coordinate
lies in the range [2^31-2^-27, 2^31+2^-27].<br>
During finalization step library unites Voronoi vertices whose both
coordinates are situated within relative error range equal to 128
machine epsilons and removes any voronoi edges between them. That is
the only case that might cause differences between algorithm output
topology and the precise one.&nbsp; Now lets see what is the practical
impact of this. Consider following example: we are going to construct
Voronoi diagram of our Solar System. The radius of our solar system is
approximately 2^42 meters, and we are going to snap it to the integer
grid of [-2^42; 2^42] x [-2^42; 2^42].&nbsp; Lets choose long double
(64 bit mantissa) output coordinate type, then maximum absolute error
for output geometries within our solar system will be on its boundary
and equal to 2^-64 * 2^42 * 2^6 = 2^-18. In the output we are going to
consider vertices with both coordinates that are within 2^-17 meters (8
micrometers) distance to be equal. Come on that distance is equal to
the size of bacteria. Can you even see those? I hope such overview
convinced most pessimistic readers to give a try to our library.<br>
      <h1>Fully functional with segment inputs</h1>
There are not many implementations of Voronoi diagrams that could
handle segment inputs, even considering commercial ones. Support of
segments allows to discretize any input geometry (circle, elipse,
parabola). Of course as the result those might have floating-point
coordinates, but that is resolved using scaling and snapping to the
integer grid. This functionality is very handy as allows to compute
medial axis transform of the arbitrary input geometry. So one may start
using it for the next generation pattern recognition or computer vision
project.<br>
      <h1>Basic and advanced usage cases</h1>
      <h1>Extendable for user provided coordinate types</h1>
Voronoi implementation is coordinate type agnostic. That means that as soon as user provided types satisfy set of <a href="voronoi_builder.htm">Voronoi builder coordinate type traits restrictions</a>
and implement library required methods no changes are requied neither
from algorithm, nor from predicates implementation. So it's possible to
construct Voronoi diagram for 256 bit integer input coordinate type and
512 bit output floating-pont type without changing any internal code.<br>

      <h1>Bright future<br>
      </h1>
Below one may find list of main directions for the future development of the library.<br>
      <br>
High-priority tasks that already have approximate implementation plan:<br>
      <ul>
        <li>Implementing Delaunay triangulation data structure.<br>
Note: only data structure needs to be implemented that properly processes events provided by Voronoi builder.</li>
        <li>Implementing medial axis transform data structure.<br>
Note: in general case Voronoi diagram has completely the same geometry
as medial axis (they are 100% equal), however for many applications
user is not interested in diagram inside hole regions. The main point
of this data structure is to automatically filter Voronoi edges that
belong to those areas.</li>
        <li>Implementing data structure built on top of Voronoi diagram that allows to execute nearest neighbour queries in O(log N) time.<br>
Note: this would be sort of kd-tree data structure built on top of bounding rectangles around Voronoi cells.</li>
        <li>Providing interface to retrieve convex hull of a set of
points and segments from Voronoi builder one's the Voronoi diagram is
constructed in O(N) time.</li>
        <li>Dropping restriction on non-intersecting input geometries.<br>
Note: this means that library will also compute segment intersections if such exist.</li>
        <li>Closer integration with interfaces and functionality of Boost Polygon.<br>
        </li>
      </ul>
High-priority tasks to be considered:<br>
      <ul>
        <li>Integration of Voronoi diagram structure with BGL library.</li>
        <li>Support of other types of distance metrics.</li>
        <li>Construction of constrained Delaunay triangulation.</li>
        <li>Support of circle input geometries.</li>
      </ul>
Based on the community suggestions priorities may be changed.<br>



</td>
	</tr>
	<tr>
		<td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top">&nbsp;</td>
		<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%">
		<table class="docinfo" id="table2" frame="void" rules="none">
			<colgroup>
				<col class="docinfo-name"><col class="docinfo-content">
			</colgroup>
			<tbody valign="top">
				<tr>
					<th class="docinfo-name">Copyright:</th>
					<td>Copyright © Intel Corporation 2008-2010.</td>
				</tr>
				<tr class="field">
					<th class="docinfo-name">License:</th>
					<td class="field-body">Distributed under the Boost Software 
					License, Version 1.0. (See accompanying file
					<tt class="literal"><span class="pre">LICENSE_1_0.txt</span></tt> 
					or copy at
					<a class="reference" target="_top" href="http://www.boost.org/LICENSE_1_0.txt">
					http://www.boost.org/LICENSE_1_0.txt</a>)</td>
				</tr>
		</tbody></table>
		</td>
	</tr>
</tbody></table>

</body></html>