<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="tree" rev:last-revision="$Date: 2012/01/15 06:05:46 $">
  <title>Hierarchical Data Structures and Related Concepts for the C++ Standard Library</title>
  <articleinfo>
    <authorgroup>
    <author>
      <firstname>Bernhard</firstname> <surname>Reiter</surname>
    </author>
    <author>
      <firstname>René</firstname> <surname>Rivera</surname>
    </author>
    </authorgroup>
    <copyright>
      <year>2006</year> <year>2007</year> <year>2008</year> <year>2009</year> <holder>Bernhard
      Reiter</holder>
    </copyright>
    <copyright>
      <year>2006</year> <year>2007</year> <year>2008</year> <year>2009</year> <year>2010</year>
      <year>2011</year> <year>2012</year> <holder>René Rivera</holder>
    </copyright>
    <legalnotice id="tree.legal">
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para>
    </legalnotice>
    <articlepurpose>
      Hierarchical Data Structures and Related Concepts for the C++ Standard Library
    </articlepurpose>
  </articleinfo>
  <section id="tree.preamble">
    <title><link linkend="tree.preamble">Hierarchical Data Structures and Related
    Concepts for the C++ Standard Library</link></title>
    <para>
      <emphasis role="bold">Bernhard Reiter and René Rivera</emphasis>
    </para>
    <variablelist>
      <title/>
      <varlistentry>
        <term>Document No.</term>
        <listitem>
          <para>
            WG21/N????=J16/??-????
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Supercedes</term>
        <listitem>
          <para>
            WG21/N2101=J16/06-0171
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Date</term>
        <listitem>
          <para>
            2012-Jan-15
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Project</term>
        <listitem>
          <para>
            Programming Language C++
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Reply to</term>
        <listitem>
          <para>
            René Rivera &lt;<ulink url="mailto:rrivera@acm.org">rrivera@acm.org</ulink>&gt;
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <section id="tree.preamble.introduction">
      <title><link linkend="tree.preamble.introduction">Introduction</link></title>
      <para>
        This paper proposes addition of library components covering tree structures
        and related concepts to the C++ Standard Library Technical Report 2. The
        proposal is based on work towards a Boost tree component library.
      </para>
      <para>
        The library strives to cover many of the relevant aspects within the vast
        field linked to the notion of trees in computer science.
      </para>
    </section>
    <section id="tree.preamble.motivation_and_scope">
      <title><link linkend="tree.preamble.motivation_and_scope">Motivation and Scope</link></title>
      <section id="tree.preamble.motivation_and_scope.why_is_this_important">
        <title><link linkend="tree.preamble.motivation_and_scope.why_is_this_important">Why
        is this important?</link></title>
        <para>
          This proposal is motivated by the wish to establish methods of dealing
          with hierarchical data structures in a manner that is similar to that of
          the Standard Template Library (STL) for linear ones. That is, it seeks
          to provide clear, straight-forward, versatile and comprehensive concepts,
          data structures and algorithms for trees and related structures that allow
          efficient implementation while not exposing implementation details.
        </para>
        <para>
          In particular, this proposal strives to unite types of hierarchical data
          structures that have historically been treated separately, although there
          is arguably good reason to view their role for algorithms as different
          aspects of common underlying concepts. Formally, this proposal's desired
          scope is covering all <emphasis>rooted ordered connected acyclic graphs</emphasis>.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.what_kinds_of_problems_does_it_a">
        <title><link linkend="tree.preamble.motivation_and_scope.what_kinds_of_problems_does_it_a">What
        kinds of problems does it address, and what kinds of programmers is it intended
        to support?</link></title>
        <para>
          Existing tree implementations as listed in the References section as well
          as the number of posts on C++ related newsgroups give an evidence of very
          general, high interest in tree and related data structures. Formalization
          of how to deal with hierarchical data structures seems to be relevant as
          programmers of any level of skill working in any given field is likely
          to need such a structure at one point.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.is_it_based_on_existing_practice">
        <title><link linkend="tree.preamble.motivation_and_scope.is_it_based_on_existing_practice">Is
        it based on existing practice?</link></title>
        <para>
          No; this proposal originates in an effort to create a generic tree container
          component for <ulink url="http://www.boost.org">Boost</ulink> in the course
          of <ulink url="http://code.google.com/soc/2006/boost/appinfo.html?csaid=E17EA7C7C537C131">Google
          Summer of Code™ 2006</ulink>, so at the time of this writing, implementation
          work is still unfinished and, however inspired by and striving to avoid
          past issues and such ones arising from current implementation efforts (see
          below) it is, it has not been used in practice yet.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.is_there_a_reference_implementat">
        <title><link linkend="tree.preamble.motivation_and_scope.is_there_a_reference_implementat">Is
        there a reference implementation?</link></title>
        <para>
          Yes; the current state is available from svn from <ulink url="http://svn.boost.org/svn/boost/sandbox/tree">http://svn.boost.org/svn/boost/sandbox/tree</ulink>.
        </para>
      </section>
    </section>
    <section id="tree.preamble.impact_on_the_standard">
      <title><link linkend="tree.preamble.impact_on_the_standard">Impact on the Standard</link></title>
      <section id="tree.preamble.impact_on_the_standard.what_does_it_depend_on_and_what_">
        <title><link linkend="tree.preamble.impact_on_the_standard.what_does_it_depend_on_and_what_">What
        does it depend on, and what depends on it?</link></title>
        <para>
          It depends on some standard library components, such as <literal moreinfo="none">std::allocator</literal>
          which is used as the default allocator template argument at some points.
          Concepts like allocators or iterators are reused and in some cases adapted.
        </para>
      </section>
      <section id="tree.preamble.impact_on_the_standard.is_it_a_pure_extension_or_does_i">
        <title><link linkend="tree.preamble.impact_on_the_standard.is_it_a_pure_extension_or_does_i">Is
        it a pure extension, or does it require changes to standard components?</link></title>
        <para>
          Most of the proposed library is a pure extension.
        </para>
        <para>
          Some extensions <literal moreinfo="none">&lt;algorithm&gt;</literal> and some extensions
          to <literal moreinfo="none">&lt;iterator&gt;</literal> are proposed.
        </para>
        <para>
          Additionally, while not proposed herein, it has sometimes been suggested
          to add a template parameter to the STL associative containers <literal moreinfo="none">set</literal>,
          <literal moreinfo="none">multiset</literal>, <literal moreinfo="none">map</literal>, and <literal moreinfo="none">multimap</literal>
          (and possibly an argument to their constructors) specifying a policy for
          storing elements, or, more concretely, what tree. The balancers presented
          in this proposal would lend themselves to such use. Indicating what type
          of balanced hierarchy to use for associative containers would create some
          amount of symmetry to TR1's <literal moreinfo="none">unordered</literal> containers that
          allow specification of a hash functor; it is however a momentous decision
          in which position to put such a parameter. The same position as for <literal moreinfo="none">unordered</literal>
          containers (before the comparison functor) would require changes in existing
          code; making it the last parameter (after the allocator) would allow existing
          code to remain unchanged, but seems somewhat irritating when compared to
          <literal moreinfo="none">unordered</literal> containers.
        </para>
      </section>
      <section id="tree.preamble.impact_on_the_standard.can_it_be_implemented_using_toda">
        <title><link linkend="tree.preamble.impact_on_the_standard.can_it_be_implemented_using_toda">Can
        it be implemented using today's compilers, or does it require language features
        that will only be available as part of C++11</link></title>
        <para>
          It can be, and partly has been, implemented with today's compilers.
        </para>
        <para>
          Note that it might be worthwhile to investigate if the present Container
          concept should be modified so that it only covers the requirements as of
          paragraph 2 of section <ulink url="#tr.hierarchy.req">[tr.hierarchy.req]</ulink>
          of this proposal, which correspond to the current Container concept with
          the exception of any expressions that implicitly assume linear internal
          structure and outsource those to a "Linear Container" concept
          as similarly formalized in the <ulink url="http://boost.org/libs/range/doc/range.html">Boost
          Range concept</ulink> (<ulink url="http://boost.org/libs/range/doc/range.html">http://boost.org/libs/range/doc/range.html</ulink>)
          externally to the Standard.
        </para>
      </section>
    </section>
    <section id="tree.preamble.important_design_decisions">
      <title><link linkend="tree.preamble.important_design_decisions">Important Design
      Decisions</link></title>
      <section id="tree.preamble.important_design_decisions.why_did_you_choose_the_specific_">
        <title><link linkend="tree.preamble.important_design_decisions.why_did_you_choose_the_specific_">Why
        did you choose the specific design that you did?</link></title>
        <para>
          One of the most important assets of the present design is the cursor concept
          as a hierarchical continuation to the STL's iterator concept, and the externally
          defined range concept. Among their benefits, cursors allow to handle both
          client data access, by dereference, and subtree access while hiding the
          normally underlying node structure and providing a uniform interface to
          algorithms that are thus enabled to deal with a number of different kinds
          of trees. On the other hand, this abstraction achieves independence of
          implementation details, such as nodes for storage in many cases, allowing
          the underlying concepts to be applicable to other possible implementations
          as well.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid">
        <title><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid">What
        alternatives did you consider, and what are the tradeoffs?</link></title>
        <bridgehead renderas="sect5" id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.h0">
          <phrase id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.trees_of_trees"/><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.trees_of_trees">Trees
          of trees</link>
        </bridgehead>
        <para>
          Trees, being recursively defined data structures, seem to somewhat lend
          themselves to recursive implementation, i.e. declaring them in a way so
          they consist of a client value part and a certain number of trees in turn
          (as e.g. in case of <link linkend="haas">[haas]</link>). Such an approach
          would allow for uniform treatment of the subtrees, but would duplicate
          allocators and imply structure that need not be present. The tree, like
          existing STL containers, should be responsible for data representation
          and storage.
        </para>
        <bridgehead renderas="sect5" id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.h1">
          <phrase id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.augmentors_balancers_as_policies"/><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.augmentors_balancers_as_policies">Augmentors/balancers
          as policies</link>
        </bridgehead>
        <para>
          Inspired by <link linkend="austern">[austern]</link> and <link linkend="dreizin">[dreizin]</link>,
          the original approach undertaken when working on the reference implementation
          was to pass policy template arguments to template class <literal moreinfo="none">binary_tree</literal>.
          While reproducing the (otherwise unbalanced) tree/cursor interface seemed
          logical at first, it turned out that this was conceptually not entirely
          clean, as e.g. it preferred one type of linear order, namely inorder, over
          the others by putting such strong focus on inorder-invariant balancing
          and its possible applications; also, balancing and augmenting metadata
          would inevitably have been much more visible. It seemed more appropriate
          to have different balancing adaptors and augmenting adaptors that would
          replicate the interface to do that work.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_are_the_consequences_of_you">
        <title><link linkend="tree.preamble.important_design_decisions.what_are_the_consequences_of_you">What
        are the consequences of your choices, for users and implementors?</link></title>
        <para>
          As focus was put on versatility and comprehensiveness, we hope users will
          find this a powerful framework that covers most important aspects of dealing
          with hierarchical data structures in a rather intuitive way, once they
          have adapted to the notion of cursors which, although being the interface
          relevant portion of the well-known node implementation of trees, partly
          diverge in their usage from plain node objects.
        </para>
        <para>
          Wherever reasonably possible, strong time complexity guarantees are given,
          which mostly, while trying not to require much space overhead, demand implementations
          that make use of any time and space saving techniques available (e.g. using
          arrays for both children of a binary tree node, see e.g. <link linkend="austern">[austern]</link>),
          which may partly restrict implementors to one "proper" way of
          doing things.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_decisions_are_left_up_to_im">
        <title><link linkend="tree.preamble.important_design_decisions.what_decisions_are_left_up_to_im">What
        decisions are left up to implementors?</link></title>
        <para>
          Most of the requirements for the library components presented in this proposal
          are rather tightly formulated in order to allow for them being both efficient
          and general enough. It is however hoped that the conceptual abstraction
          of hierarchies and cursors may be of general use, also allowing for more
          specific implementations where required (although probably not as part
          of the library; ideally comparable to the role of containers and iterators
          in modern C++ code).
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.if_there_are_any_similar_librari">
        <title><link linkend="tree.preamble.important_design_decisions.if_there_are_any_similar_librari">If
        there are any similar libraries in use, how do their design decisions compare
        to yours?</link></title>
        <para>
          Trees, having attracted much attention in the C++ community, are found
          in various implementations and as subjects of a number of papers. Contrary
          to the present proposal, practically all of them deal either with trees
          as used for sorted associative containers (with logarithmic time complexity
          for more relevant operations, achieved by some sort of balancing; examples
          are <link linkend="dreizin">[dreizin]</link>, <link linkend="ekman">[ekman]</link>
          and <link linkend="karas">[karas]</link>; plus, most current STL implementations
          use a red-black tree as their associative containers' base) or with what
          we call "external" hierarchies in the following (whose structure
          is dictated e.g. by a file system directory tree, an XML file or an AST;
          see e.g. <link linkend="gottschlich">[gottschlich]</link>, <link linkend="haas">[haas]</link>,
          <link linkend="parent">[parent]</link> and <link linkend="peeters">[peeters]</link>),
          but rarely both fields of application.
        </para>
        <para>
          Approaches as found in <link linkend="austern">[austern]</link> or <link linkend="mirwaisi">[mirwaisi]</link> go some steps further and have provided
          valuable inspiration for this project, but still do not formalize anything
          similar as the cursor-based interface in this proposal for dealing with
          a tree's contents.
        </para>
        <para>
          The <ulink url="http://www.boost.org/libs/graph/">BGL</ulink>, finally,
          deals with graphs that are even more general than hierarchical ones, which
          does not allow them to profit from specific hierarchy properties as much
          as the ones presented in this proposal. Making cursors logical extensions
          of iterators would probably also have been more difficult with a BGL-based
          approach.
        </para>
      </section>
    </section>
    <section id="tree.preamble.future_directions">
      <title><link linkend="tree.preamble.future_directions">Future Directions</link></title>
      <para>
        While it is hoped that the current proposal somewhat reunites balanced binary
        trees, B-trees and "external" hierarchies, which should also facilitate
        work with some higher-level structures (e.g. n-ary trees to implement tries),
        some of those higher-level components might be an interesting feature to
        add to the library, such as patricia tries or ternary search tries.
      </para>
    </section>
  </section>
  <section id="tree.proposal">
    <title><link linkend="tree.proposal">Proposed Text for Technical Report 2</link></title>
    <note>
      <para>
        Notes that are not part of the proposed text appear in gray boxes.
      </para>
    </note>
    <section id="tree.proposal.containers">
      <title><link linkend="tree.proposal.containers">Containers library <phrase role="tr_section_label">[tr.containers]</phrase></link></title>
      <section id="tree.proposal.containers.hierarchy">
        <title><link linkend="tree.proposal.containers.hierarchy">Hierarchy containers
        <phrase role="tr_section_label">[tr.hierarchy]</phrase></link></title>
        <section id="tree.proposal.containers.hierarchy.req">
          <title><link linkend="tree.proposal.containers.hierarchy.req">Hierarchy
          containers requirements <phrase role="tr_section_label">[tr.hierarchy.req]</phrase></link></title>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>
                A hierarchy is an object that stores a finite set of objects, all
                of the same type, in a hierarchical manner. Hierarchies introduce
                a cursor concept for navigation instead of iterators. The library
                provides two kinds of native hierarchies: <literal moreinfo="none">binary_tree</literal>,
                and <literal moreinfo="none">nary_tree</literal>, along with hierarchy-yielding hierarchy
                adaptors <literal moreinfo="none">forest_tree</literal>, and <literal moreinfo="none">multiway_tree</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                Hierarchy containers conform to the requirements of Containers ([lib.container.requirements]),
                except that the expressions in Table 1 are not required to be valid,
                where a and b denote values of a type X, and X is a hierarchy container
                class:
              </para>
              <table frame="all" id="tree.proposal.containers.hierarchy.req.table1">
                <title>Container requirements that are not required for hierarchy
                containers</title>
                <tgroup cols="1">
                  <thead>
                    <row>
                      <entry>
                        <para>
                          unsupported expression
                        </para>
                      </entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">X::iterator</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">X::const_iterator</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">X::reverse_iterator</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">X::const_reverse_iterator</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.begin()</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.end()</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.rbegin()</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.rend()</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a &lt; b</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a &gt; b</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a &lt;= b</literal>
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a &gt;= b</literal>
                        </para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </table>
            </listitem>
            <listitem>
              <para>
                Non-constant complexity requirements in this clause are stated in
                one of a number of possible different ways: unless specified otherwise,
                they are expressed in terms of the number of operations <literal moreinfo="none">n</literal>,
                which stands for the total number of elements in the hierarchy; in
                some cases, however, they are stated in terms of another value.
              </para>
            </listitem>
            <listitem>
              <para>
                In Table 2: <literal moreinfo="none">X</literal> denotes a hierarchy class containing
                objects of type <literal moreinfo="none">T</literal> and <literal moreinfo="none">a</literal> denotes
                a value of type <literal moreinfo="none">X</literal>.
              </para>
              <table frame="all" id="tree.proposal.containers.hierarchy.req.table2">
                <title>Hierarchy requirements (in addition to container)</title>
                <tgroup cols="4">
                  <thead>
                    <row>
                      <entry>
                        <para>
                          expression
                        </para>
                      </entry>
                      <entry>
                        <para>
                          return type
                        </para>
                      </entry>
                      <entry>
                        <para>
                          assertion/note<sbr/> pre/post-condition
                        </para>
                      </entry>
                      <entry>
                        <para>
                          complexity
                        </para>
                      </entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">X::cursor</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          cursor type pointing to <literal moreinfo="none">T</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          any cursor category
                        </para>
                      </entry>
                      <entry>
                        <para>
                          compile time
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">X::const_cursor</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          cursor type pointing to <literal moreinfo="none">const T</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          any cursor category
                        </para>
                      </entry>
                      <entry>
                        <para>
                          compile time
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.root()</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">iterator</literal> for mutable <literal moreinfo="none">a</literal>;<sbr/>
                          <literal moreinfo="none">const_iterator</literal> for constant <literal moreinfo="none">a</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                           
                        </para>
                      </entry>
                      <entry>
                        <para>
                          constant
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.croot()</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">const_iterator</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                           
                        </para>
                      </entry>
                      <entry>
                        <para>
                          constant
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.shoot()</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">iterator</literal> for mutable <literal moreinfo="none">a</literal>;<sbr/>
                          <literal moreinfo="none">const_iterator</literal> for constant <literal moreinfo="none">a</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                           
                        </para>
                      </entry>
                      <entry>
                        <para>
                          (Note A)
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.cshoot()</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">const_iterator</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                           
                        </para>
                      </entry>
                      <entry>
                        <para>
                          (Note A)
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">typename X::template rebind&lt;U&gt;::other</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">Y</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          For all <literal moreinfo="none">U</literal> (including <literal moreinfo="none">T</literal>),
                          <literal moreinfo="none">Y::template rebind&lt;T&gt;::other</literal> is
                          <literal moreinfo="none">X</literal>.
                        </para>
                      </entry>
                      <entry>
                        <para>
                          compile time
                        </para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </table>
              <para>
                Notes: Those entries marked "(Note A)" should have at worst
                linear complexity. See the individual hierarchy containers for specific
                complexity.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal moreinfo="none">root()</literal> and <literal moreinfo="none">croot()</literal> return a
                cursor which is the on-top value for the hierarchy. <literal moreinfo="none">shoot()</literal>
                and <literal moreinfo="none">cshoot()</literal> return a cursor which is the past-the-end
                value that is found one past the hierarchy's rightmost element. If
                the hierarchy is empty, then <literal moreinfo="none">root() == shoot();</literal>
              </para>
            </listitem>
            <listitem>
              <para>
                Copy constructors for all hierarchy types defined in this clause
                copy the allocator argument from their respective first parameters.
                All other constructors for these hierarchy types take an <literal moreinfo="none">Allocator&amp;</literal>
                argument (20.1.5). A copy of this argument is used for any memory
                allocation performed, by these constructors and by all member functions,
                during the lifetime of each hierarchy object. In all hierarchy types
                defined in this clause, the member <literal moreinfo="none">get_allocator()</literal>
                returns a copy of the Allocator object used to construct the hierarchy.
              </para>
            </listitem>
            <listitem>
              <para>
                The member class template <literal moreinfo="none">rebind</literal> in the table
                above is effectively a typedef template: if the name <literal moreinfo="none">Hierarchy</literal>
                is bound to <literal moreinfo="none">SomeHierarchy&lt;T&gt;</literal>, then <literal moreinfo="none">Hierarchy::rebind&lt;U&gt;::other</literal>
                is the same type as <literal moreinfo="none">SomeHierarchy&lt;U&gt;</literal>. Additionally,
                because of the related assertion, given <literal moreinfo="none">SomeHierarchy&lt;T,R0,...,Rn&gt;</literal>
                for all template arguments present is bound to the name <literal moreinfo="none">Hierarchy</literal>,
                then <literal moreinfo="none">Hierarchy::rebind&lt;U&gt;::other</literal> is the
                same type as <literal moreinfo="none">SomeHierarchy&lt;U,S0,...,Sn&gt;</literal>
                such that the types <literal moreinfo="none">S0</literal> through <literal moreinfo="none">Sn</literal>
                are the same as <literal moreinfo="none">R0</literal> through <literal moreinfo="none">Rn</literal>,
                respectively, when <literal moreinfo="none">U</literal> is the same type as <literal moreinfo="none">T</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                A hierarchy satisfying the requirements shown in Table 3 is called
                a <emphasis>mutable hierarchy</emphasis>. In Table 3, <literal moreinfo="none">X</literal>
                denotes a hierarchy class, <literal moreinfo="none">a</literal> denotes a value of
                <literal moreinfo="none">X</literal>, <literal moreinfo="none">c</literal> denotes a valid, non-on-top
                cursor satisfying input cursor requirements, <literal moreinfo="none">p</literal>
                denotes a valid, non-on-top cursor to <literal moreinfo="none">a</literal>, <literal moreinfo="none">q</literal>
                denotes a valid, dereferenceable cursor to <literal moreinfo="none">a</literal>,
                and <literal moreinfo="none">t</literal> denotes a value of <literal moreinfo="none">X::value_type</literal>.
              </para>
              <table frame="all" id="tree.proposal.containers.hierarchy.req.table3">
                <title>Mutable hierarchy requirements</title>
                <tgroup cols="4">
                  <thead>
                    <row>
                      <entry>
                        <para>
                          expression
                        </para>
                      </entry>
                      <entry>
                        <para>
                          return type
                        </para>
                      </entry>
                      <entry>
                        <para>
                          assertion/note<sbr/> pre/post-condition
                        </para>
                      </entry>
                      <entry>
                        <para>
                          complexity
                        </para>
                      </entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.insert(p,t)</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">cursor</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          inserts a copy of <literal moreinfo="none">t</literal> before <literal moreinfo="none">p</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          (Note A)
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.clear(q)</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">void</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          deletes the subtree of <literal moreinfo="none">q</literal> and the element
                          <literal moreinfo="none">q</literal> points to.<sbr/> pre: <literal moreinfo="none">q</literal>
                          is dereferenceable.
                        </para>
                      </entry>
                      <entry>
                        <para>
                          Should be at worst linear in the the number of elements
                          in the subtree of <literal moreinfo="none">q</literal> plus the distance
                          to <literal moreinfo="none">q</literal>'s parent's <literal moreinfo="none">end()</literal>.
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.clear()</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">void</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">while (a.size()) clear(a.begin());</literal><sbr/>
                          post: <literal moreinfo="none">a.size() == 0</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          (Note A)
                        </para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </table>
              <para>
                Notes: Those entries marked "(Note A)" should have at worst
                linear complexity. See the individual hierarchy containers for specific
                complexity.
              </para>
            </listitem>
            <listitem>
              <para>
                The cursor returned from <literal moreinfo="none">a.insert(p,t)</literal> points
                to the copy of <literal moreinfo="none">t</literal> inserted into <literal moreinfo="none">a</literal>.
                Its parent cursor is the same as that of <literal moreinfo="none">p</literal>.
              </para>
            </listitem>
          </orderedlist>
        </section>
        <section id="tree.proposal.containers.hierarchy.plain">
          <title><link linkend="tree.proposal.containers.hierarchy.plain">Plain hierarchies
          <phrase role="tr_section_label">[tr.hierarchy.plain]</phrase></link></title>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>
                A hierarchy is called plain hierarchy if its cursor and const_cursor
                types satisfy the requirements of a plain cursor.
              </para>
            </listitem>
            <listitem>
              <para>
                The library provides one native kind of plain hierarchy, nary_tree,
                and a hierarchy adaptor that in turn yields a plain hierarchy, forest_tree.
              </para>
            </listitem>
            <listitem>
              <para>
                For a mutable plain hierarchy, the following expressions as shown
                in Table 4, is additionally required to be valid:
              </para>
              <table frame="all" id="tree.proposal.containers.hierarchy.plain.table4">
                <title>Plain hierarchy requirements</title>
                <tgroup cols="4">
                  <thead>
                    <row>
                      <entry>
                        <para>
                          expression
                        </para>
                      </entry>
                      <entry>
                        <para>
                          return type
                        </para>
                      </entry>
                      <entry>
                        <para>
                          assertion/note<sbr/> pre/post-condition
                        </para>
                      </entry>
                      <entry>
                        <para>
                          complexity
                        </para>
                      </entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.insert(p,c)</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">cursor</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          inserts a copy of the subtree of <literal moreinfo="none">c</literal> before
                          <literal moreinfo="none">p</literal>.<sbr/> pre: <literal moreinfo="none">c</literal> is
                          dereferenceable.
                        </para>
                      </entry>
                      <entry>
                        <para>
                          Should be at worst linear in the the number of elements
                          in the subtree of <literal moreinfo="none">c</literal> plus the distance
                          to <literal moreinfo="none">p</literal>'s parent's <literal moreinfo="none">end()</literal>.
                        </para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.insert_above(p,t)</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">cursor</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          inserts a copy of <literal moreinfo="none">t</literal> as child of <literal moreinfo="none">p</literal>'s
                          parent and new parent of <literal moreinfo="none">p</literal> and its siblings.<sbr/>
                          pre: <literal moreinfo="none">c</literal> is dereferenceable.
                        </para>
                      </entry>
                      <entry>
                        <para>
                          Linear in the the number <literal moreinfo="none">p</literal>'s siblings.
                        </para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </table>
            </listitem>
            <listitem>
              <para>
                The cursor returned from <literal moreinfo="none">a.insert(p,c)</literal> points
                to the copy of the element that <literal moreinfo="none">c</literal> points to, inserted
                into <literal moreinfo="none">a</literal>. Its parent cursor is the same as that
                of <literal moreinfo="none">p</literal>.
              </para>
            </listitem>
          </orderedlist>
        </section>
        <section id="tree.proposal.containers.hierarchy.multiway">
          <title><link linkend="tree.proposal.containers.hierarchy.multiway">Multiway
          hierarchies <phrase role="tr_section_label">[tr.hierarchy.multiway]</phrase></link></title>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>
                A hierarchy is called multiway hierarchy if its <literal moreinfo="none">cursor</literal>
                and <literal moreinfo="none">const_cursor</literal> types satisfy the requirements
                of a multiway cursor.
              </para>
            </listitem>
            <listitem>
              <para>
                The library provides one native kind of multiway hierarchy, <literal moreinfo="none">binary_tree</literal>,
                and a hierarchy adaptor that in turn yields a multiway hierarchy,
                <literal moreinfo="none">multiway_tree</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                For a mutable multiway hierarchy, the semantics of some expressions
                from Table 3 are modified as shown in Table 5.
              </para>
              <table frame="all" id="tree.proposal.containers.hierarchy.multiway.table5">
                <title>Multiway hierarchy requirements</title>
                <tgroup cols="4">
                  <thead>
                    <row>
                      <entry>
                        <para>
                          expression
                        </para>
                      </entry>
                      <entry>
                        <para>
                          return type
                        </para>
                      </entry>
                      <entry>
                        <para>
                          assertion/note<sbr/> pre/post-condition
                        </para>
                      </entry>
                      <entry>
                        <para>
                          complexity
                        </para>
                      </entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>
                        <para>
                          <literal moreinfo="none">a.clear(q)</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          <literal moreinfo="none">void</literal>
                        </para>
                      </entry>
                      <entry>
                        <para>
                          deletes the subtree of <literal moreinfo="none">q</literal>.<sbr/> If
                          <literal moreinfo="none">q</literal> is dereferenceable, the expression
                          also deletes the element <literal moreinfo="none">q</literal> points to.<sbr/>
                          If <literal moreinfo="none">q</literal> is past-the-end, the expression
                          deletes the element <literal moreinfo="none">q</literal>'s predecessor
                          points to.<sbr/> If after either of these steps <literal moreinfo="none">q</literal>
                          has only a non-empty past-the-end child, that child's children
                          become <literal moreinfo="none">q</literal>'s children instead. Finally,
                          that child is deleted.<sbr/> pre: <literal moreinfo="none">q</literal>
                          is internal.
                        </para>
                      </entry>
                      <entry>
                        <para>
                          Should be at worst linear in the the number of elements
                          in the subtree of <literal moreinfo="none">c</literal> plus the distance
                          to <literal moreinfo="none">p</literal>'s parent's <literal moreinfo="none">end()</literal>.
                        </para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </table>
            </listitem>
          </orderedlist>
        </section>
        <section id="tree.proposal.containers.hierarchy.tree">
          <title><link linkend="tree.proposal.containers.hierarchy.tree">Trees <phrase role="tr_section_label">[tr.hierarchy.tree]</phrase></link></title>
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>
                Headers <literal moreinfo="none">&lt;binary_tree&gt;</literal>, <literal moreinfo="none">&lt;nary_tree&gt;</literal>,
                <literal moreinfo="none">&lt;forest_tree&gt;</literal>, and <literal moreinfo="none">&lt;multiway_tree&gt;</literal>.
              </para>
              <para>
                <emphasis role="bold">Header <literal moreinfo="none">&lt;binary_tree&gt;</literal>
                synopsis</emphasis>
              </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">tr2</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace tr2</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
              <para>
                <emphasis role="bold">Header <literal moreinfo="none">&lt;nary_tree&gt;</literal>
                synopsis</emphasis>
              </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">tr2</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace tr2</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
              <para>
                <emphasis role="bold">Header <literal moreinfo="none">&lt;forest_tree&gt;</literal>
                synopsis</emphasis>
              </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">tr2</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">forest_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace tr2</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
              <para>
                <emphasis role="bold">Header <literal moreinfo="none">&lt;multiway_tree&gt;</literal>
                synopsis</emphasis>
              </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">tr2</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">multiway_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace tr2</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
            </listitem>
          </orderedlist>
          <section id="tree.proposal.containers.hierarchy.tree.bintree">
            <title><link linkend="tree.proposal.containers.hierarchy.tree.bintree">Template
            class <literal moreinfo="none">binary_tree</literal> <phrase role="tr_section_label">[tr.hierarchy.bintree]</phrase></link></title>
            <section id="tree.proposal.containers.hierarchy.tree.bintree.types">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.bintree.types"><literal moreinfo="none">binary_tree</literal>
              types <phrase role="tr_section_label">[tr.hierarchy.bintree.types]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.bintree.cons">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.bintree.cons"><literal moreinfo="none">binary_tree</literal>
              constructors, copy, and assignment <phrase role="tr_section_label">[tr.hierarchy.bintree.cons]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.bintree.cursors">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.bintree.cursors"><literal moreinfo="none">binary_tree</literal>
              cursors <phrase role="tr_section_label">[tr.hierarchy.bintree.cursors]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.bintree.modifiers">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.bintree.modifiers"><literal moreinfo="none">binary_tree</literal>
              modifiers <phrase role="tr_section_label">[tr.hierarchy.bintree.modifiers]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.bintree.special">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.bintree.special"><literal moreinfo="none">binary_tree</literal>
              specialized algorithms <phrase role="tr_section_label">[tr.hierarchy.bintree.special]</phrase></link></title>
            </section>
          </section>
          <section id="tree.proposal.containers.hierarchy.tree.narytree">
            <title><link linkend="tree.proposal.containers.hierarchy.tree.narytree">Template
            class <literal moreinfo="none">nary_tree</literal> <phrase role="tr_section_label">[tr.hierarchy.narytree]</phrase></link></title>
            <section id="tree.proposal.containers.hierarchy.tree.narytree.types">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.narytree.types"><literal moreinfo="none">nary_tree</literal>
              types <phrase role="tr_section_label">[tr.hierarchy.narytree.types]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.narytree.cons">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.narytree.cons"><literal moreinfo="none">nary_tree</literal>
              constructors, copy, and assignment <phrase role="tr_section_label">[tr.hierarchy.narytree.cons]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.narytree.cursors">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.narytree.cursors"><literal moreinfo="none">nary_tree</literal>
              cursors <phrase role="tr_section_label">[tr.hierarchy.narytree.cursors]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.narytree.capacity">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.narytree.capacity"><literal moreinfo="none">nary_tree</literal>
              capacity <phrase role="tr_section_label">[tr.hierarchy.narytree.capacity]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.narytree.modifiers">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.narytree.modifiers"><literal moreinfo="none">nary_tree</literal>
              modifiers <phrase role="tr_section_label">[tr.hierarchy.narytree.modifiers]</phrase></link></title>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.narytree.special">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.narytree.special"><literal moreinfo="none">nary_tree</literal>
              specialized algorithms <phrase role="tr_section_label">[tr.hierarchy.narytree.special]</phrase></link></title>
            </section>
          </section>
          <section id="tree.proposal.containers.hierarchy.tree.adaptors">
            <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors">Hierarchy
            adaptors <phrase role="tr_section_label">[tr.hierarchy.adaptors]</phrase></link></title>
            <section id="tree.proposal.containers.hierarchy.tree.adaptors.foresttree">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.foresttree">Template
              class <literal moreinfo="none">forest_tree</literal> <phrase role="tr_section_label">[tr.hierarchy.foresttree]</phrase></link></title>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.types">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.types"><literal moreinfo="none">forest_tree</literal>
                types <phrase role="tr_section_label">[tr.hierarchy.foresttree.types]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.cons">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.cons"><literal moreinfo="none">forest_tree</literal>
                constructors, copy, and assignment <phrase role="tr_section_label">[tr.hierarchy.foresttree.cons]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.cursors">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.cursors"><literal moreinfo="none">forest_tree</literal>
                cursors <phrase role="tr_section_label">[tr.hierarchy.foresttree.cursors]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.modifiers">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.modifiers"><literal moreinfo="none">forest_tree</literal>
                modifiers <phrase role="tr_section_label">[tr.hierarchy.foresttree.modifiers]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.special">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.foresttree.special"><literal moreinfo="none">forest_tree</literal>
                specialized algorithms <phrase role="tr_section_label">[tr.hierarchy.foresttree.special]</phrase></link></title>
              </section>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree">Template
              class <literal moreinfo="none">multiway_tree</literal> <phrase role="tr_section_label">[tr.hierarchy.multiwaytree]</phrase></link></title>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.types">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.types"><literal moreinfo="none">multiway_tree</literal>
                types <phrase role="tr_section_label">[tr.hierarchy.multiwaytree.types]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.cons">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.cons"><literal moreinfo="none">multiway_tree</literal>
                constructors, copy, and assignment <phrase role="tr_section_label">[tr.hierarchy.multiwaytree.cons]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.cursors">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.cursors"><literal moreinfo="none">multiway_tree</literal>
                cursors <phrase role="tr_section_label">[tr.hierarchy.multiwaytree.cursors]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.capacity">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.capacity"><literal moreinfo="none">multiway_tree</literal>
                capacity <phrase role="tr_section_label">[tr.hierarchy.multiwaytree.capacity]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.modifiers">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.modifiers"><literal moreinfo="none">multiway_tree</literal>
                modifiers <phrase role="tr_section_label">[tr.hierarchy.multiwaytree.modifiers]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.special">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.multiwaytree.special"><literal moreinfo="none">multiway_tree</literal>
                specialized algorithms <phrase role="tr_section_label">[tr.hierarchy.multiwaytree.special]</phrase></link></title>
              </section>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.adaptors.augment">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.augment">Augmenting
              hierarchy adaptors <phrase role="tr_section_label">[tr.hierarchy.augment]</phrase></link></title>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.augment.ranktree">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.augment.ranktree">Template
                class <literal moreinfo="none">rank_tree</literal> <phrase role="tr_section_label">[tr.hierarchy.ranktree]</phrase></link></title>
              </section>
            </section>
            <section id="tree.proposal.containers.hierarchy.tree.adaptors.balance">
              <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.balance">Balancing
              hierarchy adaptors <phrase role="tr_section_label">[tr.hierarchy.balance]</phrase></link></title>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.balance.cons">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.balance.cons">Balancing
                adaptor constructors, copy, and assigment <phrase role="tr_section_label">[tr.hierarchy.balance.cons]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.balance.map">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.balance.map">Balancing
                adaptor map operations <phrase role="tr_section_label">[tr.hierarchy.balance.map]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.balance.modifiers">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.balance.modifiers">Balancing
                adaptor modifiers <phrase role="tr_section_label">[tr.hierarchy.balance.modifiers]</phrase></link></title>
              </section>
              <section id="tree.proposal.containers.hierarchy.tree.adaptors.balance.special">
                <title><link linkend="tree.proposal.containers.hierarchy.tree.adaptors.balance.special">Balancing
                adaptor specialized algorithms <phrase role="tr_section_label">[tr.hierarchy.balance.special]</phrase></link></title>
              </section>
            </section>
          </section>
        </section>
      </section>
    </section>
  </section>
  <section id="tree.references">
    <title><link linkend="tree.references">References</link></title>
    <variablelist>
      <title>References</title>
      <varlistentry>
        <term>austern</term>
        <listitem>
          <para>
            Austern, Matthew H.; Stroustrup, Bjarne; Thorup, Mikkel; Wilikinson,
            John. <emphasis>Untangling the Balancing and Searching of Balanced Binary
            Search Trees</emphasis>, Software: Practice and Experience 33(13): 1273-1298
            (2003) Electronic Appendix: http://www.research.att.com/~bs/tree-appendix.pdf
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>cormen</term>
        <listitem>
          <para>
            Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford.
            <emphasis>Introduction to Algorithms</emphasis>. Second Edition (MIT
            Press, 2001)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dreizin</term>
        <listitem>
          <para>
            Dreizin, Vladimir; Kosnik, Benjamin; Tavory, Ami. <emphasis>Policy-Based
            Data Structures</emphasis>, http://gcc.gnu.org/onlinedocs/libstdc++<emphasis>ext/pb_ds</emphasis>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>ekman</term>
        <listitem>
          <para>
            Ekman, Rasmus. <emphasis>Structured Associative Containers</emphasis>,
            http://www.abc.se/~re/code/tst
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>gottschlich</term>
        <listitem>
          <para>
            Gottschlich, Justin. <emphasis>C++ Trees</emphasis>, http://www.gamedev.net/reference/articles/article2192.asp
            and http://www.gamedev.net/reference/articles/article2233.asp
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>haas</term>
        <listitem>
          <para>
            Haas, Mitchell. <emphasis>Tree Container Library</emphasis>, http://www.datasoftsolutions.net/tree_container_library/overview.php
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>karas</term>
        <listitem>
          <para>
            Karas, Walt. <emphasis>C++ AVL Tree Template</emphasis>, http://us.geocities.com/wkaras/gen_cpp/avl_tree.html
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>knuth97</term>
        <listitem>
          <para>
            Knuth, Donald E. <emphasis>The Art of Computer Programming</emphasis>.
            Volume 1: Fundamental Algorithms. Third Edition (Reading, Massachusetts:
            Addison-Wesley, 1997)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>knuth98</term>
        <listitem>
          <para>
            Knuth, Donald E. <emphasis>The Art of Computer Programming</emphasis>.
            Volume 3: Sorting and Searching. Second Edition (Reading, Massachusetts:
            Addison-Wesley, 1998)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>mirwaisi</term>
        <listitem>
          <para>
            Mirwaisi, Jeff. <emphasis>treelib</emphasis>, https://boost-consulting.com:8443/trac/soc/attachment/wiki/tree/resources/trees/treelib.tar.bz2
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>parent</term>
        <listitem>
          <para>
            Parent, Sean et al. <emphasis>forest</emphasis>, http://opensource.adobe.com/group__forest__related.html
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>peeters</term>
        <listitem>
          <para>
            Peeters, Kasper. <emphasis>tree.hh: an STL-like C++ tree class</emphasis>,
            http://www.aei.mpg.de/~peekas/tree/
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>rivera</term>
        <listitem>
          <para>
            Rivera, René. <emphasis>RankTree.h</emphasis>, http://redshift-software.com/~grafik/RankTree.h
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</article>
