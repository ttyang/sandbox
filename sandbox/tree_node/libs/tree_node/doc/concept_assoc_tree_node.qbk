[/=============================================================================
    Copyright (C) 2011-2012 Cromwell D. Enage

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    [@http://www.boost.org/LICENSE_1_0.txt])
=============================================================================/]

[section:associative_tree_node Associative Tree Node]

[section Description]
Models of this concept provide key-based access to their child nodes.
[endsect]

[section Refinement of]
__Tree_Node__
[endsect]

[variablelist Notation
    [[`Node`][A type that models the [*Associative Tree Node] concept.]]
    [[`node`][An object of type `Node::pointer`.]]
    [[`const_node`][An object of type `Node::const_pointer`.]]
    [[`key`][An object of type `Node::traits::key_type const&`.]]
    [[`data`][An object of type `Node::traits::data_type const&`.]]
]

[section:types Associated Types]
One new type is introduced.

[table
    [[Name][Expression][Description][Requirements]]
    [
        [Key type]
        [`Node::traits::key_type`]
        [The type of a key that a tree node will associate with a child node.]
        []
    ]
]

In addition, the requirements for the iterator types are strengthened:

  * The value type of `Node::iterator` must define a `first_type` type.
  * The value type of `Node::iterator` must define a `first` member variable of
    type `first_type`.
  * Given an object `itr` of type `Node::iterator`, `itr->first` must be
    convertible to `Node::traits::key_type const&`.
  * The value type of `Node::iterator` must define a `second_type` type.
  * The value type of `Node::iterator` must define a `second` member variable
    of type `second_type`.
  * Given an object `itr` of type `Node::iterator`, `itr->second` must be
    convertible to `Node&`.
  * The value type of `Node::const_iterator` must define a `first_type` type.
  * The value type of `Node::const_iterator` must define a `first` member
    variable of type `first_type`.
  * Given an object `itr` of type `Node::const_iterator`, `itr->first` must be
    convertible to `Node::traits::key_type const&`.
  * The value type of `Node::const_iterator` must define a `second_type` type.
  * The value type of `Node::const_iterator` must define a `second` member
    variable of type `second_type`.
  * Given an object `itr` of type `Node::const_iterator`, `itr->second` must be
    convertible to `Node const&`.

[endsect]

[section:expressions Valid Expressions and Semantics]
In addition to the expressions defined in the __Tree_Node__ concept, the
following expressions must be valid.

[table
    [
        [Name]
        [Expression]
        [Type requirements]
        [Return Type]
        [Semantics]
        [__Runtime_Complexity__]
    ]
    [
        [Child creation with data]
        [`node->add_child(key, data);`]
        []
        [`Node::iterator`]
        [
            Creates and returns a tree node to be associated with the specified
            key in the range of children of the invoking node.  The node
            returned will store the specified data.
        ]
        [Amortized constant]
    ]
    [
        [Child creation]
        [`node->add_child(key)`]
        [
            `Node::traits::data_type` must model the __Default_Constructible__
            concept.
        ]
        [`Node::iterator`]
        [
            Creates and returns a tree node to be associated with the specified
            key in the range of children of the invoking node.
        ]
        [Amortized constant]
    ]
    [
        [Child copy creation]
        [`node->add_child_copy(key, const_node)`]
        []
        [`Node::iterator`]
        [
            Creates and returns a deep copy of `const_node` to be associated
            with the specified key in the range of children of the invoking
            node.
        ]
        [Linear with respect to the number of descendants of `const_node`]
    ]
    [
        [Child search]
        [`const_node->find_child(key)`]
        []
        [`Node::const_iterator`]
        [
            Returns an iterator pointing to a child node associated with the
            specified key, or `const_node->end()` if no such child exists.
        ]
        [Logarithmic]
    ]
    [
        [Child search]
        [`node->find_child(key)`]
        []
        [`Node::iterator`]
        [
            Returns an iterator pointing to a child node associated with the
            specified key, or `node->end()` if no such child exists.
        ]
        [Logarithmic]
    ]
    [
        [Child search range]
        [`const_node->find_children(key)`]
        []
        [[^_std_pair_<Node::const_iterator,Node::const_iterator>]]
        [
            Returns a pair `p` such that `[p.first, p.second)` is a range
            of all child nodes associated with the specified key.  If no such
            children exist, then the range will be empty.
        ]
        [Logarithmic]
    ]
    [
        [Child search range]
        [`node->find_children(key)`]
        []
        [[^_std_pair_<Node::iterator,Node::iterator>]]
        [
            Returns a pair `p` such that `[p.first, p.second)` is a range
            of all child nodes associated with the specified key.  If no such
            children exist, then the range will be empty.
        ]
        [Logarithmic]
    ]
    [
        [Remove children]
        [`node->remove_children(key)`]
        []
        [`std::size_t`]
        [
            Removes all child nodes associated with the specified key from the
            tree node.  Returns the number of children removed.
        ]
        [
            Linear with respect to the number of children and their descendants
            in the range to be removed, plus logarithmic
        ]
    ]
]
[endsect]

[section Models]

  * __associative_node__
  * __associative_node_base__

[endsect]

[endsect] [/ Associative Tree Node]

