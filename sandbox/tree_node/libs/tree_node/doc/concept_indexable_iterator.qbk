[/=============================================================================
    Copyright (C) 2013 Cromwell D. Enage

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    [@http://www.boost.org/LICENSE_1_0.txt])
=============================================================================/]

[section:indexable_iterator Indexable Iterator]

[section Description]
An [*Indexable Iterator] is an iterator that provides both increment and
decrement as well as sublinear-time operators for moving forward and backward
in arbitrary-sized steps.  The runtime complexity requirement is the only
major difference between an [*Indexable Iterator] and a
__Random_Access_Iterator__.
[endsect]

[section Refinement of]

  * __Bidirectional_Iterator__
  * __Less_Than_Comparable__

[endsect]

[section:types Associated Types]
No additional types beyond those defined in the __Bidirectional_Iterator__ and
__Less_Than_Comparable__ concepts.
[endsect]

[variablelist Notation
    [[`Iterator`][A type that models the [*Indexable Iterator] concept.]]
    [[`i`, `j`][Objects of type `Iterator`.]]
    [[`T`][The value type of `Iterator`.]]
    [[`t`][An object of type `T`.]]
    [[`Distance`][The distance type of `Iterator`.]]
    [[`n`][An object of type `Distance`.]]
]

[section:expressions Valid Expressions and Semantics]
In addition to the expressions defined in the __Bidirectional_Iterator__
concept, the following expressions must be valid.

[table
    [
        [Name]
        [Expression]
        [Return Type]
        [Semantics]
        [Type Requirements]
        [Precondition]
        [Postcondition]
        [__Runtime_Complexity__]
    ]
    [
        [Iterator addition assignment]
        [`i += n`]
        [`X&`]
        [
            If `n > 0`, equivalent to executing `++i` `n` times.  If `n < 0`,
            equivalent to executing `--i` `n` times. If `n == 0`, this is a
            null operation.
        ]
        []
        [
            Including `i` itself, there must be `n` dereferenceable or
            past-the-end iterators following or preceding `i`, depending on
            whether `n` is positive or negative.
        ]
        [`i` is dereferenceable or past-the-end.]
        []
    ]
    [
        [Iterator addition]
        [`i + n` or `n + i`]
        [`X`]
        [
            Equivalent to `{ X tmp = i; return tmp += n; }`.  The two forms
            `i + n` and `n + i` are identical.
        ]
        []
        [Same as for `i += n`]
        [The result is dereferenceable or past-the-end.]
        []
    ]
    [
        [Iterator subtraction assignment]
        [`i -= n`]
        [`X&`]
        [Equivalent to `i += (-n)`.]
        []
        [
            Including `i` itself, there must be `n` dereferenceable or
            past-the-end iterators preceding or following `i`, depending on
            whether `n` is positive or negative.
        ]
        [`i` is dereferenceable or past-the-end.]
        []
    ]
    [
        [Iterator subtraction]
        [`i - n`]
        [`X`]
        [Equivalent to `{ X tmp = i; return tmp -= n; }`.]
        []
        [Same as for `i -= n`]
        [The result is dereferenceable or past-the-end.]
        []
    ]
    [
        [Difference]
        [`i - j`]
        [`Distance`]
        [Returns a number `n` such that `i == j + n`.]
        []
        [
            Either `i` is reachable from `j` or `j` is reachable from `i`, or
            both.
        ]
        []
        []
    ]
    [
        [Element operator]
        [`i[n]`]
        [Convertible to `T`]
        [Equivalent to `*(i + n)`.]
        []
        [`i + n` exists and is dereferenceable.]
        []
        []
    ]
    [
        [Element assignment]
        [`i[n] = t`]
        [Convertible to `T`]
        [Equivalent to `*(i + n)`.]
        [`X` is mutable.]
        [`i + n` exists and is dereferenceable.]
        [`i[n]` is a copy of `t`.]
        []
    ]
]

In addition, the domain of the less-than comparison expression `i < j` is the
group of iterators that are reachable from each other: that is, either `i` is
reachable from `j` or `j` is reachable from `i`, or both.

The __Forward_Iterator__ and __Reverse_Iterator__ requirements that the
increment and decrement operators must exhibit constant time complexity have
been relaxed; they now need only exhibit linear time complexity with respect
to the number of descendants in the worst case.
[endsect]

[section Models]

  * The iterator types of __binode_container__.
  * The iterator types of __binode_associative_container__.

[endsect]

[endsect] [/ Tree Node Iterator]

