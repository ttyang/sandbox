[/=============================================================================
    Copyright (C) 2011-2012 Cromwell D. Enage

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    [@http://www.boost.org/LICENSE_1_0.txt])
=============================================================================/]

[section:tree_node Tree Node]

[section Description]
All tree node implementations that this library provides model this concept:
a structure that maintains information about its data and its immediate
parent-child relationships.  However, in practice, a full-fledged tree node
data structure or adaptor consists of three components: a __Base_Tree_Node__
model that defines the functionality, a [*Tree Node] model that inherits from
the base type and is better suited for external usage, and a __Type_Generator__
that returns the __Base_Tree_Node__ model from which adaptor types can also
inherit.
[endsect]

[variablelist Notation
    [[`Node`][A type that models the [*Tree Node] concept.]]
    [[`node`][An object of type `Node::pointer`.]]
    [[`const_node`][An object of type `Node::const_pointer`.]]
]

[section:types Associated Types]
[table
    [[Name][Expression][Description][Requirements]]
    [
        [Data type]
        [`Node::traits::data_type`]
        [The type of the object stored in a tree node.]
        [
            It must model the __Copy_Constructible__ concept, but need not
            model the __Assignable__ concept.
        ]
    ]
    [
        [Pointer type]
        [`Node::pointer`]
        [The type of a pointer to a `Node` object.]
        [
            It must model the __Trivial_Iterator__ concept, it must point to
            a mutable object, and it must be implicitly convertible to
            `Node::const_pointer`.
        ]
    ]
    [
        [Pointer-to-const type]
        [`Node::const_pointer`]
        [The type of a pointer to a `Node const` object.]
        [
            It must model the __Trivial_Iterator__ concept, and it must /not/
            point to a mutable object.
        ]
    ]
    [
        [Iterator type]
        [`Node::iterator`]
        [
            The type of iterator used to iterate through the children of a
            `Node` object.
        ]
        [
            It must model the __Input_Iterator__ concept, and it must be
            convertible to `Node::const_iterator`.
        ]
    ]
    [
        [Immutable iterator type]
        [`Node::const_iterator`]
        [
            The type of iterator used to iterate through the children of a
            `Node const` object.
        ]
        [
            It must model the __Input_Iterator__ concept.
        ]
    ]
]
[endsect]

[section:expressions Valid Expressions and Semantics]
[table
    [[Name][Expression][Return Type][Semantics][__Runtime_Complexity__]]
    [
        [Data access]
        [`const_node->get_data()`]
        [`Node::traits::data_type const&`]
        [Returns the object stored in the tree node.]
        [Constant]
    ]
    [
        [Data access]
        [`node->get_data()`]
        [`Node::traits::data_type&`]
        [Returns the object stored in the tree node.]
        [Constant]
    ]
    [
        [Parent access]
        [`const_node->get_parent_ptr()`]
        [`Node::const_pointer`]
        [
            Returns a pointer to the parent of the tree node, or a null pointer
            if the node is the root.
        ]
        [Constant]
    ]
    [
        [Parent access]
        [`node->get_parent_ptr()`]
        [`Node::pointer`]
        [
            Returns a pointer to the parent of the tree node, or a null pointer
            if the node is the root.
        ]
        [Constant]
    ]
    [
        [Children range begin access]
        [`const_node->begin()`]
        [`Node::const_iterator`]
        [
            Returns an iterator pointing to the beginning of the range of
            children of the tree node.  If the range is empty, then the
            iterator points past-the-end.
        ]
        [Constant]
    ]
    [
        [Children range begin access]
        [`node->begin()`]
        [`Node::iterator`]
        [
            Returns an iterator pointing to the beginning of the range of
            children of the tree node.  If the range is empty, then the
            iterator points past-the-end.
        ]
        [Constant]
    ]
    [
        [Children range past-the-end access]
        [`const_node->end()`]
        [`Node::const_iterator`]
        [
            Returns an iterator pointing past the end of the range of children
            of the tree node.
        ]
        [Constant]
    ]
    [
        [Children range past-the-end access]
        [`node->end()`]
        [`Node::iterator`]
        [
            Returns an iterator pointing past the end of the range of children
            of the tree node.
        ]
        [Constant]
    ]
    [
        [Leaf node query]
        [`const_node->empty()`]
        [`bool`]
        [
            Equivalent to `const_node->begin() == const_node->end()`, but may
            be more efficient in certain cases.
        ]
        [Linear with respect to the number of children]
    ]
    [
        [Remove all children]
        [`node->clear()`]
        [`void`]
        [Removes all children from the tree node.]
        [Linear with respect to the number of children and their descendants]
    ]
]
[endsect] [/ Valid Expressions and Semantics]

[section Models]

  * __binary_node__
  * __binary_node_base__
  * __nary_node__
  * __nary_node_base__
  * __associative_node__
  * __associative_node_base__
  * __tree_node_with_depth__
  * __tree_node_with_depth_base__
  * __tree_node_with_position__
  * __tree_node_with_position_base__
  * __tree_node_with_red_black_flag__
  * __tree_node_with_red_black_flag_base__

[endsect]

[endsect] [/ Tree Node]

