<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Specifying Precision</title>
<link rel="stylesheet" href=".././boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.77.1">
<link rel="home" href="../index.html" title="Specific-Width Floating-Point Types">
<link rel="up" href="../index.html" title="Specific-Width Floating-Point Types">
<link rel="prev" href="suffixes.html" title="How to specify extended precision constants - Q?">
<link rel="next" href="precision/integerfixedtypes.html" title="Existing Specific precision integer types">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="" width="180" height="90" src=".././images/boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="suffixes.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="precision/integerfixedtypes.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section precision_precision">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="precision.precision"></a><a class="link" href="precision.html" title="Specifying Precision">Specifying Precision</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="precision/integerfixedtypes.html">Existing Specific
      precision integer types</a></span></dt>
<dt><span class="section"><a href="precision/newfloattypes.html">Proposed new section</a></span></dt>
</dl></div>
<p>
      One could envision two ways to name the fixed-precision types:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput"><span class="identifier">float24_t</span><span class="special">,</span>
          <span class="identifier">float53_t</span><span class="special">,</span>
          <span class="identifier">float113_t</span><span class="special">,</span>
          <span class="special">...</span></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">float32_t</span><span class="special">,</span>
          <span class="identifier">float64_t</span><span class="special">,</span>
          <span class="identifier">float128_t</span><span class="special">,</span>
          <span class="special">...</span></code>
        </li>
</ul></div>
<p>
      The first set above is intuitively coined from <a href="http://dx.doi.org/10.1109/IEEESTD.2008.4610935" target="_top">IEE754:2008</a>.
      It is also consistent with the gist of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">uint32_t</span></code>,
      et al in so far as the number of binary digits of <span class="emphasis"><em>significand</em></span>
      precision is contained within the name of the data type.
    </p>
<p>
      On the other hand, the second set using the size of the <span class="emphasis"><em>whole type</em></span>
      may probably seem more intuitive to users. The exact layout and number of significand
      and exponent bits can be confirmed as IEEE754 by checking <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">is_iec559</span>
      <span class="special">==</span> <span class="keyword">true</span></code>.
    </p>
<p>
      With the availability of Boost.Multprecision, C++ programmers can now easily
      switch to using floating-point types that give far more decimal digits of precision
      (hundreds) than the built-in types <code class="computeroutput"><span class="keyword">float</span></code>,
      <code class="computeroutput"><span class="keyword">double</span></code> and <code class="computeroutput"><span class="keyword">long</span>
      <span class="keyword">double</span></code>.
    </p>
<p>
      And portability is also reduced. For example, suppose we wish to achieve a
      precision higher than the most common IEEE 64-bit floating-point type supported
      by the X86 chipsets normally used for double. http://en.wikipedia.org/wiki/Double_precision
      providing a precision of between 15 to 17 decimal digits.
    </p>
<p>
      The options for <a href="http://en.wikipedia.org/wiki/Long_double" target="_top">long
      double</a> are many.
    </p>
<p>
      At least one popular compiler treats <code class="computeroutput"><span class="keyword">long</span>
      <span class="keyword">double</span></code> exactly as <code class="computeroutput"><span class="keyword">double</span></code>
      (as permitted by the C++ Standard which does not prescribe the precision for
      any floating-point (or integer) types, leaving them to be implementation-defined).
    </p>
<p>
      However the <a href="http://gcc.gnu.org/wiki/x87note" target="_top">Intel X8087 chipset</a>
      does do calculations using internal 80-bit registers, increasing the significand
      from 53 to 63 bits, and gaining about 3 decimal digits precision from 18 and
      21.
    </p>
<p>
      Some hardware, for example <a href="http://en.wikipedia.org/wiki/SPARC" target="_top">Sparc</a>,
      provides a 128-bit quadruple precision floating-point chip.
    </p>
<p>
      As of gcc 4.3, a quadruple precision is also supported on x86, but as the nonstandard
      type <code class="computeroutput"><span class="identifier">__float128</span></code> rather than
      <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">double</span></code>.
    </p>
<p>
      <a href="http://www.opensource.apple.com/source/gcc/gcc-5646/gcc/config/rs6000/darwin-ldouble.c" target="_top">Darwin</a>
      long double uses a double-double format developed first by <a href="http://keithbriggs.info/doubledouble.html" target="_top">Keith
      Briggs</a>. This gives about 106-bits of precision (about 33 decimal digits)
      but has rather odd behaviour at the extremes making implementation of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;&gt;::</span><span class="identifier">epsilon</span><span class="special">()</span></code> problematic.
    </p>
<p>
      Clang uses a similar technique
    </p>
<pre class="programlisting"><span class="preprocessor">#ifdef</span> <span class="identifier">__clang__</span>
  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="special">{</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">y</span><span class="special">;</span> <span class="special">}</span> <span class="identifier">__float128</span><span class="special">;</span>
<span class="preprocessor">#endif</span>
</pre>
<p>
      as described in <a href="http://stackoverflow.com/questions/13525774/clang-and-float128-bug-error" target="_top">Clang
      float128</a>.
    </p>
<p>
      If we wish to ensure that we use all 80 bits available from Intel 8087 chips
      to calculate <a href="http://en.wikipedia.org/wiki/Extended_precision" target="_top">Extended
      precision</a> we would use a <code class="computeroutput"><span class="keyword">typedef</span>
      <span class="identifier">float80_t</span></code>.
    </p>
<p>
      If the compiler could not generate code this type directly, then it would substitute
      software emulation, perhaps using a Boost.Multiprecision type <code class="computeroutput"><span class="identifier">cpp_dec_float_21</span></code>.
    </p>
<p>
      Similarly if a quadrupole precision of 16-byte 128-bit <a href="http://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format" target="_top">Quadruple-precision
      floating-point format</a> is desired, the specification of <code class="computeroutput"><span class="identifier">float128_t</span></code> will either direct the compiler
      to generate code using the hardware, or it will do this using software emulation.
      This might be generated by the compiler for GCC or delegated to a <code class="computeroutput"><span class="identifier">cpp_bin_float_128</span></code> type (under development
      for <a href="http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html" target="_top">Boost.Multiprecision</a>).
    </p>
<h5>
<a name="precision.precision.h0"></a>
      <span class="phrase"><a name="precision.precision.existing_extended_precision_types"></a></span><a class="link" href="precision.html#precision.precision.existing_extended_precision_types">Existing
      extended precision types</a>
    </h5>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          <a href="http://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html" target="_top">GNU
          C supports additional floating types, <code class="computeroutput"><span class="identifier">__float80</span></code>
          and <code class="computeroutput"><span class="identifier">__float128</span></code> to support
          80-bit (XFmode) and 128-bit (TFmode) floating types.</a>
        </li>
<li class="listitem">
          <a href="http://software.intel.com/en-us/forums/topic/358472" target="_top">Extended
          or Quad IEEE FP formats</a> by Intel Intel64 mode on Linux (V12.1)
          provides 128 bit <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">double</span></code>
          in C, however it appears that it only provides computation at 80-bit format
          giving 64-bit significand precision, and other bits are just padding.
        </li>
<li class="listitem">
          <a href="http://software.intel.com/en-us/forums/topic/358476" target="_top">Intel
          FORTRAN REAL*16</a> is an actual 128-bit IEEE quad, emulated in software.
          But "I don't know of any plan to implement full C support for 128-bit
          IEEE format, although evidently ifort has support libraries." This
          is equivalent to the proposed float128_t type.
        </li>
<li class="listitem">
          The 360/85 and follow-on System/370 added support for a 128-bit "extended"
          <a href="http://en.wikipedia.org/wiki/Extended_precision#IBM_extended_precision_formats" target="_top">IBM
          extended precision formats</a>. These formats are still supported in
          the current design, where they are now called the "hexadecimal floating
          point" (HFP) formats.
        </li>
</ol></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013 Paul A. Bristow, Christopher Kormanyos, John Maddock<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="suffixes.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="precision/integerfixedtypes.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
