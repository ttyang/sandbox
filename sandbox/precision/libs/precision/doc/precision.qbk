[article Specific-Width Floating-Point Typedefs
    [quickbook 1.5]
    [id precision]
    [copyright 2013 Paul A. Bristow,  Christopher Kormanyos, John Maddock]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [Bristow, Paul A.], [Kormanyos, Christopher], [Maddock, John]]
    [source-mode c++]
]

[/purpose paper for C++ ISO standards group WG21/SG6 numerics.]

ISO/IEC JTC1 SC22 WG21/SG6 Numerics N???  - 2013-4-??

[def __Boost [@http://www.boost.org/ Boost]]
[def __Boost_Math [@http://www.boost.org/doc/libs/1_53_0/libs/math/doc/html/index.html Boost.Math]]
[def __gsl [@http://www.gnu.org/software/gsl/ GSL-1.9]]
[def __glibc [@http://www.gnu.org/software/libc/ GNU C Lib]]
[def __hpc [@http://docs.hp.com/en/B9106-90010/index.html HP-UX C Library]]
[def __cephes [@http://www.netlib.org/cephes/ Cephes]]
[def __NTL [@http://www.shoup.net/ntl/ NTL A Library for doing Number Theory]]
[def __NTL_RR [@http://shoup.net/ntl/doc/RR.txt NTL::RR]]
[def __NTL_quad_float [@http://shoup.net/ntl/doc/quad_float.txt NTL::quad_float]]
[def __MPFR [@http://www.mpfr.org/ GNU MPFR library]]
[def __GMP [@http://gmplib.org/ GNU Multiple Precision Arithmetic Library]]
[def __Boost_Multiprecision [@http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html Boost.Multiprecision]]
[def __cpp_dec_float [@http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_dec_float.html cpp_dec_float]]
[def __R [@http://www.r-project.org/ The R Project for Statistical Computing]]
[def __e_float [@http://calgo.acm.org/910.zip e_float (TOMS Algorithm 910)]]
[def __Abramowitz_Stegun M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions, NBS  (1964)]
[def __DMLF [@http://dlmf.nist.gov/ NIST Digital Library of Mathematical Functions]]
[def __Mathematica [@http://www.wolfram.com/products/mathematica/index.html Wolfram Mathematica]]
[def __WolframAlpha [@http://www.wolframalpha.com/ Wolfram Alpha]]
[def __Matlab [@http://www.mathworks.co.uk/products/matlab/ MATLAB]]
[def __libquadmath [@http://gcc.gnu.org/onlinedocs/libquadmath/ GCC libquadmath]]
[def __Quad [@http://software.intel.com/en-us/forums/topic/358472 Extended or Quad IEEE FP formats]]
[def __IEEE754 [@http://dx.doi.org/10.1109/IEEESTD.2008.4610935 IEEE Standard for Floating-point Arithmetic, IEEE Std 754-2008]]
[def __IEEE_Half [@http://en.wikipedia.org/wiki/Half_precision_floating-point_format IEEE half-precision floating-point format]]
[def __IEEE_Single [@http://en.wikipedia.org/wiki/Single_precision_floating-point_format IEEE single-precision floating-point format]]
[def __IEEE_Double [@http://en.wikipedia.org/wiki/Double_precision_floating-point_format IEEE double-precision floating-point format]]
[def __IEEE_Quad [@http://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format  Quadruple-precision floating-point format]]
[def __IEEE_Extended [@http://en.wikipedia.org/wiki/Extended_precision#IEEE_754_extended_precision_formats IEEE 754 extended precision formats and x86 80-bit Extended Precision Format]]
[def __IEEE_floating_point [@http://en.wikipedia.org/wiki/IEEE_floating_point IEEE_ floating-point format]]
[def __IEEE_80_bit [@ http://en.wikipedia.org/wiki/Extended_precision#IEEE_754_extended_precision_formats# x86 Extended Precision Format]]
[def __IBM_hexadecimal [@http://en.wikipedia.org/wiki/Extended_precision#IBM_extended_precision_formats IBM extended precision formats]]

[def __C_IEEE_2008 [@http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1582.pdf C support for IEEE754:2008 N1582]]

[def __arbitrary_precision [@http://en.wikipedia.org/wiki/Arbitrary_precision arbitrary precision]]

[include html4_symbols.qbk]

[note Comments and suggestions to Paul.A.Bristow pbristow@hetp.u-net.com.]

[section:abstract Abstract]

It is proposed to add to the C++ standard
optional floating-point `typedef`s having specified width.
The optional `typedef`s include
`float16_t`, `float32_t`, `float64_t`, `float128_t`,
their corresponding fast and least types,
and the corresponding maximum-width type.
These are to conform with the corresponding specifications of
`binary16`, `binary32`, `binary64`, and `binary128`
in __IEEE_floating_point.

The optional floating-point `typedef`s having specified width
are to be contained in a new standard library header `<cstdfloat>`.
They will be defined in the `std` namespace.

It is not proposed to make any changes to `<cmath>`, special functions,
`<limits>`, or `<complex>`.
Any of the optional floating-point `typedef`s having specified width
that are `typedef`ed from the built-in types `float`, `double`, and `long double`
should automatically be supported by
the implementation's existing `<cmath>`, special functions,
`<limits>`, and `<complex>`.
Support for other `typedef`s is implementation-defined.

New C-style macros are proposed to facilitate initialization
of the optional floating-point `typedef`s having specified width
from a floating-point literal constant.

The main objectives of this proposal are to:

* Improve portability, reliability and safety.
* Reduce the risk of error in precision.
* Improve clarity of coding.
* Optionally extend the range of floating-point precision.

[endsect] [/section:abstract  Abstract]

[section:introduction Introduction]

Since the inceptions of C and C++, the built-in types
`float`, `double`, and `long double` have provided a strong basis
for floating-point calculations.
Optional compiler conformance with __IEEE_floating_point has generally led
to a relatively reliable and portable environment for floating-point
calculations in the programming community.

Support for mathematical facilities and specialized number types
in C++ is progressing rapidly. Currently, C++11 supports floating-point
calculations with its built-in types `float`, `double`, and `long double`
as well as imlementations of numerous elementary and transcendental functions.

A variety of higher transcendental functions of pure and applied mathematics
were added to the C++11 libraries via technical report TR1.
It is now proposed to fix these into the next C++1Y standard.[footnote
[@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3548.pdf Conditionally-supported Special Math Functions for C++14, N3584, Walter E. Brown]
]

Other mathematical special functions are also now proposed, for example,
[@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3494.pdf
A proposal to add special mathematical functions
according to the ISO/IEC 80000-2:2009 standard
Document number: N3494 Version: 1.0 Date: 2012-12-19]

It is, however, emphasized that floating-point adherence
to __IEEE_floating_point is not mandated by the current C++ language standard.
Nor does the standard specify the width, precision or lyaout of its built-in types
`float`, `double`, and `long double`. This can lead to portability problems,
introduce poor efficiency on cost-sensitive microcontroller architectures,
and reduce reliability and safety.

This situation reveals a need for a standard way to specify
floating-point precision in C++.

It may also be desirable to extend floating-point precision to
both lower and higher precisions. This can be done by including
implementation-specific optional floating-point `typedef`s having specified width
that are not derived from `float`, `double`, and `long double`.

Providing optional floating-point `typedef`s having specified width
is expected to significantly improve portability, reliability, and safety
of floating-point calculations in C++.
[footnote
[Analogous improvements for integer calculations were recently achieved
via standardization of integer types having specified width
such as `int8_t`, `int16_t`, `int32_t`, and `int64_t`.]
]

[endsect] [/section:introduction Introduction]

[section:thetypedefs  The proposed typedefs and potential extensions]

The core of this proposal is based on the
optional floating-point `typedef`s `float16_t`, `float32_t`,
`float64_t`, `float128_t`,
their corresponding least and fast types,
and the corresponding maximum-width type.

For example,

  // Sample partial synopsis of <cstdfloat>

  namespace std
  {
    typedef float       float32_t;
    typedef double      float64_t;
    typedef long double float128_t;
    typedef float128_t  floatmax_t;

    // ... and the corresponding least and fast types.
  }

These proposed optional floating-point `typedef`s are to conform with
the corresponding specifications of
`binary16`, `binary32`, `binary64`, and `binary128`
in __IEEE_floating_point.
In particular, `float16_t`, `float32_t`, `float64_t`, and `float128_t`
correspond to floating-point types with 11, 24, 53, and 113 binary significand digits,
respectively. These are defined in __IEEE_floating_point, and there are more detailed descrptions
of each type at __IEEE_Half, __IEEE_Single, __IEEE_Double, __IEEE_Quad, and __IEEE_Extended.

One could envision two ways to name the proposed
optional floating-point `typedef`s having specified width:

* `float11_t, float24_t, float53_t, float113_t, ...`
* `float16_t, float32_t, float64_t, float128_t, ...`

The first set above is intuitively coined from [@http://dx.doi.org/10.1109/IEEESTD.2008.4610935 IEE754:2008].
It is also consistent with the gist of integer types having specified width
such as `int64_t`, in so far as the number of binary digits of ['significand] precision
is contained within the name of the data type.

On the other hand, the second set with the size of the ['whole type] contained within
the name may be more intuitive to users. Here, we prefer the latter naming scheme.

No matter what naming scheme is used, the exact layout and number of significand
and exponent bits can be confirmed as IEEE754 by checking
`std::numeric_limits<type>::is_iec559 == true`, and the byte-order.

We will now consider several examples showing how
various implementations might introduce some of the
optional floating-point `typedef`s having specified width
into the `std` namespace.

An implementation has `float` and `double` corresponding to
IEEE754 `binary32`, `binary64`, respectively. This implementation
could introduce `float32_t`, `float64_t`, and `floatmax_t`
into the `std` namespace as shown below.

  // In <cstdfloat>

  namespace std
  {
    typedef float     float32_t;
    typedef double    float64_t;
    typedef float64_t floatmax_t;
  }

There may be a need for octuple-precision float, in other words
an extension to `float256_t` with about 240 binary significand digits of precision.
In addition, a `float512_t` type with even more precision
may be considered as a option. Beyond these, there may be
potential extension to multiprecision types, even __arbitrary_precision, in the future.

Consider an implementation for a supercomputer. This platform might have
`float`, `double`, and `long double` corresponding to IEEE754
`binary32`, `binary64`, and `binary128`, respectively. In addition, this
platform might have a user-defined type with octuple-precision.
The implementation for this supercomputer could introduce
its optional floating-point `typedef`s having specified width
into the `std` namespace as shown below.

  // In <cstdfloat>

  namespace std
  {
    typedef float                     float32_t;
    typedef double                    float64_t;
    typedef long double               float128_t;
    typedef my_octuple_precision_type float256_t;
    typedef float256_t                floatmax_t;
  }

A cost-sensitive 8-bit microcontroller platform without an FPU
does not have sufficient resources to support the eight-byte, 64-bit
`binary64` type in a feasible fashion.
An implementation for this platform can, however, support
half-precision `float16_t` and single-precision `float32_t`.
This implementation could introduce
its optional floating-point `typedef`s having specified width
into the `std` namespace as shown below.

  // In <cstdfloat>

  namespace std
  {
    typedef my_half_precision_type float16_t;
    typedef float                  float32_t;
    typedef float32_t              floatmax_t;
  }

The popular [@http://gcc.gnu.org/wiki/x87note Intel X8087 chipset]
architecture supports a 10-byte floating-point format.
It may be useful to extend the optional support to `float80_t`.
Several implementations using __IEEE_80_bit already exist in practice.

Consider an implementation that supports single-precision `float`,
double-precision `double`, and 10-byte `long double`.
This implementation could introduce its optional `typedef`s
`float32_t`, `float64_t`, `float80_t`, and `floatmax_t`
into the `std` namespace as shown below.

  // In <cstdfloat>

  namespace std
  {
    typedef float       float32_t;
    typedef double      float64_t;
    typedef long double float80_t;
    typedef float80_t   floatmax_t;
  }

[endsect] [/section:thetypedefs The proposed types and potential extensions]

[section:literals Handling floating-point literals]

We will now examine how to use floating-point literal constants in combination
with the optional floating-point `typedef`s having specified width.
This will be done in a manner analagous to the mechanism
specified for integer types having specified width,
in other words using C-style macros.

The header `<cstdfloat>` should contain all necessary
C-style function macros in the form shown below.

  FLOAT{16 32 64 128 256 MAX}_C

The code below, for example, initializes a constant `float128_t`
value using one of these macros.

  #include <cstdfloat>

  constexpr std::float128_t euler = FLOAT128_C(0.57721566490153286060651209008240243104216);

The following code initializes a constant `float16_t`
value using another one of these macros.

  #include <cstdfloat>

  constexpr std::float16_t euler = FLOAT16_C(0.577216);

In addition, the header `<cstdfloat>` should contain all
necessary macros of the form:

  FLOAT_[FAST LEAST]{16 32 64 128 256}_MIN
  FLOAT_[FAST LEAST]{16 32 64 128 256}_MAX
  FLOATMAX_MIN
  FLOATMAX_MAX

These macros can be used to query the ranges of
the optional floating-point `typedef`s having specified width
at compile-time. For example,

  #include <limits>
  #include <cstdfloat>

  static_assert(FLOATMAX_MAX > (std::numeric_limits<float>::max)(),
                "The floating-point range is too small");

[endsect] [/section:literals Handling floating-point literals]

[section:thestandard Place in the standard]

The proper place for defining the optional
floating-point `typedef`s having specified width
should be oriented along the lines of the current standard.
Consider the existing specification of integer `typedef`s having
specified precision in C++11. A partial synopsis is shown below.

18.4 Integer types [cstdint]
18.4.1 Header <cstdint> synopsis [cstdint.syn]

  namespace std
  {
    typedef signed integer type int8_t;  // optional
    typedef signed integer type int16_t; // optional
    typedef signed integer type int32_t; // optional
    typedef signed integer type int64_t; // optional
  }

  // ... and the corresponding least and fast types.

It is not immediately obvious where the
optional floating-point `typedef`s having specified width
should reside. One potential place is `<cstdint>`.
The `int`, however, implies integer types. Here, we prefer the
proposed new header `<cstdfloat>`.

We propose to add a new header `<cstdfloat>` to the standard library.
The header `<cstdfloat>` should contain all
optional floating-point `typedef`s having specified width
included in the implementation and the corresponding C-style
macros shown above.

Section 18.4 could be extended as shown below.

18.4? Integer and Floating-Point Types Having Specified Width
18.4.1 Header <cstdint> synopsis [cstdint.syn]
18.4.2? Header <cstdfloat> synopsis [cstdfloat.syn]

  namespace std
  {
    typedef floating-point type float16_t;   // optional.
    typedef floating-point type float32_t;   // optional.
    typedef floating-point type float64_t;   // optional.
    typedef floating-point type float80_t;   // optional.
    typedef floating-point type float128_t;  // optional.
    typedef floating-point type float256_t;  // optional.
    typedef floating-point type floatmax_t;  // optional.

    typedef floating-point type float_least16_t;  // optional.
    typedef floating-point type float_least32_t;  // optional.
    typedef floating-point type float_least64_t;  // optional.
    typedef floating-point type float_least80_t;  // optional.
    typedef floating-point type float_least128_t; // optional.
    typedef floating-point type float_least256_t; // optional.

    typedef floating-point type float_fast16_t;  // optional.
    typedef floating-point type float_fast32_t;  // optional.
    typedef floating-point type float_fast64_t;  // optional.
    typedef floating-point type float_fast80_t;  // optional.
    typedef floating-point type float_fast128_t; // optional.
    typedef floating-point type float_fast256_t; // optional.
  }

[endsect] [/section:thestandard Place in the standard]

[section:cmathinterop Interoperation with <cmath> and special functions]

It is not proposed to make any changes to `<cmath>` or special functions.

Any of the optional floating-point `typedef`s having specified width
that are `typedef`ed from the built-in types `float`, `double`, and `long double`
should automatically be supported by
the implementation's existing `<cmath>` and special functions.

Implementation-specific optional floating-point `typedef`s having specified width
that are not derived from `float`, `double`, and `long double` can optionally
be supported by `<cmath>` and special functions.
This is considered an implementation detail.

[note Support of elementary functions and possibly some special functions,
even where only optional, can be quite useful for real-life computational regimes.]

[endsect] [/section:cmathinterop Interoperation with <cmath> and special functions]

[section:limitsinterop Interoperation with <limits>]

It is not proposed to make any changes to `<limits>`.

Any of the optional floating-point `typedef`s having specified width
that are `typedef`ed from the built-in types `float`, `double`, and `long double`
should automatically be supported by
the implementation's existing `<limits>`.

Implementation-specific optional floating-point `typedef`s having specified width
that are not derived from `float`, `double`, and `long double` can optionally
be supported by `<limits>`.
This is considered an implementation detail.

[note Support for `<limits>`, even where optional, can be quite
useful. This allows programs query the floating-point limits
and use, among other things, `std::numeric_limits<>::is_iec559`
to determine if a floating-point type conforms with __IEEE_floating_point.]

[endsect] [/section:limitsinterop Interoperation with <limits>]

[section:complexinterop Interoperation with <complex>]

It is not proposed to make any changes to `<complex>`.

Any of the optional floating-point `typedef`s having specified width
that are `typedef`ed from the built-in types `float`, `double`, and `long double`
should automatically be supported by
the implementation's existing `<complex>`.

Implementation-specific optional floating-point `typedef`s having specified width
that are not derived from `float`, `double`, and `long double` can optionally
be supported by `<complex>`.
This is considered an implementation detail.

[endsect] [/section:complexinterop Interoperation with <complex>]

[section:context The context among existing implementations]

Many existing implementations already support `float`, `double`, and `long double`.
In addition, some of these either are or strive to be compliant with __IEEE_floating_point.
In these cases, it will be straightforward to support (at least) a subset
of the proposed optional floating-point `typedef`s having specified width
by adding any desired optional type definitions and the corresponding
macro definitions.

Some implementations for cost-sensitive microcontroller platforms support
`float`, `double`, and `long double`, and some of these are compliant with __IEEE_floating_point.
Some of these implementations treat `double` exactly as `float`,
and even treat `long double` exactly as `double`.
This is permitted by the standard which does not prescribe the precision
for any floating-point (or integer) types, leaving them to be implementation-defined.
On these platforms, the existing floating-point types could optionally
be type-defined to `float32_t`.
Optional support for an extension to `float16_t` could provide a very useful
and efficient floating-point type with half-precision, but reduced range.

Some implementations for cost-sensitive microcontroller platforms
also support a 24-bit floating-point type. Here, an extension
of the optional floating-point `typedef`s with specified width
could include `float24_t`. This would be equivalent to
three-quarter precision floating-point, which is not
specified in __IEEE_floating_point.

The [@http://gcc.gnu.org/wiki/x87note Intel X8087 chipset] is capable of performing
calculations with internal 80-bit registers. This increases the width of the
significand from 53 to 63 bits, thereby gaining about 3 decimal digits precision
and extending it from 18 and 21. If an implementation has a type that uses
all 80 bits from this chipset to calculate
[@http://en.wikipedia.org/wiki/Extended_precision Extended precision],
it could could use an optional `typedef` of this type to `float80_t`.

Some hardware, for example [@http://en.wikipedia.org/wiki/SPARC Sparc],
provides a full 128-bit quadruple-precision floating-point chip.
An implementation for this kind of architecture might already have
a built-in type corresponding to `binary128`, and this type could be
optionally `typedef`ed to `float128_t`.

GCC has recently developed quadruple-precision support on a variety of
platforms using __libquadmath. However, the implementation-specific
type `__float128` is used rather than `long double`.
These implementations could optionally `typedef` `__float128` to `float128_t`
in addition to any other optional `typedef`s.

[@http://www.opensource.apple.com/source/gcc/gcc-5646/gcc/config/rs6000/darwin-ldouble.c Darwin]
`long double` uses a double-double format developed first by
[@http://keithbriggs.info/doubledouble.html Keith Briggs].
This gives about 106-bits of precision (about 33 decimal digits) but has rather odd behavior
at the extremes making implementation of `std::numeric_limits<>::epsilon()` problematic.

[note On powerful PCs and workstations, `long double` has been treated
in a variety of ways, and this has given rise to numerous portability problems.
It may be useful if future implementations for powerful PCs and workstations
strive to make `long double` equivalent to quadruple-precision (__IEEE_Quad)
and to `typedef` this to `float128_t`. Some architectures have hardware support
for this. Those lacking direct hardware support can use software emulation.]

TBD by Chris: Question: Table of recommended precisions and float layouts?

TBD by Chris: Clearly state that only 16, 32, 64, 128 are portable, as only these are IEEE754.

[h4 Survey of existing extended precision types]

# [@http://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html   GNU C supports additional floating types, `__float80` and `__float128` to support 80-bit (XFmode) and 128-bit (TFmode) floating types.]

# __Quad by Intel Intel64 mode on Linux (V12.1) provides 128 bit `long double` in C, however it appears that it only provides computation at 80-bit format giving 64-bit significand precision, and other bits are just padding.
# [@http://software.intel.com/en-us/forums/topic/358476 Intel FORTRAN REAL*16] is an actual 128-bit IEEE quad, emulated in software. But "I don't know of any plan to implement full C support for 128-bit IEEE format, although evidently ifort has support libraries."  This is equivalent to the proposed float128_t type.

# The 360/85 and follow-on System/370 added support for a 128-bit "extended" __IBM_hexadecimal. These formats are still supported in the current design, where they are now called the "hexadecimal floating point" (HFP) formats.

# With the availability of Boost.Multprecision, C++ programmers can now easily switch to using floating-point types that give far more decimal digits of precision (hundreds) than the built-in types `float`, `double` and `long double`.

[endsect] [/section:context The context among existing implementations]


[section:references References]

# [@http://isocpp.org/std/meetings-and-participation/papers-and-mailings isocpp.org C++ papers and mailings]

# [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3352.html C++ Binary Fixed-Point Arithmetic, N3352, Lawrence Crowl]

# [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3407.html Proposal to Add Decimal Floating Point Support to C++, N3407 Dietmar Kuhl]

# The C committee is working on a Decimal TR as TR 24732.
The decimal support in C uses built-in types _Decimal32, _Decimal64, and _Decimal128.
[@http://www.cesura17.net/~will/Professional/Research/Papers/retrospective.pdf
128-bit decimal floating point in IEEE 754:2008]

# [@http://en.wikipedia.org/wiki/IEEE_floating_point lists binary16, 32, 64 and 128]
(and also decimal 32, 64, and 128)

# [@http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933  IEEE Std 754-2008]

# [@http://dx.doi.org/10.1109/IEEESTD.2008.4610935 IEEE Standard for Floating-point Arithmetic, IEEE Std 754-2008]

# [@http://www.cesura17.net/~will/Professional/Research/Papers/retrospective.pdf
How to Read Floating Point Numbers Accurately, William D Clinger]

# [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3548.pdf Conditionally-supported Special Math Functions for C++14, N3584, Walter E. Brown]

# [@www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3515.pdf
Walter E.Brown, Opaque Typedefs]

# [@http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n????.pdf Specification of Extended Precision Floating-point and Integer Types, Christopher Kormanyos, John Maddock]

# [@ http://gcc.gnu.org/wiki/x87note X8087 notes]

# [@http://software.intel.com/en-us/forums/topic/304052 Intel __Quad compiler '-Qoption,cpp,--extended_float_type']

[endsect] [/section:references References]

[section:version_id Version Info]

Last edit to Quickbook file __FILENAME__ was at __TIME__ on __DATE__.

[tip This should appear on the pdf version
(but may be redundant on a html version where the last edit date is on the first (home) page).]

[warning Home page "Last revised" is GMT, not local time.  Last edit date is local time.]
[/See also Adobe Reader pdf File Properties for creation date, and PDF producer, version and page count.]

[endsect] [/section:version_id Version Info]

[/ precision.qbk
  Copyright 2013 Paul A. Bristow
  Copyright 2013 Christopher Kormanyos.
  Copyright 2013 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]
