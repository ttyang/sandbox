[library Boost.TypeErasure
    [quickbook 1.5]
    [authors [Watanabe, Steven]]
    [copyright 2011 Steven Watanabe]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [purpose Runtime polymorphism based on concepts]
]

[def __any [classref boost::type_erasure::any any]]
[def __any_cast [funcref boost::type_erasure::any_cast any_cast]]
[def __tuple [classref boost::type_erasure::tuple tuple]]
[def __rebind_any [classref boost::type_erasure::rebind_any rebind_any]]
[def __derived [classref boost::type_erasure::derived derived]]
[def __concept_interface [classref boost::type_erasure::concept_interface concept_interface]]
[def __constructible [classref boost::type_erasure::constructible constructible]]
[def __destructible [classref boost::type_erasure::destructible destructible]]
[def __copy_constructible [classref boost::type_erasure::copy_constructible copy_constructible]]
[def __assignable [classref boost::type_erasure::assignable assignable]]
[def __typeid_ [classref boost::type_erasure::typeid_ typeid_]]
[def __relaxed_match [classref boost::type_erasure::relaxed_match relaxed_match]]
[def __binding [classref boost::type_erasure::binding binding]]
[def __static_binding [classref boost::type_erasure::static_binding static_binding]]
[def __placeholder [classref boost::type_erasure::placeholder placeholder]]
[def __call [funcref boost::type_erasure::call call]]
[def __deduced [classref boost::type_erasure::deduced deduced]]

[def __addable [classref boost::type_erasure::addable addable]]
[def __subtractable [classref boost::type_erasure::subtractable subtractable]]
[def __multipliable [classref boost::type_erasure::multipliable multipliable]]
[def __dividable [classref boost::type_erasure::dividable dividable]]
[def __modable [classref boost::type_erasure::modable modable]]
[def __bitandable [classref boost::type_erasure::bitandable bitandable]]
[def __bitorable [classref boost::type_erasure::bitorable bitorable]]
[def __bitxorable [classref boost::type_erasure::bitxorable bitxorable]]
[def __left_shiftable [classref boost::type_erasure::left_shiftable left_shiftable]]
[def __right_shiftable [classref boost::type_erasure::right_shiftable right_shiftable]]
[def __add_assignable [classref boost::type_erasure::add_assignable add_assignable]]
[def __subtract_assignable [classref boost::type_erasure::subtract_assignable subtract_assignable]]
[def __multiply_assignable [classref boost::type_erasure::multiply_assignable multiply_assignable]]
[def __divide_assignable [classref boost::type_erasure::divide_assignable divide_assignable]]
[def __mod_assignable [classref boost::type_erasure::mod_assignable mod_assignable]]
[def __bitand_assignable [classref boost::type_erasure::bitand_assignable bitand_assignable]]
[def __bitor_assignable [classref boost::type_erasure::bitor_assignable bitor_assignable]]
[def __bitxor_assignable [classref boost::type_erasure::bitxor_assignable bitxor_assignable]]
[def __left_shift_assignable [classref boost::type_erasure::left_shift_assignable left_shift_assignable]]
[def __right_shift_assignable [classref boost::type_erasure::right_shift_assignable right_shift_assignable]]
[def __incrementable [classref boost::type_erasure::incrementable incrementable]]
[def __decrementable [classref boost::type_erasure::decrementable decrementable]]
[def __negatable [classref boost::type_erasure::negatable negatable]]
[def __complementable [classref boost::type_erasure::complementable complementable]]
[def __dereferenceable [classref boost::type_erasure::dereferenceable dereferenceable]]
[def __callable [classref boost::type_erasure::callable callable]]
[def __subscriptable [classref boost::type_erasure::subscriptable subscriptable]]
[def __equality_comparable [classref boost::type_erasure::equality_comparable equality_comparable]]
[def __less_than_comparable [classref boost::type_erasure::less_than_comparable less_than_comparable]]
[def __ostreamable [classref boost::type_erasure::ostreamable ostreamable]]
[def __istreamable [classref boost::type_erasure::istreamable istreamable]]
[def __iterator [classref boost::type_erasure::iterator iterator]]
[def __forward_iterator [classref boost::type_erasure::forward_iterator forward_iterator]]
[def __bidirectional_iterator [classref boost::type_erasure::bidirectional_iterator bidirectional_iterator]]
[def __random_access_iterator [classref boost::type_erasure::random_access_iterator random_access_iterator]]
[def __same_type [classref boost::type_erasure::same_type same_type]]

[def __BOOST_TYPE_ERASURE_MEMBER [macroref BOOST_TYPE_ERASURE_MEMBER]]
[def __BOOST_TYPE_ERASURE_FREE [macroref BOOST_TYPE_ERASURE_FREE]]

[section:introduction Introduction]

The TypeErasure library provides runtime polymorphism
in C++, superior to that provided by the core language.

We have two distinct kinds of polymorphism built in to C++,
virtual functions and templates, which each have
their own advantages and disadvantages.

* Virtual functions are not resolved until runtime,
  while templates are always resolved at compile
  time.  If your types can vary at runtime (for
  example, if they depend on user input), then
  static polymorphism with templates doesn't help much.
* Virtual functions can be used with separate compilation.
  The body of a template has to be available
  in every translation unit in which it is used,
  slowing down compiles and increasing rebuilds.
* Virtual function automatically make the requirements
  on the aruments explicit.  Templates are only
  checked when they're instantiated, requiring
  extra work in testing, assertions, and documentation.
* The compiler creates a new copy of each function
  template every time it is instantiated.  This
  allows better optimization, because the compiler
  knows everything statically, but it also causes
  a significant increase of binary sizes.
* Templates support Value semantics.  Objects that
  "behave like an int" and are not shared are easier
  to reason about.  To use virtual functions, on
  the other hand, you have to use (smart) pointers
  or references.
* Template libraries can allow third-party types to
  be adapted non-intrusively for seamless interoperability.
  With virtual functions, you have to create a wrapper
  that inherits from the base class.
* Templates can handle constraints involving
  multiple types.  For example, std::for_each
  takes an iterator range and a function that
  can be called on the elements of the range.
  Virtual functions aren't really able to
  express such constraints.

The Boost.TypeErasure library provides another set
of trade-offs.  As with virtual functions, dispatching
occurs at runtime and you can define a function once
in a source file.  The requirements are stated up front
in the form of a Concept.  Like templates, the library
supports value semantics, non-intrusive adaptation, and
requirements across multiple types.

Boost includes several special cases of this kind
of polymorphism:

* `boost::any` for CopyConstructible types.
* `boost::function` for objects that can be called like functions.
* Boost.Range provides `any_iterator`.

Boost.TypeErasure generalizes this to support arbitrary
requirements and provides a
[link boost_typeerasure.predef predefined set of common concepts]

[endsect]

[section:reading How to read this documentation]

To avoid excessive verbosity, all the examples
assume that a few using directives are in place.

    namespace mpl = boost::mpl;
    using namespace boost::type_erasure;

[endsect]

[section:basic Basic Usage]

[import ../example/basic.cpp]
[basic]

[section Composing Concepts]
[import ../example/compose.cpp]
[compose]
[endsect]

[section Conversions]
[import ../example/convert.cpp]
[convert]
[endsect]

[endsect]

[section:concept Concepts in Depth]

[section:custom Defining Custom Concepts]
[import ../example/custom.cpp]
[custom]
[endsect]

[section:overload Overloading]
[import ../example/overload.cpp]
[overload]
[endsect]

[section:references Using References]
[import ../example/references.cpp]
[references]
[endsect]

[section:construction Construction]
[import ../example/construction.cpp]
[construction]
[endsect]

[section:multi Functions with Multiple Arguments]
[import ../example/multi.cpp]
[multi]
[endsect]

[section:concept_map Concept Maps]
[import ../example/concept_map.cpp]
[concept_map]
[endsect]

[section:overload Associated Types]
[import ../example/associated.cpp]
[associated]
[endsect]

[endsect]

[section:examples Examples]

[section:print_sequence A polymorphic range formatter]
[import ../example/print_sequence.cpp]
[print_sequence]
[endsect]

[section:print_sequence A type-safe printf]
[import ../example/printf.cpp]
[printf]
[endsect]

[endsect]

[section:conceptdef Concept Definitions]

A placeholder is any type that inherits
publicly from __placeholder.

There are three kinds of concepts.

# The library defines a number of [link boost_typeerasure.predef predefined concepts].
# Any MPL Forward Sequence whose elements are
  concepts is also a concept.
# Users can define their own primitive concepts.

Each primitive concept defines a single operation.
A primitive concept must be a specialization of a
class template, with a static member function
called apply.

The template parameters of the concept
may involve placeholders.  The following are
considered.

* Each template argument may be a cv and/or reference
  qualified placeholder type.
* If a template argument is a function type, its
  arguments and return type may be cv/reference
  qualified placeholders.

Any other placeholders are ignored.

When a concept is instantiated with a specific
set of type bindings, each placeholder is bound
to a cv-unqualified non-reference type.  After
replacing each placeholder in the template argument
list with the type that it binds to, the following
must hold.

* The number of arguments of apply in the
  bound concept must be the same as the number
  of arguments in the unbound concept.
* The arguments and return type of apply in the
  bound concept can be derived from the corresponding
  arguments and the return type in the unbound concept
  as follows: If the argument in the unbound concept is a
  placeholder with optional cv and reference
  qualifiers, then the argument in the bound
  concept can be found by replacing the placeholder.
  Otherwise, the argument in the unbound concept
  must be the same as the argument in the bound concept.

[endsect]

[section:predef Predefined Concepts]

In the following tables, `T` and `U` are the types that the operation
applies to, `R` is the result type.  `T` always defaults
to `_self` to match the default behavior of any.  These
concepts assume normal semantics.  Thus, comparison
operators always return bool, and references will be
added to the arguments and results as appropriate.

[table:special Special Members
    [[concept][notes]]
    [[__constructible`<Sig>`][-]]
    [[__copy_constructible`<T>`][-]]
    [[__destructible`<T>`][-]]
    [[__typeid_`<T>`][-]]
]
[table:unary Unary Operators
    [[operator][concept][notes]]
    [[`operator++`][__incrementable`<T>`][There is no separate post-increment]]
    [[`operator--`][__decrementable`<T>`][There is no separate post-decrement]]
    [[`operator*`][__dereferenceable`<R, T>`][`R` should usually be a reference]]
    [[`operator~`][__complementable`<T, R = T>`][-]]
    [[`operator-`][__negatable`<T, R = T>`][-]]
]

[table:binary Binary Operators
    [[operator][concept][notes]]
    [[`operator+`][__addable`<T, U = T, R = T>`][-]]
    [[`operator-`][__subtractable`<T, U = T, R = T>`][-]]
    [[`operator*`][__multipliable`<T, U = T, R = T>`][-]]
    [[`operator/`][__dividable`<T, U = T, R = T>`][-]]
    [[`operator%`][__modable`<T, U = T, R = T>`][-]]
    [[`operator&`][__bitandable`<T, U = T, R = T>`][-]]
    [[`operator|`][__bitorable`<T, U = T, R = T>`][-]]
    [[`operator^`][__bitxorable`<T, U = T, R = T>`][-]]
    [[`operator<<`][__left_shiftable`<T, U = T, R = T>`][-]]
    [[`operator>>`][__right_shiftable`<T, U = T, R = T>`][-]]
    [[`operator==` and `!=`][__equality_comparable`<T, U = T>`][`!=` is implemented in terms of `==`]]
    [[`operator<`, `>`, `<=`, and `>=`][__less_than_comparable`<T, U = T>`][All are implemented in terms of `<`]]
    [[`operator+=`][__add_assignable`<T, U = T>`][-]]
    [[`operator-=`][__subtract_assignable`<T, U = T>`][-]]
    [[`operator*=`][__multiply_assignable`<T, U = T>`][-]]
    [[`operator/=`][__divide_assignable`<T, U = T>`][-]]
    [[`operator%=`][__mod_assignable`<T, U = T>`][-]]
    [[`operator&=`][__bitand_assignable`<T, U = T>`][-]]
    [[`operator|=`][__bitor_assignable`<T, U = T>`][-]]
    [[`operator^=`][__bitxor_assignable`<T, U = T>`][-]]
    [[`operator<<=`][__left_shift_assignable`<T, U = T>`][-]]
    [[`operator>>=`][__right_shift_assignable`<T, U = T>`][-]]
    [[`operator<<`][__ostreamable`<Os = std::ostream, T = _self>`][-]]
    [[`operator>>`][__istreamable`<Is = std::istream, T = _self>`][-]]
]

[table:misc Miscellaneous Operators
    [[operator][concept][notes]]
    [[`operator()`][__callable`<Sig, T>`][`Sig` should be a function type. T may be const qualified.]]
    [[`operator[]`][__subscriptable`<R, T, N = std::ptrdiff_t>`][`R` should usually be a reference. `T` can be optionally const qualified.]]
]

[table:iterator Iterator Concepts
    [[concept][notes]]
    [[__iterator`<Traversal, T, Reference, Difference>`][Use __same_type to control the iterator's value type.]]
    [[__forward_iterator`<T, Reference, Difference>`][-]]
    [[__bidirectional_iterator`<T, Reference, Difference>`][-]]
    [[__random_access_iterator`<T, Reference, Difference>`][-]]
]

[table:special Special Concepts
    [[concept][notes]]
    [[__same_type`<T>`][Indicates that two types are the same.]]
]

[endsect]

[xinclude reference.xml]

[section:rationale Rationale]

[section Why do I have to specify the presence of a destructor explicitly?]
When using references the destructor isn't needed.
By not assuming it implicitly, we allow capturing
types with private or protected destructors by reference.
For the sake of consistency, it must be specified
when capturing by value as well.
[endsect]

[section Why non-member functions?]
The members of __any can be customized.  By using
free functions, we guarantee that we don't interfere
with anything that a user might want.
[endsect]

[section:placeholder Why are the placeholders called `_a`, `_b` and not `_1` `_2`]

An earlier version of the library used the names `_1`, `_2`, etc.
instead of `_a`, `_b`, etc.  This caused a certain amount
of confusion because the numbered placeholders are
already used with a somewhat different meaning by several
other libraries including Boost/Std Bind, Boost.Phoenix,
and Boost.MPL.  I eventually decided that since the
placeholders represented named parameters instead of positional parameters,
letters were more appropriate than numbers.

[endsect]

[endsect]

[section:design Design Notes]

This section is purely for informational
purposes.  You don't need to read it to
understand how to use the library.  Here,
I try to explain how the library evolved
and why I chose the current interfaces.

[section:concepts Concept Interfaces]

When designing the concept system, I had a couple
of goals.  First of all, the basic definitions
need to be simple.  Second, concepts need to be
composable.  Making concepts composable is fairly
easy by recursively expanding mpl sequences.
The first goal is much harder.  In earlier
versions of TypeErasure and in most similar libraries
such as DynamicAny and Adobe::Poly, the base
definitions generally resemble the following

  struct incrementable_interface {
    virtual void increment() = 0;
  };
  template<class T>
  struct incrementable_implementation : incrementable_interface {
    virtual void increment() { ++x; }
    T x;
  };

  template<class Derived>
  struct incrementable_mixin {
    Derived& operater++();
  };

Note that we require three definitions, the
virtual interface, the virtual implementation,
and the user level interface.  In the immediate
predecessor of this library, the first two
were combined into a single template

  template<class T>
  struct incrementable :
    primitive_concept<incrementable<T>, void(T&) > {
    static void apply(T& t) { ++t; }
  };

Here, the `primitive_concept` base specifies the
function signature, serving the purpose of the
virtual interface.  We now have only one class
here, but it's still excessively complicated.
To get rid of this we can note that the signature
must be `remove_pointer<decltype(&incrementable<T>::apply)>::type`
and can therefore be deduced automatically.

[endsect]

[section:constructors Constructors]

The constructors of __any have to serve three
different purposes.  First, we have constructors
that capture the type passed.  This is what
happens when constructing an __any from an
`int` for example.  The second kind of constructor
dispatches to a constructor of the contained
type using an existing set of bindings.  This
is what happens for the copy constructor.  The
last kind of constructor "upcasts" from one
concept to another more general
concept.  For example, `any< mpl::vector<copy_constructible<>, incrementable<> > >`
should be convertible to `any<copy_constructible<> >`.
We want to define these three kinds of constructors
in an unambiguous way.  For short, we'll refer
to these three kinds of constructors an binding
constructors, dispatched constructors, and
converting constructors.

# binding constructors take an argument
  which is the object to capture and
  an optional argument specifying any
  bindings that can't be deduced.
# dispatched constructors take the
  arguments of the underlying constructor
  and an optional argument specifing
  the bindings to use.  (This extra
  argument is needed when the bindings
  can't be deduced because none of
  the arguments is an any.)
# converting constructors take an
  argument which must be an __any
  and an optional argument indicating
  how placeholders should be substituted.

Now, where are the ambiguities?

* A single argument which is not an __any
  can only match a binding constructor.
  It cannot match a dispatching constructor
  because we don't have anything to dispatch on.
  It can't match a converting constructor
  because it isn't an __any.
* A single argument which is an __any can
  match all three. We'll rule out binding
  constructors by arbitrarily deciding that
  an __any can never contain another __any.
  This makes our job a lot easier.  This
  leaves us with dispatched constructors
  vs. converting constructors.  If the
  Concept of the argument is different
  from the Concept of the type being
  constructed, we have to have a converting
  constructor.  If the concepts are the
  same and the placeholders are the same,
  then we have the copy constructor, and
  there is no difference between the
  dispatched constructor and the converting
  constructor.  If the placeholders are
  different, then we call the dispatched
  constructor.  In theory it's possible
  that this is intended to be converting constructor,
  but this is rare.
* For two arguments, the converting and binding
  constructors take one argument that is either
  a __binding or a __static_binding.  They
  can be distinguised by whether the other
  argument is an __any or not.

We'll add one more requirement to avoid
going crazy.  No argument of a constructor
to __any shall be __binding or __static_binding,
except for the ones that are explicitly
allowed.

Now, we can at least allow users to explicily
avoid any ambiguity with the following rules.

# If there are exactly two arguments and the
  first argument is neither an __any nor a specialization
  of __binding or __static_binding, and the second
  argement is a specialization of __binding
  or __static_binding, then this is a binding
  constructor.
# If the first argument is a specialization
  of __binding, then this is a dispatching
  constructor.
# If there are exactly two arguments and the
  first argument is an __any and the second
  argument is a specialization of __binding
  or __static_binding, the constructor is
  a converting constructor.

These are not ambiguous and any constructor
call can be converted to one of these forms.
Note in particular that the order of the
arguments is important.  If the *first*
argument is a __binding, then we have a
dispatched constructor.  If the *second*
argument is a __binding or a __static_binding,
then we have either a binding constructor or
a converting constructor.

[endsect]

[section:binding Binding]

The easiest implementation of manual type erasure
uses virtual functions.  However, virtual functions
are somewhat limited.  We get a lot more flexibility
by using explicit tables of function pointers.

* A table can be constructed dynamically.  This
  allows us to implement conversions by creating
  a subset of the table.
* A table is easy to share between multiple types.
  This makes it easier to implement multi-type concepts
  and __any references.
* A table can be passed around without a corresponding
  object.  This allows us to implement captured constructor
  calls that don't take an __any argument.

[endsect]

[endsect]

[section:feedback Feedback Wanted]

There are a number of things that I'm not entirely
happy about.  Any thoughts about them would be
greatly appreciated.

* The name `_self`.  Basically, I need some placeholder
  to act as a default.  Since placeholders act as a
  substitute for template parameters, I'd really like
  to use `_T`.  Alack-a-day, `_T` is a reserved identifier.
  `_self` was the best I could think of.
* Implicit conversions.  Implicit conversion from the
  contained type to a reference any is not allowed.
  The reason for this is that I found that such
  conversions were interefering with overload resolution.
  Getting overload resolution to work correctly in
  the following would be a lot more difficult if
  implicit conversion were allowed:
  ``
    typedef mpl::vector<
        copy_constructible<>,
        constructible<_self(const std::string&)>
    > concept;
    any<concept> x = ...;
    any<concept> y(binding_of(x), "hello");
  ``
  Without great care we end up with an ambiguity
  between the `std::string` constructor and the
  copy constructor.  User-defined overloaded
  functions would also need to handle this somehow.
  I decided that it was better to avoid the whole
  problem by disabling implicit conversions.
* __relaxed_match.  I considered a lot of names
  for this, `strict_match<false>`, `enable_mixed`,
  `nonstrict_match`, `loose_match`, `best_effort`,
  and probably more that I've forgotten.  I'm not
  really happy with any of them.  I'm not really
  happy about having it in `Concept` either, but
  I'm not sure where else it could go.  It's presence
  can affect the contents of the vtable, so if it
  were a separate template argument, it would have
  to be passed to __binding as well.  It would generally
  add complication.

[endsect]

[section:future Future Work]

These are just some ideas.  There is absolutely no
guarantee that any of them will ever be implemented.

* Use SBO.
* Allow more control over vtable layout.
* Attempt to reuse sub-tables in conversions.
* Allow "dynamic_cast".
* Use C++0x features.  (Rvalue references and
  variadic templates in particular.)
* Optimize the compile-time cost.

[endsect]


[section:acknowledgements Acknowledgements]

The name `any` was taken from Alexander Nasonov's
DynamicAny library.

Thanks to review manager, Lorenzo Caminiti
and all who participated in the formal review:

* Christophe Henry
* Paul Bristow
* Karsten Ahnert
* Pete Bartlett
* Sebastian Redl
* Hossein Haeri
* Trigve Siver
* Julien Nitard
* Eric Niebler
* Fabio Fracassi
* Joel de Guzman
* Alec Chapman
* Larry Evans
* Vincente J. Botet Escriba
* Marcus Werle
* Andrey Semashev
* Dave Abrahams
* Thomas Jordan

[endsect]
