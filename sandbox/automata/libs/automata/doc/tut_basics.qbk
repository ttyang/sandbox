[/=============================================================================
    Copyright (C) 2007-2011 Cromwell D. Enage

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    [@http://www.boost.org/LICENSE_1_0.txt])
=============================================================================/]

[section:basics Tutorial: Basics]
The classical application for automata is
[@http://en.wikipedia.org/wiki/Syntax_analysis syntax analysis], of which step
one is scanning.  In this example, we will implement a minimal
[@http://en.wikipedia.org/wiki/Lexical_analysis scanner] for several
[@http://en.wikipedia.org/wiki/Context-free_language context-free
languages].  A *minimal scanner* simply accepts a sequence of [termlink input
symbols] if and only if that sequence is part of the language for which the
scanner is implemented.

Each context-free language can be formulated in terms of a corresponding
[@http://en.wikipedia.org/wiki/Context-free_grammar context-free grammar].  The
following grammars will generate our example languages (0 denotes the empty
string):

[*Grammar 1]
[pre S --> aSb | 0]

[*Grammar 2]
[pre S --> x | y | z | S+S | S-S | S*S | S/S | (S)]

[*Grammar 3]
[pre S --> aSc | B
B --> bBc | 0]

Each string in the language generated by the first grammar can have any number
of `'a'`s followed by the same number of `'b'`s.  Each string in the language
generated by the second grammar must be an infix arithmetic expression over the
variables `'x'`, `'y'`, and `'z'`.  Each string in the language generated by
the third grammar can have any number of `'a'`s followed by any number of
`'b'`s, as long as the number of following `'c'`s is equal to the sum of the
number of `'a'`s and the number of `'b'`s.

The scanner type that is compatible with all of these languages is the
__DPDA__.  Our objective is to be able to use the DPDA to accept or reject
a given word, as the following routine does:

[test__accept__function_template]

The automaton processes each input letter via its function call
operator.  This operator must return true at all times, and the DPDA's stack
must be empty, in order for the routine to accept the word.  As soon as the
automaton rejects an input letter, the routine rejects the entire word.

[heading Recipe]
An automaton is nothing without a [termlink transition function].  The first
thing we need is a type definition that uses the __dpda_transition_function__
class template.

[test__dpda_trans_func__typedef]

The ability to initialize a __DPDA__ will be provided by several functions
that model the __Automaton_Builder__ concept.  Each of these functions takes
in a single argument: a reference to a transition function object.  For the
language generated by the first example grammar, we have:

[test__dpda_build1__function]

The overall [termlink current state] of a [termlink pushdown automaton] is the
combination of the contents of its stack, if any, and the current value of its
[termlink state register].  When the pushdown automaton is initialized or
reset, its stack is emptied and its state register is set to zero by default.

  # The transition function's `reset()` member function call sets the finite
    automaton component to recognize two state register values--0 and 1--and
    removes all transitions previously added.
  # The first `set_transition()` call means: if the current state register
    value is 0 and the next input symbol is an `\'a\'`, then don\'t pop
    anything from the stack, push an `\'S\'` onto the stack, and maintain the
    current state register value.
  # The second and third `set_transition()` calls mean: if the next input
    symbol is a `\'b\'` and the top of the stack is an `\'S\'`, then pop from
    the stack, don't push anything onto the stack, and set the state register
    value to 1.  Two calls are required because there are two valid state
    register values.

For the language generated by the second example grammar, we have:

[test__dpda_build2__function]

For illustration, let's focus on the first pair of statements after the
`reset()` call, reproduced here:

``
    function.set_transition(0, '(', r0S);
    function.set_transition(0, '(', 'A', r0S);
``

In all cases, the transition represented by the statement /with the stack
symbol to be popped/ takes precedence over the statement without one,
regardless of the order of the statements in the code; e.g. if the current
state register value is 0, the input symbol is the open parenthesis `'('`, and
the letter `'A'` is at the top of the stack, then the stack will be popped
before the letter `'S'` is pushed onto it.  The three pairs of
`set_transition()` calls that follow will abide by the same precedence rules.

For the language generated by the third example grammar, we have:

[test__dpda_build3__function]

We can now test our word accepting routine.  Each build function can be passed
to the automaton's constructor or to its `initialize()` method.

[test__basics__case]

You may be wondering why we need to instantiate an __automaton__ with a
separate __dpda_generator__ and __dpda_transition_function__ instead of
obtaining a DPDA type immediately.  This is because the __automaton__ class
template also combines other common functionality that we will see in action in
the __Observer_Policies_tutorial__ and the
__Input_Validation_and_Undoable_Automata_tutorial__.  In fact, the
__automaton__ class template is the primary front end of this library;
almost all other components work together through it, within certain
constraints.

The complete working program for this tutorial is contained in four files:

  * __test_dpda_builder_hpp__
  * __test_dpda_builder_cpp__
  * __test_basics_hpp__
  * __test_basics_cpp__

[important
    __Build__ __Boost_Test__ before you attempt to compile the program.
]
[endsect] [/ Tutorial: Basics]

