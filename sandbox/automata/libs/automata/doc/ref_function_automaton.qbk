[/=============================================================================
    Copyright (C) 2007-2011 Cromwell D. Enage

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    [@http://www.boost.org/LICENSE_1_0.txt])
=============================================================================/]

[section:function_automaton `function_automaton`]

[section Synopsis]
[reference__function_automaton]
[endsect]

[section Description]
This __Automaton__ model uses plain-vanilla __Binary_Functions__ rather
than specific __Transition_Functions__ for transitioning between states;
otherwise, it maintains much of the flexibility of the __automaton__ class
template.
[endsect]

[section:definition Where defined]
``
#include <__boost_automata_function_automaton_hpp__>
``
[endsect]

[section:tpl_param Template Parameters]
[table
    [[Parameter][Description][Requirements][Default]]
    [
        [Function]
        [
            The type of the underlying function that this `function_automaton`
            will treat as its transition function.
        ]
        [
            * It must model the __Binary_Function__ concept.
            * One of its argument types must be convertible to the return type.
        ]
        []
    ]
    [
        [`_Policies`]
        [
            The type of a heterogeneous container of policies that this
            `function_automaton` will enact.
        ]
        [
          * It must model the __Fusion_Forward_Sequence__ concept.
          * Each of its element types must model the
            __Unary_Metafunction_Class__ concept.
          * The return type of the `_BaseGenerator` template-argument type
            must be a valid argument for each element type.
          * If the `_IsUndoable` template-argument type evaluates to
            __mpl_true__, then the return type of each element type must
            model the __Undoable_Automaton_Observer__ concept; otherwise,
            the return type of each element type must model the
            __Automaton_Observer__ concept.
        ]
        [__fusion_nil__]
    ]
    [
        [`_InputValidationPolicy`]
        [
            The type that determines how this `function_automaton` will
            validate its inputs.
        ]
        [
          * It must model the __Unary_Metafunction_Class__ concept.
          * The return type of the `_BaseGenerator` template-argument type
            must be a valid argument to this type.
          * The return type must model the __Input_Validator__ concept.
        ]
        [__default_input_validation_policy__]
    ]
    [
        [`_IsUndoable`]
        [
            The type that determines whether or not this `function_automaton`
            type will model the __Undoable_Automaton__ concept.
        ]
        [It must model the __Boolean_Integral_Constant__ concept.]
        [__mpl_false__]
    ]
]

You can use the parameter names as __template_keywords__.  For example,
assume that the following function is defined:

[example__ublas_product__function]

The following type definitions are semantically equivalent:

``
typedef function_automaton<
            BOOST_TYPEOF(ublas_product)
          , _fusion_nil_
          , _default_input_validation_policy_
          , _mpl_true_
        >
        FA1;
typedef function_automaton<
            BOOST_TYPEOF(ublas_product)
          , [*_IsUndoable]<_mpl_true_>
        >
        FA2;
typedef function_automaton<
            [*_IsUndoable]<_mpl_true_>
          , [*_Function]<BOOST_TYPEOF(ublas_product)>
        >
        FA3;
``

The last two definitions have the added benefit of not having to specify the
default types of the `_Policies` and `_InputValidationPolicy` template
parameters.

All template parameter names for this class template are defined in the
`boost::automata::keyword` namespace.
[endsect] [/ Template Parameters]

[section:model_of Model of]
  * __Automaton__
  * __Automaton_With_State_Register__ if the `_Function` template-argument
    type models the __State_Register_Transition_Function__ concept
  * __Extensible_Automaton__ if the `_Policies` template-argument type is a
    non-__empty__ __Fusion_Forward_Sequence__ model
  * __Undoable_Automaton__ if the `_isUndoable` template-argument type
    evaluates to __mpl_true__
[endsect]

[section:public_bases Public Base Classes]
The return type of __deterministic_generator__ when passed in the type
[^_adaptor_transition_function_<_Function>].
[endsect]

[section Members]
[table
    [[Name][Expression][Description]]
    [
        [Transition function type]
        [`transition_function`]
        [Defined by the __Automaton__ concept.]
    ]
    [
        [Observer map type]
        [`observer_map`]
        [Defined by the __Extensible_Automaton__ concept.]
    ]
    [
        [Traits type]
        [`traits`]
        [Defined by the __Automaton__ concept.]
    ]
    [
        [Default constructor]
        [`function_automaton();`]
        [Defined by the __Default_Constructible__ concept.]
    ]
    [
        [Build Constructor]
        [``
            template <
                typename A0
              , typename A1
              , typename A2
              , typename A3
              , typename A4
            >
            function_automaton(
                A0 const&
              , A1 const& = implementation_defined
              , A2 const& = implementation_defined
              , A3 const& = implementation_defined
              , A4 const& = implementation_defined
            );
        ``]
        [
             Read the
             [link automata.reference.function_automaton.build_ctor_param
             Build Constructor Parameters] section for parameter descriptions.
        ]
    ]
    [
        [Copy constructor]
        [`function_automaton(function_automaton const&);`]
        [
          * Defined by the __Copy_Constructible__ concept.
          * Defined if and only if the return type of each element type
            of the `_Policies` template-argument type models the
            __Copyable_Observer__ concept, and the return type of the
            `_InputValidationPolicy` template-argument type models the
            __Copyable_Observer__ concept.
        ]
    ]
    [
        [Assignment operator]
        [`function_automaton& operator=(function_automaton const&);`]
        [
          * Defined by the __Assignable__ concept.
          * Defined if and only if the return type of each element type of the
            `_Policies` template-argument type models the __Assignable__
            concept, and the return type of the `_InputValidationPolicy`
            template-argument type models the __Assignable__ concept.
        ]
    ]
    [
        [State assignment operator]
        [`function_automaton& operator=(traits::state const&);`]
        [Sets the [termlink source state] of this `function_automaton`.]
    ]
    [
        [Function assignment operator]
        [``
            template <typename TFunction>
            function_automaton& operator=(TFunction);
        ``]
        [
          * Forwards to the transition function's assignment operator.
          * Defined if and only if the previously mentioned operator is
            defined and accepts the specified argument.
        ]
    ]
    [
        [Initialization]
        [``
            template <typename A0, typename A1>
            void initialize(A0 const&, A1 const& = implementation_defined);
        ``]
        [
           * Defined by the __Automaton__ concept.
           * Read the [link automata.reference.function_automaton.init_param
             Initialization Parameters] section for parameter descriptions.
        ]
    ]
    [
        [Resetting]
        [`void reset();`]
        [
          * Defined by the __Automaton__ concept.
          * If the underlying observer map is non-__empty__, then this
            `function_automaton` will invoke each observer's `on_reset()`
            method.
        ]
    ]
    [
        [Transition function accessor]
        [`transition_function const& get_transition_function() const;`]
        [Defined by the __Automaton__ concept.]
    ]
    [
        [Observer map accessor]
        [`observer_map const& get_observer_map() const;`]
        [Defined by the __Extensible_Automaton__ concept.]
    ]
    [
        [Input processing]
        [`template <typename Input> bool operator()(Input const&);`]
        [
          * Defined by the __Automaton__ concept.
          * If the underlying observer map is non-__empty__, then this
            `function_automaton` will perform one of the following actions:
              * Forward the input to each observer's `on_invalid_input()`
                method if the underlying input validator marks the input as
                invalid.
              * Forward the input to each observer's `on_accept_input()`
                method if the `function_automaton` type is a
                __Discrete_Automaton__ and the nontrivial input check
                returns `true`, or if the `function_automaton` type does *not*
                model the __Discrete_Automaton__ concept and the input
                processing implementation returns `true`.
              * Forward the input to each observer's `on_reject_input()`
                method if the `function_automaton` type is a
                __Discrete_Automaton__ and the nontrivial input check
                returns `false`, or if the `function_automaton` type does *not*
                model the __Discrete_Automaton__ concept and the input
                processing implementation returns `false`.
        ]
    ]
    [
        [Undo operation]
        [`void undo();`]
        [
          * Defined by the __Undoable_Automaton__ concept.
          * Defined if and only if the type of this `function_automaton` has
            been configured to model the __Undoable_Automaton__ concept.
          * If the underlying observer map is non-__empty__, then:
              # If the operation succeeds in restoring this
                `function_automaton` to the most recent snapshot, then it will
                invoke each observer's `on_accept_undo()` method.
              # Otherwise, the `function_automaton` will invoke each observer's
                `on_reject_undo()` method.
        ]
    ]
    [
        [Undo ability check]
        [`bool can_undo() const;`]
        [
          * Defined by the __Undoable_Automaton__ concept.
          * Defined if and only if the type of this `function_automaton` has
            been configured to model the __Undoable_Automaton__ concept.
        ]
    ]
    [
        [Undo limit access]
        [`std::size_t get_undo_limit() const;`]
        [
          * Defined by the __Undoable_Automaton__ concept.
          * Defined if and only if the type of this `function_automaton` has
            been configured to model the __Undoable_Automaton__ concept.
        ]
    ]
]
[endsect] [/ Members]

[section:build_ctor_param Build Constructor Parameters]
[table
    [[Parameter][Description][Requirements][Default]]
    [
        [`_function`]
        [
            A function object used to initialize the underlying transition
            function.
        ]
        [
          * If the `_Policies` template-argument type is non-__empty__, then
            the data type must model the __Extensible_Automaton_Builder__
            concept; otherwise, the data type must model the
            __Automaton_Builder__ concept.
          * The transition function must be a valid argument.
        ]
        []
    ]
    [
        [`_policies`]
        [
            A heterogeneous container of policies that this
            `function_automaton` will enact.  If this container is
            non-__empty__, then the automaton will transform each policy type
            into its metafunction class return type, create an instance of that
            return type as an __Observer__, and associate the policy type with
            the observer in the underlying observer map.  If this parameter is
            specified, then each observer's build constructor will be invoked;
            otherwise, each observer's subject-policy constructor will be
            invoked.
        ]
        [
            The data type must be the same as the `_Policies` template-argument
            type.
        ]
        [
            A default-constructed instance of the `_Policies` template-argument
            type.
        ]
    ]
    [
        [`_input_validation_policy`]
        [
            This `function_automaton` will transform the
            `_InputValidationPolicy` template-argument type into its
            metafunction class return type and create an instance of that
            return type as an __Input_Validator__, which it will use for
            input validation.  If this parameter is specified, then the input
            validator's build constructor will be invoked; otherwise, the input
            validator's subject-policy constructor will be invoked.
        ]
        [
            The data type must be the same as the `_InputValidationPolicy`
            template-argument type.
        ]
        [
            A default-constructed instance of the `_InputValidationPolicy`
            template-argument type.
        ]
    ]
    [
        [`_source_state`]
        [The [termlink source state] of this `function_automaton`.]
        [The data type must be convertible to `traits::state`.]
        [`traits::state()`]
    ]
    [
        [`_undo_limit`]
        [
            The number of consecutive times that the `undo()` operation can be
            carried out on this `function_automaton`.
        ]
        [
          * The data type must be a primitive integral type.
          * The type of this `function_automaton` must be configured to fulfill
            the __Undoable_Automaton__ concept.
        ]
        [`std::size_t()`]
    ]
]

You can __name_each_parameter__ when you invoke this constructor.  Continuing
the [link automata.reference.function_automaton.tpl_param type definitions
example], the following statements are semantically equivalent:

``
FA1
    fa1(
        ublas_product
      , _fusion_nil_()
      , _default_input_validation_policy_()
      , 18
      , 32
    );
FA2
    fa2(
        ublas_product
      , [*_source_state] = 18
      , [*_undo_limit] = 32
    );
FA3
    fa3(
        [*_undo_limit] = 32
      , [*_function] = ublas_product
      , [*_source_state] = 18
    );
``

The last two instructions have the added benefit of not having to specify the
default values of the `_policies` and `_input_validation_policy` parameters.

All parameter names for this operation are defined in the
`boost::automata::keyword` namespace.
[endsect] [/ Build Constructor Parameters]

[section:init_param Initialization Parameters]
[table
    [[Parameter][Description][Requirements][Default]]
    [
        [`_builder`]
        [
            A function object used to initialize the underlying transition
            function.
        ]
        [
          * If the `_Policies` template-argument type is non-__empty__, then
            the data type must model the __Extensible_Automaton_Builder__
            concept; otherwise, the data type must model the
            __Automaton_Builder__ concept.
          * The transition function must be a valid argument.
        ]
        []
    ]
    [
        [`_source_state`]
        [The [termlink source state] of this `function_automaton`.]
        [The data type must be convertible to `traits::state`.]
        [`traits::state()`]
    ]
]

You can __name_each_parameter__ when you invoke the `initialize()`
method.  All parameter names for this operation are defined in the
`boost::automata::keyword` namespace.
[endsect]

[endsect] [/ function_automaton]

