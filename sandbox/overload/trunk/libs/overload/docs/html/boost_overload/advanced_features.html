<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Advanced features</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Boost.Overload 0.4.0">
<link rel="up" href="../index.html" title="Boost.Overload 0.4.0">
<link rel="prev" href="use_case.html" title="Use case">
<link rel="next" href="design_and_definitions.html" title="Design and Definitions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="use_case.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="design_and_definitions.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_overload.advanced_features"></a><a class="link" href="advanced_features.html" title="Advanced features">Advanced features</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method">The
      set_for_each_shared_signature method</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___polymorphic_function_objects">Example
        - Polymorphic function objects</a></span></dt>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___a_statefull_polymorphic_function_object">Example
        - A statefull polymorphic function object</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support">Boost.ResultOf
      and Boost.Lambda support</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_resultof_support">Example
        - Boost.ResultOf support</a></span></dt>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_lambda_support">Example
        - Boost.Lambda support</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.a_special_variant_of_the_set_signature__method">A
      special variant of the set&lt;Signature&gt; method</a></span></dt>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.type_traits">Type Traits</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_overload.advanced_features.the_set_for_each_shared_signature_method"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method" title="The set_for_each_shared_signature method">The
      set_for_each_shared_signature method</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___polymorphic_function_objects">Example
        - Polymorphic function objects</a></span></dt>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___a_statefull_polymorphic_function_object">Example
        - A statefull polymorphic function object</a></span></dt>
</dl></div>
<p>
        The <a class="link" href="references.html#ref_overload_set_for_each_shared_sig"><code class="computeroutput"><span class="identifier">set_for_each_shared_signature</span></code></a>
        method can manage multi-signature function objects of class type (i.e. function
        objects whose <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
        is overloaded or is a template function) and it handles them in a special
        way. The passed function object sets/replaces all the existent object targets
        related to the call signatures supported by both the given instantiation
        of the template class <a class="link" href="references.html#boost_overload.references.boost_overload_hpp.class_template_overload" title="Class template overload"><code class="computeroutput"><span class="identifier">overload</span></code></a> and the passed function
        object itself.
      </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          Signature deduction of multi-signature function objects is not supported
          with Microsoft Visual C++ 7.1, you have to use the <a class="link" href="references.html#ref_overload_set_S_F"><code class="computeroutput"><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">Signature</span><span class="special">&gt;</span></code></a>
          method.
        </p></td></tr>
</table></div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          The <a class="link" href="references.html#ref_overload_set_for_each_shared_sig"><code class="computeroutput"><span class="identifier">set_for_each_shared_signature</span></code></a>
          method cannot handle either free or member polymorphic functions.
        </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___polymorphic_function_objects"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___polymorphic_function_objects" title="Example - Polymorphic function objects">Example
        - Polymorphic function objects</a>
</h4></div></div></div>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">detail</span><span class="special">/</span><span class="identifier">lightweight_test</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">/* polymorphic function object */</span>
<span class="keyword">struct</span> <span class="identifier">bar</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">-</span><span class="number">1</span><span class="special">;</span> <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">T</span><span class="special">);</span> <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overload</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">),</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">),</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">)&gt;</span> <span class="identifier">f</span><span class="special">;</span>

    <span class="comment">// function object</span>
    <span class="identifier">bar</span> <span class="identifier">foo</span><span class="special">;</span>

    <span class="comment">// we use the set_for_each_shared_signature method</span>
    <span class="comment">// for setting a copy of foo as object target for</span>
    <span class="comment">// both the shared int(int ) and int(char ) call signatures</span>
    <span class="comment">// *warning*: internally two separate boost::functions</span>
    <span class="comment">// are created</span>
    <span class="identifier">f</span><span class="special">.</span><span class="identifier">set_for_each_shared_signature</span><span class="special">(</span><span class="identifier">foo</span><span class="special">);</span>
    <span class="comment">// invokes int foo(int ) template instantiation</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">(</span><span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">foo</span><span class="special">(</span><span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="comment">// invokes int foo(char ) template instantiation</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">(</span><span class="char">'x'</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">foo</span><span class="special">(</span><span class="char">'x'</span><span class="special">)</span> <span class="special">);</span>
    <span class="comment">// through the empty&lt;Signature&gt;() method we check</span>
    <span class="comment">// that object target related to the not shared</span>
    <span class="comment">// int(int, int ) call signature is still empty</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">empty</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">)&gt;()</span> <span class="special">);</span>


    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">report_errors</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        </p>
</div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          It is important that you understand that internally for each supported
          signature a new <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span></code> object is generated exactly
          as you had used the <a class="link" href="references.html#ref_overload_set_S_F"><code class="computeroutput"><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">Signature</span><span class="special">&gt;</span></code></a>
          method. Each created <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span></code>
          instance wraps a different copy of the passed multi-signature function
          object. This behaviour can lead to unexpected result if the multi-signature
          function object has its own state. A solution to this issue is to to utilize
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span></code> for wrapping the function object.
        </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___a_statefull_polymorphic_function_object"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.the_set_for_each_shared_signature_method.example___a_statefull_polymorphic_function_object" title="Example - A statefull polymorphic function object">Example
        - A statefull polymorphic function object</a>
</h4></div></div></div>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">detail</span><span class="special">/</span><span class="identifier">lightweight_test</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">/* polymorphic function object */</span>
<span class="keyword">struct</span> <span class="identifier">bar</span>
<span class="special">{</span>
    <span class="identifier">bar</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">total_calls</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span> <span class="special">)</span> <span class="special">{</span> <span class="special">++</span><span class="identifier">total_calls</span><span class="special">;</span> <span class="keyword">return</span> <span class="special">-</span><span class="number">1</span><span class="special">;</span> <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="special">)</span> <span class="special">{</span> <span class="special">++</span><span class="identifier">total_calls</span><span class="special">;</span> <span class="keyword">return</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">T</span><span class="special">);</span> <span class="special">}</span>

    <span class="keyword">int</span> <span class="identifier">total_calls</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overload</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">),</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">)&gt;</span> <span class="identifier">f</span><span class="special">;</span>

    <span class="comment">// function object</span>
    <span class="identifier">bar</span> <span class="identifier">foo</span><span class="special">;</span>
    <span class="identifier">foo</span><span class="special">(</span> <span class="number">1</span> <span class="special">);</span> <span class="identifier">foo</span><span class="special">(</span> <span class="char">'x'</span> <span class="special">);</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">foo</span><span class="special">.</span><span class="identifier">total_calls</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>

    <span class="identifier">f</span><span class="special">.</span><span class="identifier">set_for_each_shared_signature</span><span class="special">(</span><span class="identifier">foo</span><span class="special">);</span>
    <span class="identifier">f</span><span class="special">(</span><span class="number">1</span><span class="special">);</span> <span class="identifier">f</span><span class="special">(</span><span class="char">'x'</span><span class="special">);</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">foo</span><span class="special">.</span><span class="identifier">total_calls</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span> <span class="comment">// not 4</span>
    <span class="comment">// f.get&lt;int (int )&gt;() and f.get&lt;double (double )&gt;() are</span>
    <span class="comment">// different boost::function instances that own two</span>
    <span class="comment">// different copy of the foo function object</span>
    <span class="keyword">const</span> <span class="identifier">bar</span><span class="special">*</span> <span class="identifier">foo_copy_1</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">)&gt;().</span><span class="identifier">target</span><span class="special">&lt;</span><span class="identifier">bar</span><span class="special">&gt;();</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">foo_copy_1</span><span class="special">-&gt;</span><span class="identifier">total_calls</span> <span class="special">==</span> <span class="number">3</span> <span class="special">);</span> <span class="comment">// not 4</span>
    <span class="keyword">const</span> <span class="identifier">bar</span><span class="special">*</span> <span class="identifier">foo_copy_2</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">)&gt;().</span><span class="identifier">target</span><span class="special">&lt;</span><span class="identifier">bar</span><span class="special">&gt;();</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">foo_copy_2</span><span class="special">-&gt;</span><span class="identifier">total_calls</span> <span class="special">==</span> <span class="number">3</span> <span class="special">);</span> <span class="comment">// not 4</span>

    <span class="identifier">f</span><span class="special">.</span><span class="identifier">clear_all</span><span class="special">();</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">empty_all</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// foo.total_calls is still equal to 2</span>

    <span class="comment">//</span>
    <span class="identifier">f</span><span class="special">.</span><span class="identifier">set_for_each_shared_signature</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">foo</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">f</span><span class="special">(</span><span class="number">1</span><span class="special">);</span> <span class="identifier">f</span><span class="special">(</span><span class="char">'x'</span><span class="special">);</span>
    <span class="comment">// f.get&lt;int (int )&gt;() and f.get&lt;double (double )&gt;()</span>
    <span class="comment">// are different boost::function instances</span>
    <span class="comment">// that own a reference to the same function object</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">foo</span><span class="special">.</span><span class="identifier">total_calls</span> <span class="special">==</span> <span class="number">4</span> <span class="special">);</span>
    <span class="keyword">const</span> <span class="identifier">bar</span><span class="special">*</span> <span class="identifier">foo_ref_1</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">)&gt;().</span><span class="identifier">target</span><span class="special">&lt;</span><span class="identifier">bar</span><span class="special">&gt;();</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">foo_ref_1</span><span class="special">-&gt;</span><span class="identifier">total_calls</span> <span class="special">==</span> <span class="number">4</span> <span class="special">);</span>
    <span class="keyword">const</span> <span class="identifier">bar</span><span class="special">*</span> <span class="identifier">foo_ref_2</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">)&gt;().</span><span class="identifier">target</span><span class="special">&lt;</span><span class="identifier">bar</span><span class="special">&gt;();</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">foo_ref_2</span><span class="special">-&gt;</span><span class="identifier">total_calls</span> <span class="special">==</span> <span class="number">4</span> <span class="special">);</span>


    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">report_errors</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_overload.advanced_features.boost_resultof_and_boost_lambda_support"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support" title="Boost.ResultOf and Boost.Lambda support">Boost.ResultOf
      and Boost.Lambda support</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_resultof_support">Example
        - Boost.ResultOf support</a></span></dt>
<dt><span class="section"><a href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_lambda_support">Example
        - Boost.Lambda support</a></span></dt>
</dl></div>
<p>
        <a class="link" href="../index.html" title="Boost.Overload 0.4.0">Boost.Overload</a> provides support for
        <a href="http://www.boost.org/doc/libs/release/libs/utility/utility.htm#result_of" target="_top">Boost.ResultOf</a>
        and <a href="http://www.boost.org/doc/libs/release/doc/html/lambda.html" target="_top">Boost.Lambda</a>
        result type deduction. The latter needs to be explicitly enabled by defines
        the macro <code class="computeroutput"><span class="identifier">BOOST_OVERLOAD_ENABLE_LAMBDA_SUPPORT</span></code>.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_resultof_support"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_resultof_support" title="Example - Boost.ResultOf support">Example
        - Boost.ResultOf support</a>
</h4></div></div></div>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">static_assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_traits</span><span class="special">/</span><span class="identifier">is_same</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">result_of</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">A</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">B</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">A</span> <span class="special">{};</span>


<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overload</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">),</span> <span class="keyword">char</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">),</span> <span class="keyword">double</span> <span class="special">(</span><span class="keyword">double</span> <span class="special">),</span> <span class="identifier">A</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="special">)&gt;</span>
        <span class="identifier">overload_type</span><span class="special">;</span>


<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">int</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">char</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="keyword">double</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">double</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="keyword">short</span> <span class="keyword">int</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">int</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="keyword">char</span><span class="special">&amp;</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">char</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">float</span><span class="special">&amp;</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">double</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="identifier">B</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="identifier">A</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">overload_type</span> <span class="special">(</span><span class="identifier">B</span><span class="special">&amp;</span> <span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="identifier">A</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>
</pre>
<p>
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_lambda_support"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.boost_resultof_and_boost_lambda_support.example___boost_lambda_support" title="Example - Boost.Lambda support">Example
        - Boost.Lambda support</a>
</h4></div></div></div>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">detail</span><span class="special">/</span><span class="identifier">lightweight_test</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">lambda</span><span class="special">/</span><span class="identifier">lambda</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">lambda</span><span class="special">/</span><span class="identifier">bind</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// You need to explicitly enable Boost.Lambda support</span>
<span class="preprocessor">#define</span> <span class="identifier">BOOST_OVERLOAD_ENABLE_LAMBDA_SUPPORT</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>


<span class="keyword">int</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">int</span> <span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">int</span> <span class="identifier">bar</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span> <span class="special">}</span>


<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lambda</span><span class="special">;</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overload</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">),</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">)&gt;</span> <span class="identifier">f</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">bar</span><span class="special">);</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">hello</span><span class="special">(</span><span class="string">"hello"</span><span class="special">);</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lambda</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span> <span class="number">10</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)(</span><span class="identifier">hello</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">f</span><span class="special">(</span><span class="number">10</span><span class="special">,</span> <span class="identifier">hello</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lambda</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span> <span class="number">10</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)(</span><span class="number">5</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">f</span><span class="special">(</span><span class="number">10</span><span class="special">,</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lambda</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">,</span> <span class="identifier">hello</span><span class="special">)(</span><span class="number">10</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">f</span><span class="special">(</span><span class="number">10</span><span class="special">,</span> <span class="identifier">hello</span><span class="special">)</span> <span class="special">);</span>

    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">report_errors</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
            <a href="http://www.boost.org/doc/libs/release/doc/html/lambda.html" target="_top">Boost.Lambda</a>
            result type deduction support does not work with MSVC 7.1 and with all
            Intel compilers prior to version 12.0
          </p></td></tr>
</table></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_overload.advanced_features.a_special_variant_of_the_set_signature__method"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.a_special_variant_of_the_set_signature__method" title="A special variant of the set&lt;Signature&gt; method">A
      special variant of the set&lt;Signature&gt; method</a>
</h3></div></div></div>
<p>
        When the explicit call signature of a member function supported by an overload
        object is the non-const qualified version (e.g. as <code class="computeroutput"><span class="keyword">int</span>
        <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">int</span> <span class="special">)</span></code>
        where <code class="computeroutput"><span class="identifier">bar</span></code> is of class type),
        you need a special variant of the call signature based syntax in order to
        manage the case of a class with two member function overloads that differ
        for the const qualifier only. This is exactly what happens in the next example:
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">detail</span><span class="special">/</span><span class="identifier">lightweight_test</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>


<span class="keyword">struct</span> <span class="identifier">bar</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">mf</span><span class="special">(</span><span class="keyword">int</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">mf</span><span class="special">(</span><span class="keyword">int</span> <span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">mf</span><span class="special">(</span><span class="keyword">double</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">3</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>


<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// overload object that supports the *non-const* qualified</span>
    <span class="comment">// explicit call signature int (bar*, int )</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overload</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">int</span> <span class="special">),</span> <span class="keyword">int</span> <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">double</span> <span class="special">)&gt;</span> <span class="identifier">f</span><span class="special">;</span>

    <span class="comment">// bar instance</span>
    <span class="identifier">bar</span> <span class="identifier">foo</span><span class="special">;</span>

    <span class="comment">// we set bar::*mf as object target</span>
    <span class="comment">// for the int (bar*, double ) call signature only</span>
    <span class="identifier">f</span><span class="special">.</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">double</span> <span class="special">)&gt;(&amp;</span><span class="identifier">bar</span><span class="special">::</span><span class="identifier">mf</span><span class="special">);</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="number">1.0</span><span class="special">)</span> <span class="special">==</span> <span class="number">3</span> <span class="special">);</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">empty</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">int</span> <span class="special">)&gt;()</span> <span class="special">);</span>

    <span class="comment">// if you try to compile the following line of code:</span>
    <span class="comment">// f.set&lt;int (bar*, int )&gt;(&amp;bar::mf);</span>
    <span class="comment">// you get a compiler error, because the call signature</span>
    <span class="comment">// syntax is not able to disambiguate between two member</span>
    <span class="comment">// functions that differ for the const qualifier only</span>


    <span class="comment">// in order to set a pointer to the non-const qualified</span>
    <span class="comment">// version of bar::mf as object target</span>
    <span class="comment">// for the int (bar*, int ) call signature of the overload</span>
    <span class="comment">// object f, you can utilize a special variant of</span>
    <span class="comment">// the call signature syntax</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overloads</span><span class="special">::</span><span class="identifier">non_const</span><span class="special">;</span>
    <span class="identifier">f</span><span class="special">.</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">int</span> <span class="special">),</span> <span class="identifier">non_const</span><span class="special">&gt;(&amp;</span><span class="identifier">bar</span><span class="special">::</span><span class="identifier">mf</span><span class="special">);</span>
    <span class="comment">// now foo.mf(int ) is invoked</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">1</span> <span class="special">);</span>

    <span class="comment">// what if I want to set a pointer to</span>
    <span class="comment">// the const qualified version of boost::mf as object</span>
    <span class="comment">// target for the int (bar*, int ) call signature of</span>
    <span class="comment">// the overload object f ?</span>

    <span class="comment">// first off, you should notice that the set up of such</span>
    <span class="comment">// a target is semantically correct because the explicit</span>
    <span class="comment">// call signature of the const qualified bar::mf function</span>
    <span class="comment">// member is int (const bar*, int ) and we can always pass</span>
    <span class="comment">// a T* argument where a const T* is expected.</span>

    <span class="comment">// as above you can utilize the special variant of the call</span>
    <span class="comment">// signature syntax</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overloads</span><span class="special">::</span><span class="identifier">const_</span><span class="special">;</span>
    <span class="identifier">f</span><span class="special">.</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">int</span> <span class="special">),</span> <span class="identifier">const_</span><span class="special">&gt;(&amp;</span><span class="identifier">bar</span><span class="special">::</span><span class="identifier">mf</span><span class="special">);</span>
    <span class="comment">// now foo.mf(int ) const is invoked</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">f</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>



    <span class="comment">// you should notice that in case we have an overload</span>
    <span class="comment">// object that supports the *const* qualified explicit call</span>
    <span class="comment">// signature int (const bar*, int )</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overload</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">int</span> <span class="special">),</span>
                    <span class="keyword">int</span> <span class="special">(</span><span class="identifier">bar</span><span class="special">*,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">)&gt;</span> <span class="identifier">g</span><span class="special">;</span>
    <span class="comment">// we can utilize the standard call signature based syntax</span>
    <span class="comment">// because selecting the const qualified version of the</span>
    <span class="comment">// bar::mf member function is the only semantically correct</span>
    <span class="comment">// choice</span>

    <span class="comment">// no compiler error here!</span>
    <span class="identifier">g</span><span class="special">.</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bar</span><span class="special">*,</span> <span class="keyword">int</span> <span class="special">)&gt;(&amp;</span><span class="identifier">bar</span><span class="special">::</span><span class="identifier">mf</span><span class="special">);</span>
    <span class="comment">// foo.mf(int ) const is invoked</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="identifier">g</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>

    <span class="comment">// and if you try to compile the following line of code:</span>
    <span class="comment">// g.set&lt;int (const bar*, int ), non_const&gt;(&amp;bar::mf);</span>
    <span class="comment">// you get a compiler error because you cannot pass a</span>
    <span class="comment">// const T* argument where a T* is expected</span>

    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">report_errors</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_overload.advanced_features.type_traits"></a><a class="link" href="advanced_features.html#boost_overload.advanced_features.type_traits" title="Type Traits">Type Traits</a>
</h3></div></div></div>
<p>
        For extracting type traits from a template class <a class="link" href="references.html#boost_overload.references.boost_overload_hpp.class_template_overload" title="Class template overload"><code class="computeroutput"><span class="identifier">overload</span></code></a> the following metafunctions
        are provided:
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Metafunction
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="references.html#ref_tt_extent">extent</a><span class="special">&lt;</span><span class="identifier">CallWrapperType</span><span class="special">&gt;::</span><span class="identifier">value</span></code>
                </p>
              </td>
<td>
                <p>
                  it provides the amount of signatures supported by a call wrapper
                  type
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="references.html#ref_tt_signature">signature</a><span class="special">&lt;</span><span class="identifier">CallWrapperType</span><span class="special">,</span> <span class="identifier">N</span>
                  <span class="special">=</span> <span class="number">0</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
              </td>
<td>
                <p>
                  it provides the N-th signature for a call wrapper type (indexing
                  start from zero)
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="references.html#ref_tt_function">function</a><span class="special">&lt;</span><span class="identifier">CallWrapperType</span><span class="special">,</span>
                  <span class="identifier">N</span> <span class="special">=</span>
                  <span class="number">0</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                </p>
              </td>
<td>
                <p>
                  it provides the type of the N-th boost::function embedded object
                  (indexing start from zero)
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="references.html#ref_tt_index_of_sig">index_of_signature</a><span class="special">&lt;</span><span class="identifier">CallWrapperType</span><span class="special">,</span> <span class="identifier">Signature</span><span class="special">&gt;::</span><span class="identifier">value</span></code>
                </p>
              </td>
<td>
                <p>
                  it provides the index of a signature, and returns -1 if it is not
                  found
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="references.html#ref_tt_has_signature">has_signature</a><span class="special">&lt;</span><span class="identifier">CallWrapperType</span><span class="special">,</span> <span class="identifier">Signature</span><span class="special">&gt;::</span><span class="identifier">value</span></code>
                </p>
              </td>
<td>
                <p>
                  utility to discover if a given signature is supported by a call
                  wrapper type
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="references.html#ref_tt_have_any_shared_sig">have_any_shared_signature</a><span class="special">&lt;</span><span class="identifier">CallWrapperType</span><span class="special">,</span> <span class="identifier">Functor</span><span class="special">&gt;::</span><span class="identifier">value</span></code>
                </p>
              </td>
<td>
                <p>
                  utility to discover if a given functor has a signature supported
                  by a call wrapper type
                </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        These metafunctions live in the namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">overloads</span></code>
        and work with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span></code> too.
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">detail</span><span class="special">/</span><span class="identifier">lightweight_test</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">static_assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_traits</span><span class="special">/</span><span class="identifier">is_same</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overloads</span><span class="special">;</span>
<span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">;</span>


<span class="keyword">int</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">long</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">typedef</span> <span class="keyword">int</span> <span class="special">(*</span><span class="identifier">foo_ptr</span><span class="special">)(</span><span class="keyword">long</span> <span class="special">);</span>

<span class="keyword">struct</span> <span class="identifier">bar</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">-</span><span class="number">1</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>


<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overload</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">),</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">),</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">double</span> <span class="special">)&gt;</span>
        <span class="identifier">overload_type</span><span class="special">;</span>


<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">extent</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="number">3</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">signature</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="number">0</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">int</span> <span class="special">(</span><span class="keyword">int</span> <span class="special">)</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="number">1</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">)&gt;</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overloads</span><span class="special">::</span><span class="identifier">index_of_signature</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">double</span> <span class="special">)&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="number">2</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">overloads</span><span class="special">::</span><span class="identifier">index_of_signature</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">float</span> <span class="special">)&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="special">-</span><span class="number">1</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">has_signature</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="keyword">int</span><span class="special">(</span> <span class="keyword">char</span><span class="special">)&gt;::</span><span class="identifier">value</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="special">!</span><span class="identifier">has_signature</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="keyword">int</span><span class="special">(</span> <span class="keyword">long</span><span class="special">)&gt;::</span><span class="identifier">value</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">have_any_shared_signature</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="identifier">bar</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="special">!</span><span class="identifier">have_any_shared_signature</span><span class="special">&lt;</span><span class="identifier">overload_type</span><span class="special">,</span> <span class="identifier">foo_ptr</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">));</span>



<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="keyword">double</span><span class="special">)&gt;</span> <span class="identifier">function_type</span><span class="special">;</span>


<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">extent</span><span class="special">&lt;</span><span class="identifier">function_type</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="number">1</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="identifier">signature</span><span class="special">&lt;</span><span class="identifier">function_type</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">int</span> <span class="special">(</span><span class="keyword">double</span> <span class="special">)</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">has_signature</span><span class="special">&lt;</span><span class="identifier">function_type</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">double</span> <span class="special">)&gt;::</span><span class="identifier">value</span> <span class="special">));</span>
<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="special">!</span><span class="identifier">has_signature</span><span class="special">&lt;</span><span class="identifier">function_type</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">(</span><span class="keyword">char</span> <span class="special">)&gt;::</span><span class="identifier">value</span> <span class="special">));</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="identifier">have_any_shared_signature</span><span class="special">&lt;</span><span class="identifier">function_type</span><span class="special">,</span> <span class="identifier">bar</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">));</span>
<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span> <span class="special">!</span><span class="identifier">have_any_shared_signature</span><span class="special">&lt;</span><span class="identifier">function_type</span><span class="special">,</span> <span class="identifier">foo_ptr</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">));</span>
</pre>
<p>
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007-2012 Marco Cecchetti, Dean Michael Berris<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="use_case.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="design_and_definitions.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
