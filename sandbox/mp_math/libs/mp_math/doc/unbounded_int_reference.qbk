[/ Copyright Kevin Sopp 2008 - 2009.
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at
 / http://www.boost.org/LICENSE_1_0.txt)]

[section unbounded_int reference]

[heading Synopsis]

  // <boost/mp_math/unbounded_int.hpp>
  namespace boost {
  namespace mp_math {

  template<
    class Allocator = std::allocator<void>,
    class Traits = unbounded_traits<>
  >
  struct unbounded_int
  {
    typedef multiprecision_integer_tag tag;

    typedef Alloc                              allocator_type;
    typedef Traits                             traits_type;
    typedef typename traits_type::digit_type   digit_type;
    typedef typename allocator_type::size_type size_type;

    typedef typename base_type::iterator               iterator;
    typedef typename base_type::const_iterator         const_iterator;
    typedef typename base_type::reverse_iterator       reverse_iterator;
    typedef typename base_type::const_reverse_iterator const_reverse_iterator;

      // ctor/cctor/dtor/assign
    unbounded_int();

    explicit unbounded_int(const allocator_type& a);

    template<typename IntegralT>
    unbounded_int(IntegralT,
           const allocator_type& a = allocator_type(),
           typename enable_if<is_integral<IntegralT> >::type* dummy = 0);

    template<typename charT>
    unbounded_int(const charT*, const allocator_type& a = allocator_type());

    template<typename charT>
    unbounded_int(const charT*,
                  std::ios_base::fmtflags,
                  const allocator_type& a = allocator_type());

    template<typename charT, class traits, class alloc>
    unbounded_int(const std::basic_string<charT,traits,alloc>&,
                  const allocator_type& a = allocator_type());

    template<typename charT, class traits, class alloc>
    unbounded_int(const std::basic_string<charT,traits,alloc>&,
                  std::ios_base::fmtflags,
                  const allocator_type& a = allocator_type());

    template<typename RandomAccessIterator>
    unbounded_int(RandomAccessIterator first,
                  RandomAccessIterator last,
                  const allocator_type& a = allocator_type());

    template<typename RandomAccessIterator>
    unbounded_int(RandomAccessIterator first,
                  RandomAccessIterator last,
                  std::ios_base::fmtflags f,
                  const allocator_type& a = allocator_type());

    template<class ApInt>
    unbounded_int(const ApInt& x,
                  typename enable_if<
                    mpl::and_<
                      mpl::not_<is_same<traits_type, typename ApInt::traits_type> >,
                      is_same<typename ApInt::tag, multiprecision_integer_tag>
                    >
                    >::type* dummy = 0);

    unbounded_int(const unbounded_int& copy);

    #ifndef BOOST_NO_RVALUE_REFERENCES
    unbounded_int(unbounded_int&& copy);
    #endif

    ~unbounded_int();

    unbounded_int& operator = (const unbounded_int& rhs);

    #ifndef BOOST_NO_RVALUE_REFERENCES
    unbounded_int& operator = (unbounded_int&& rhs);
    #endif

    template<typename IntegralT>
    typename enable_if<is_integral<IntegralT>, unbounded_int&>::type
    operator = (IntegralT rhs);

    template<typename charT>
    unbounded_int& operator = (const charT*);

    template<typename charT, class traits, class alloc>
    unbounded_int& operator = (const std::basic_string<charT,traits,alloc>&);

    template<typename charT>
    void assign(const charT*, std::ios_base::fmtflags);

    template<typename charT, class traits, class alloc>
    void assign(const std::basic_string<charT,traits,alloc>&,
                std::ios_base::fmtflags);

    template<typename RandomAccessIterator>
    void assign(RandomAccessIterator first, RandomAccessIterator last,
                std::ios_base::fmtflags);

    // modifiers
    void swap(unbounded_int& other);

    // increment/decrement
    unbounded_int& operator ++();
    unbounded_int& operator --();
    unbounded_int  operator ++(int);
    unbounded_int  operator --(int);

    // shifting
    unbounded_int& operator <<= (size_type);
    unbounded_int& operator >>= (size_type);

    // unary negate
    unbounded_int& operator - ();

    // arithmetic operators
    unbounded_int& operator += (const unbounded_int& x);
    unbounded_int& operator -= (const unbounded_int& x);
    unbounded_int& operator *= (const unbounded_int& x);
    unbounded_int& operator /= (const unbounded_int& x);
    unbounded_int& operator %= (const unbounded_int& x);

    // bitwise operators
    unbounded_int& operator |= (const unbounded_int& x);
    unbounded_int& operator &= (const unbounded_int& x);
    unbounded_int& operator ^= (const unbounded_int& x);

    // operators involving integral types
    template<typename IntegralT> unbounded_int& operator += (IntegralT x);
    template<typename IntegralT> unbounded_int& operator -= (IntegralT x);
    template<typename IntegralT> unbounded_int& operator *= (IntegralT x);
    template<typename IntegralT> unbounded_int& operator /= (IntegralT x);
    template<typename IntegralT> unbounded_int& operator %= (IntegralT x);
    template<typename IntegralT> unbounded_int& operator |= (IntegralT x);
    template<typename IntegralT> unbounded_int& operator &= (IntegralT x);
    template<typename IntegralT> unbounded_int& operator ^= (IntegralT x);

    // operators involving character strings
    template<typename charT> unbounded_int& operator += (const charT*);
    template<typename charT> unbounded_int& operator -= (const charT*);
    template<typename charT> unbounded_int& operator *= (const charT*);
    template<typename charT> unbounded_int& operator /= (const charT*);
    template<typename charT> unbounded_int& operator %= (const charT*);
    template<typename charT> unbounded_int& operator |= (const charT*);
    template<typename charT> unbounded_int& operator &= (const charT*);
    template<typename charT> unbounded_int& operator ^= (const charT*);

    // operators involving std::basic_string
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator += (const std::basic_string<charT,traits,Alloc>& s);
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator -= (const std::basic_string<charT,traits,Alloc>& s);
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator *= (const std::basic_string<charT,traits,Alloc>& s);
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator /= (const std::basic_string<charT,traits,Alloc>& s);
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator %= (const std::basic_string<charT,traits,Alloc>& s);
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator |= (const std::basic_string<charT,traits,Alloc>& s);
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator &= (const std::basic_string<charT,traits,Alloc>& s);
    template<typename charT, class traits, class Alloc>
    unbounded_int& operator ^= (const std::basic_string<charT,traits,Alloc>& s);

    // observers
    allocator_type get_allocator() const;

    bool is_even() const;
    bool is_odd () const;

    bool is_positive() const;
    bool is_negative() const;

    bool is_initialized  () const;
    bool is_uninitialized() const;

    size_type precision() const;

    #ifdef BOOST_NO_EXPLICIT_CONVERSION_OPERATORS
    operator unspecified_bool_type() const;
    #else
    explicit operator bool() const;
    #endif

    std::string to_string(std::ios_base::fmtflags f = std::ios_base::dec) const;

    template<typename IntegralT>
    IntegralT to_integral() const;

    // low level access
    digit_type&       operator[](size_type i);
    const digit_type& operator[](size_type i) const;

    digit_type&       at(size_type i);
    const digit_type& at(size_type i) const;

    void clamp();
    void clamp_high_digit();

    void set_bit   (size_type bit);
    void clear_bit (size_type bit);
    void set_bits  (size_type beg, size_type end);
    void clear_bits(size_type beg, size_type end);

    void truncate(size_type prec);

    size_type precision() const;
    void set_precision(size_type bits);

    size_type count_trailing_zero_bits() const;

    void print(bool all = false) const;
  };


  // non-member functions

  template<class A, class T>
  void swap(unbounded_int<A,T>&, unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator << (const unbounded_int<A,T>&, typename unbounded_int<A,T>::size_type);

  template<class A, class T>
  unbounded_int<A,T> operator >> (const unbounded_int<A,T>&, typename unbounded_int<A,T>::size_type);

  template<class A, class T>
  unbounded_int<A,T> operator - (const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator + (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator - (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator * (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator / (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator % (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator | (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator & (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator ^ (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator + (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator - (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator * (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator / (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator % (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator | (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator & (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator ^ (const unbounded_int<A,T>&, IntegralT);


  // Comparison operators

  template<class A, class T>
  bool operator == (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator != (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator < (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator > (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator <= (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator >= (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  // Comparison between unbounded_int and std::basic_string

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator == (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator != (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator < (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator > (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator <= (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator >= (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  // Comparison between std::basic_string and unbounded_int

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator == (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator != (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator < (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator > (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator <= (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator >= (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  // Comparison between unbounded_int and const charT*

  template<class A, class T>
  bool operator == (const unbounded_int<A,T>&, const charT*);

  template<class A, class T>
  bool operator != (const unbounded_int<A,T>&, const charT*);

  template<class A, class T>
  bool operator < (const unbounded_int<A,T>&, const charT*);

  template<class A, class T>
  bool operator > (const unbounded_int<A,T>&, const charT*);

  template<class A, class T>
  bool operator <= (const unbounded_int<A,T>&, const charT*);

  template<class A, class T>
  bool operator >= (const unbounded_int<A,T>&, const charT*);

  // Comparison between const charT* and unbounded_int

  template<class A, class T>
  bool operator == (const charT*, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator != (const charT*, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator < (const charT*, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator > (const charT*, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator <= (const charT*, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator >= (const charT*, const unbounded_int<A,T>&);

  // Comparison between unbounded_int and integral type

  template<class A, class T, typename IntegralT>
  bool operator == (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator != (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator < (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator > (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator <= (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator >= (const unbounded_int<A,T>&, IntegralT);

  // Comparison between integral type and unbounded_int

  template<class A, class T, typename IntegralT>
  bool operator == (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator != (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator < (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator > (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator <= (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator >= (IntegralT, const unbounded_int<A,T>&);


  // Stream I/O

  template<class A, class T, typename charT, class traits>
  std::basic_istream<charT, traits>&
  operator >> (std::basic_istream<charT, traits>& is, unbounded_int<A,T>& x);

  template<class A, class T, typename charT, class traits>
  std::basic_ostream<charT, traits>&
  operator << (std::basic_ostream<charT, traits>& os, const unbounded_int<A,T>& x);


  // Special functions

  template<class A, class T>
  unbounded_int<A,T> abs(const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> gcd(const unbounded_int<A,T>& a, const unbounded_int<A,T>& b);

  template<class A, class T>
  unbounded_int<A,T> lcm(const unbounded_int<A,T>& a, const unbounded_int<A,T>& b);

  template<class A, class T>
  int jacobi(const unbounded_int<A,T>& a, const unbounded_int<A,T>& p);

  template<class A, class T>
  unbounded_int<A,T> pow(const unbounded_int<A,T>& x, typename unbounded_int<A,T>::digit_type n);

  template<class A, class T>
  unbounded_int<A,T> pow(const unbounded_int<A,T>& x, const unbounded_int<A,T>& n);

  template<class A, class T>
  unbounded_int<A,T> modpow(const unbounded_int<A,T>& base, const unbounded_int<A,T>& exp, const unbounded_int<A,T>& mod);

  template<class A, class T>
  unbounded_int<A,T> sqrt(const unbounded_int<A,T>& x);

  template<class A, class T>
  unbounded_int<A,T> nth_root(const unbounded_int<A,T>& x, typename unbounded_int<A,T>::digit_type n);

  template<class A, class T>
  unbounded_int<A,T> nth_root(const unbounded_int<A,T>& x, const unbounded_int<A,T>& n);


  } // namespace mp_math
  } // namespace boost


[h3 Construction from / assignment to a string object]
In a constructor or assignment operation without the possibility to specify the base
of the string argument the base of the number is deduced from the string prefix.

* `0` - octal
* `0x`, `0X` - hexadecimal

An optional `-` sign is allowed as the first character in the string to indicate
a negative value.

In a constructor or assignment operation with the ability to specify the format
of the string argument via a `std::ios_base::fmtflags` parameter, possible
formatting flags are:

* `std::ios_base::showbase`
* `std::ios_base::dec`
* `std::ios_base::hex`
* `std::ios_base::oct`


[heading Construct/Copy/Destroy/Assign]

  unbounded_int();

* [*Effects:] Constructs an empty `unbounded_int` object, such an uninitialized
`unbounded_int` has no value, i.e. it is /not/ zero.
* [*Complexity:] O(1).
* [*Throws:] Nothing.


  explicit unbounded_int(const allocator_type& a);

* [*Effects:] Constructs an empty `unbounded_int` object and initializes its allocator
with `a`, such an uninitialized `unbounded_int` has no value, i.e. it is /not/ zero.
* [*Complexity:] O(1).
* [*Throws:] Nothing.


  template<typename IntegralT>
  unbounded_int(IntegralT x,
         const allocator_type& a = allocator_type(),
         typename enable_if<is_integral<IntegralT> >::type* dummy = 0);

* [*Effects:] Constructs an `unbounded_int` object from an integral type. The value of
the object is that of the integral type.
* [*Complexity:] O(N) where N is the number of bits of IntegralT.
* [*Throws: ] `std::bad_alloc`.


  template<typename charT>
  unbounded_int(const charT* s, const allocator_type& a = allocator_type());

* [*Requires: ] `s` points to a valid number formatted as string or to an empty
string.
* [*Effects:] Constructs an `unbounded_int` object from a string.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.


  template<typename charT>
  unbounded_int(const charT* s,
         std::ios_base::fmtflags f,
         const allocator_type& a = allocator_type());

* [*Requires: ] `s` points to a valid number formatted according to the flags in
`f` or `s` is an empty string.
* [*Effects:] Constructs an `unbounded_int` object from a string.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character or if an
    unrecognized formatting flag was set.


  template<typename charT, class traits, class Alloc>
  unbounded_int(const std::basic_string<charT,traits,Alloc>& s,
         const allocator_type& a = allocator_type());

* [*Requires: ] `s` contains a valid number formatted as string or `s` is an
empty string.
* [*Effects:] Constructs an `unbounded_int` object from a string.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.


  template<typename charT, class traits, class Alloc>
  unbounded_int(const std::basic_string<charT,traits,Alloc>& s,
         std::ios_base::fmtflags f,
         const allocator_type& a = allocator_type());

* [*Requires: ] `s` contains a valid number formatted according to the flags in
`f` or `s` is an empty string.
* [*Effects:] Constructs an `unbounded_int` object from a string.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character or if an
    unrecognized formatting flag was set.


  template<typename RandomAccessIterator>
  unbounded_int(RandomAccessIterator first,
         RandomAccessIterator last,
         const allocator_type& a = allocator_type());

* [*Requires: ] `first` and `last` are iterators into a string.
* [*Effects:] Constructs an `unbounded_int` object from two iterators.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.


  template<typename RandomAccessIterator>
  unbounded_int(RandomAccessIterator first,
         RandomAccessIterator last,
         std::ios_base::fmtflags f,
         const allocator_type& a = allocator_type());

* [*Requires: ] `first` and `last` are iterators into a string formatted
according to the formatting flags in `f`.
* [*Effects:] Constructs an `unbounded_int` object from two iterators.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character or if an
    unrecognized formatting flag was set.


  unbounded_int(const unbounded_int& copy);

* [*Effects:] Constructs a copy of a given `unbounded_int`.
* [*Complexity:] O(N), where N is the number of digits in `copy`.
* [*Throws: ] `std::bad_alloc`.


  unbounded_int(unbounded_int&& copy);

* [*Effects:] Constructs an `unbounded_int` by moving `copy` into `*this`.
* [*Complexity:] O(1).
* [*Throws:] Nothing.


  ~unbounded_int();

* [*Effects:] Destroys `*this`.
* [*Complexity:] O(1).
* [*Throws:] Nothing.


  unbounded_int& operator = (const unbounded_int& rhs);

* [*Effects:] Copies the value of `rhs` into `*this`.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int& operator = (unbounded_int&& rhs);

* [*Effects: ] `*this` obtains the value of `rhs`.
* [*Returns: ] `*this`.
* [*Complexity:] O(1).
* [*Throws:] Nothing.


  template<typename IntegralT>
  unbounded_int& operator = (IntegralT rhs);

* [*Effects: ] `*this` obtains the value of `rhs`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] basic.


  template<typename charT>
  unbounded_int& operator = (const charT* s);

* [*Requires: ] `s` points to a valid number formatted as string or to an empty
string.
* [*Effects:] `*this = unbounded_int(s);`.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.
* [*Exception safety:] basic.


  template<typename charT, class traits, class Alloc>
  unbounded_int& operator = (const std::basic_string<charT,traits,Alloc>& s);

* [*Requires: ] `s` points to a valid number formatted as string or to an empty
string.
* [*Effects:] `*this = unbounded_int(s);`.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.
* [*Exception safety:] basic.


  template<typename charT>
  void assign(const charT* s, std::ios_base::fmtflags);

* [*Requires: ] `s` points to a valid number formatted according to the flags in
`f` or `s` is an empty string.
* [*Effects:] Constructs an `unbounded_int` object from a string.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character or if an
    unrecognized formatting flag was set.
* [*Exception safety:] basic.


  template<typename charT, class traits, class Alloc>
  void assign(const std::basic_string<charT,traits,Alloc>& s, std::ios_base::fmtflags f);

* [*Requires: ] `s` contains a valid number formatted according to the flags in
`f` or `s` is an empty string.
* [*Effects:] Constructs an `unbounded_int` object from a string.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character or if an
    unrecognized formatting flag was set.
* [*Exception safety:] basic.


  template<typename RandomAccessIterator>
  void assign(RandomAccessIterator first, RandomAccessIterator last, std::ios_base::fmtflags f);

* [*Requires: ] `first` and `last` are iterators into a string formatted
according to the formatting flags in `f`.
* [*Effects:] Constructs an `unbounded_int` object from two iterators.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character or if an
    unrecognized formatting flag was set.
* [*Exception safety:] basic.


[heading Modifiers]

  void swap(unbounded_int&& other);

* [*Effects:] Swaps the value of `other` and `*this`.
* [*Complexity:] O(1).
* [*Exception safety:] nothrow.


  void swap(unbounded_int& other);

* [*Effects:] Swaps the value of `other` and `*this`.
* [*Complexity:] O(1).
* [*Exception safety:] nothrow.


[heading Increment/decrement]

  unbounded_int& operator ++();

* [*Effects:]
``
*this += 1;
return *this;
``
* [*Returns: ] `*this`.
* [*Complexity:] best case is O(1), worst case is O(N) - this happens when the
addition causes a carry bit to ripple through all digits subsequently.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int& operator --();

* [*Effects:]
``
*this -= 1;
return *this;
``
* [*Returns: ] `*this`.
* [*Complexity:] best case is O(1), worst case is O(N) - this happens when the
subtraction causes a borrow bit to ripple through all digits subsequently.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int  operator ++(int);

* [*Effects:]
``
unbounded_int tmp(*this);
*this += 1;
return tmp;
``
* [*Returns:] The value of `*this` before incrementation.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int  operator --(int);

* [*Effects:]
``
unbounded_int tmp(*this);
*this -= 1;
return tmp;
``
* [*Returns:] The value of `*this` before decrementation.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


[heading Shifting]

 unbounded_int& operator <<= (size_type x);

* [*Effects:] Shift `*this` by `x` bits to the left.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


 unbounded_int& operator >>= (size_type x);

* [*Effects:] Shift `*this` by `x` bits to the right.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


[heading Unary negate]

  unbounded_int& operator - ();

* [*Effects:] Negates `*this`.
* [*Returns: ] `*this`.
* [*Complexity:] O(1).
* [*Exception safety:] nothrow.


[heading Arithmetic operators]

  unbounded_int& operator += (const unbounded_int& x);

* [*Effects:] Adds `x` to `*this`.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int& operator -= (const unbounded_int& x);


* [*Effects:] Subtracts `x` from `*this`.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int& operator *= (const unbounded_int& x);

* [*Effects:] Multiplies `*this` by `x`.
* [*Returns: ] `*this`.
* [*Complexity:] If `&x == this` then a squaring algorithm will be used.
Different multiplication algorithms are chosen for numbers of different size.
The thresholds can be tuned via the `unbounded_int_traits` class template parameter.
  * Small numbers: Comba algorithm O(N^2).
  * Midsize numbers: Karatsuba algorithm O(N^log2(3)) ~ O(N^1.585).
  * Large numbers: Toom-Cook algorithm O(N^(log(5)/log(3))) ~ O(N^1.465).

* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


 unbounded_int& operator /= (const unbounded_int& x);

* [*Requires: ] `x != 0`.
* [*Effects:] Divides `*this` by `x`.
* [*Returns: ] `*this`.
* [*Throws: ]
  * `std::bad_alloc`
  * `std::domain_error` if `x == 0`.

* [*Exception safety:] strong.


 unbounded_int& operator %= (const unbounded_int& x);

* [*Requires: ] `x != 0`.
* [*Effects:] Modulus `*this` by `x`.
* [*Returns: ] `*this`.
* [*Throws: ]
  * `std::bad_alloc`
  * `std::domain_error` if `x == 0`.

* [*Exception safety:] strong.


[heading Bitwise operators]

  unbounded_int& operator |= (const unbounded_int& x);

* [*Effects: ] `*this` OR `x`.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int& operator &= (const unbounded_int& x);

* [*Effects: ] `*this` AND `x`.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  unbounded_int& operator ^= (const unbounded_int& x);

* [*Effects: ] `*this` XOR `x`.
* [*Returns: ] `*this`.
* [*Complexity:] O(N).
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


[heading Operators involving integral types]

  template<typename IntegralT> unbounded_int& operator += (IntegralT x);

* [*Effects:] Adds `x` to `*this`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT> unbounded_int& operator -= (IntegralT x);

* [*Effects:] Subtracts `x` to `*this`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT> unbounded_int& operator *= (IntegralT x);

* [*Effects:] Multiplies `*this` by `x`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT> unbounded_int& operator /= (IntegralT x);

* [*Effects:] Divides `*this` by `x`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT> unbounded_int& operator %= (IntegralT x);

* [*Effects: ] `*this` modulo `x`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT> unbounded_int& operator |= (IntegralT x);

* [*Effects:] Applies the bitwise or operation on `*this` and the absolute of `x`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT> unbounded_int& operator &= (IntegralT x);

* [*Effects:] Applies the bitwise and operation on `*this` and the absolute of `x`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT> unbounded_int& operator ^= (IntegralT x);

* [*Effects:] Applies the bitwise xor operation on `*this` and the absolute of `x`.
* [*Returns: ] `*this`.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


[heading Operators involving charT strings]

  template<typename charT> unbounded_int& operator += (const charT* s);
  template<typename charT> unbounded_int& operator -= (const charT* s);
  template<typename charT> unbounded_int& operator *= (const charT* s);
  template<typename charT> unbounded_int& operator /= (const charT* s);
  template<typename charT> unbounded_int& operator %= (const charT* s);
  template<typename charT> unbounded_int& operator |= (const charT* s);
  template<typename charT> unbounded_int& operator &= (const charT* s);
  template<typename charT> unbounded_int& operator ^= (const charT* s);

[heading Operators involving std::basic_string]

  template<typename charT, class traits, class Alloc>
  unbounded_int& operator += (const std::basic_string<charT,traits,Alloc>& s);
  template<typename charT, class traits, class Alloc>
  unbounded_int& operator -= (const std::basic_string<charT,traits,Alloc>& s);
  template<typename charT, class traits, class Alloc>
  unbounded_int& operator *= (const std::basic_string<charT,traits,Alloc>& s);
  template<typename charT, class traits, class Alloc>
  unbounded_int& operator /= (const std::basic_string<charT,traits,Alloc>& s);
  template<typename charT, class traits, class Alloc>
  unbounded_int& operator %= (const std::basic_string<charT,traits,Alloc>& s);
  template<typename charT, class traits, class Alloc>
  unbounded_int& operator |= (const std::basic_string<charT,traits,Alloc>& s);
  template<typename charT, class traits, class Alloc>
  unbounded_int& operator &= (const std::basic_string<charT,traits,Alloc>& s);
  template<typename charT, class traits, class Alloc>
  unbounded_int& operator ^= (const std::basic_string<charT,traits,Alloc>& s);


[heading Observers]

  allocator_type get_allocator() const;

* [*Returns: ] A copy of the allocator.
* [*Complexity:] O(1).
* [*Throws:] Nothing if allocator copy constructor is nothrow.


  bool is_even() const;

* [*Complexity:] O(1).
* [*Throws:] Nothing.


  bool is_odd () const;

* [*Complexity:] O(1).
* [*Throws:] Nothing.


  bool is_positive() const;

* [*Complexity:] O(1).
* [*Throws:] Nothing.


  bool is_negative() const;

* [*Complexity:] O(1).
* [*Throws:] Nothing.


  size_type precision() const;

* [*Returns:] The number of bits used by the absolute value of *this.
* [*Complexity:] O(N).
* [*Throws:] Nothing.

  operator unspecified_bool_type() const;

* [*Returns: ] `*this != 0`.
* [*Complexity:] O(1).
* [*Throws:] Nothing.


  std::string to_string(std::ios_base::fmtflags f = std::ios_base::dec) const;

* [*Effects:] Converts `*this` to a `std::string`, formatting of the string is
done according to the `std::ios_base::fmtflags` parameter. Possible formatting
flags are:
  * `std::ios_base::showpos`
  * `std::ios_base::showbase`
  * `std::ios_base::dec`
  * `std::ios_base::hex`
  * `std::ios_base::oct`
  * `std::ios_base::uppercase`

* [*Returns: ] `*this` converted to a `std::string` object.
* [*Throws: ] `std::bad_alloc`.
* [*Exception safety:] strong.


  template<typename IntegralT>
  IntegralT to_integral() const;

* [*Returns: ] `*this` converted to an object of type `IntegralT`.
* [*Complexity:] O(1).
* [*Throws: ] `std::overflow_error` if `IntegralT` does not have enough
precision to hold the result.
* [*Exception safety:] strong.



[heading Non-member functions]

  template<class A, class T>
  void swap(unbounded_int<A,T>&&, unbounded_int<A,T>&&);

  template<class A, class T>
  unbounded_int<A,T> operator << (const unbounded_int<A,T>&, typename unbounded_int<A,T>::size_type);

  template<class A, class T>
  unbounded_int<A,T> operator >> (const unbounded_int<A,T>&, typename unbounded_int<A,T>::size_type);

  template<class A, class T>
  unbounded_int<A,T> operator - (const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator + (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator - (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator * (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator / (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator % (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator | (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator & (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  unbounded_int<A,T> operator ^ (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator + (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator - (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator * (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator / (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator % (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator | (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator & (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  unbounded_int<A,T> operator ^ (const unbounded_int<A,T>&, IntegralT);

These functions are implemented in terms of their respective member functions.


[heading Comparison operators]

  template<class A, class T>
  bool operator == (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator != (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator < (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator > (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator <= (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

  template<class A, class T>
  bool operator >= (const unbounded_int<A,T>&, const unbounded_int<A,T>&);

* [*Effects:] These operators compare the numeric value of their arguments and
return a truth value based on that evaluation.
* [*Throws:] Nothing.


  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator == (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator != (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator < (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator > (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator <= (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator >= (const unbounded_int<A,T>&, const std::basic_string<charT,Traits,Alloc>&);

* [*Effects:] Converts the string argument to an `unbounded_int` object and compares it
to the object on the left side of the expression.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.


  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator == (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator != (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator < (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator > (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator <= (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

  template<class A, class T, class charT, class Traits, class Alloc>
  bool operator >= (const std::basic_string<charT,Traits,Alloc>&, const unbounded_int<A,T>&);

* [*Effects:] Converts the string argument to an `unbounded_int` object and compares it
to the object on the right side of the expression.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.


  template<class A, class T, typename charT>
  bool operator == (const unbounded_int<A,T>&, const charT*);

  template<class A, class T, typename charT>
  bool operator != (const unbounded_int<A,T>&, const charT*);

  template<class A, class T, typename charT>
  bool operator < (const unbounded_int<A,T>&, const charT*);

  template<class A, class T, typename charT>
  bool operator > (const unbounded_int<A,T>&, const charT*);

  template<class A, class T, typename charT>
  bool operator <= (const unbounded_int<A,T>&, const charT*);

  template<class A, class T, typename charT>
  bool operator >= (const unbounded_int<A,T>&, const charT*);

* [*Effects:] Converts the string argument to an `unbounded_int` object and compares it
to the object on the left side of the expression.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.


  template<class A, class T, typename charT>
  bool operator == (const charT*, const unbounded_int<A,T>&);

  template<class A, class T, typename charT>
  bool operator != (const charT*, const unbounded_int<A,T>&);

  template<class A, class T, typename charT>
  bool operator < (const charT*, const unbounded_int<A,T>&);

  template<class A, class T, typename charT>
  bool operator > (const charT*, const unbounded_int<A,T>&);

  template<class A, class T, typename charT>
  bool operator <= (const charT*, const unbounded_int<A,T>&);

  template<class A, class T, typename charT>
  bool operator >= (const charT*, const unbounded_int<A,T>&);

* [*Effects:] Converts the string argument to an `unbounded_int` object and compares it
to the object on the right side of the expression.
* [*Throws:]
  * `std::bad_alloc`
  * `std::invalid_argument` if the string contains an invalid character.


  template<class A, class T, typename IntegralT>
  bool operator == (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator != (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator < (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator > (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator <= (const unbounded_int<A,T>&, IntegralT);

  template<class A, class T, typename IntegralT>
  bool operator >= (const unbounded_int<A,T>&, IntegralT);

* [*Effects:] Converts the integral argument to an `unbounded_int` object and compares it
to the object on the left side of the expression.
* [*Throws: ] `std::bad_alloc`.


  template<class A, class T, typename IntegralT>
  bool operator == (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator != (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator < (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator > (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator <= (IntegralT, const unbounded_int<A,T>&);

  template<class A, class T, typename IntegralT>
  bool operator >= (IntegralT, const unbounded_int<A,T>&);

* [*Effects:] Converts the integral argument to an `unbounded_int` object and compares it
to the object on the right side of the expression.
* [*Throws: ] `std::bad_alloc`.


[heading Stream I/O]

  template<class A, class T, typename charT, class traits>
  std::basic_istream<charT, traits>&
  operator >> (std::basic_istream<charT, traits>& is, unbounded_int<A,T>& x);

  template<class A, class T, typename charT, class traits>
  std::basic_ostream<charT, traits>&
  operator << (std::basic_ostream<charT, traits>& os, const unbounded_int<A,T>& x);


[heading Special functions]

  template<class A, class T>
  unbounded_int<A,T> abs(const unbounded_int<A,T>& x);

* [*Returns:] The positive value of `x`.
* [*Complexity:] O(1).
* [*Throws: ] `std::bad_alloc`.


  template<class A, class T>
  unbounded_int<A,T> gcd(const unbounded_int<A,T>& a, const unbounded_int<A,T>& b);

* [*Returns:] The greatest common divisor of `a` and `b`.
* [*Complexity:] O((log2(AB))^2).
* [*Throws: ] `std::bad_alloc`.


  template<class A, class T>
  unbounded_int<A,T> lcm(const unbounded_int<A,T>& a, const unbounded_int<A,T>& b);

* [*Returns:] The least common multiple of `a` and `b`.
* [*Complexity:] O((log2(AB))^2).
* [*Throws: ] `std::bad_alloc`.


  template<class A, class T>
  int jacobi(const unbounded_int<A,T>& a, const unbounded_int<A,T>& p);

* [*Returns:] The Jacobi symbol of integer `a` and positive odd integer `p`.
* [*Throws:]
  * `std::bad_alloc`
  * `std::domain_error` if `p` is negative.


  template<class A, class T>
  unbounded_int<A,T> pow(const unbounded_int<A,T>& x, typename unbounded_int<A,T>::digit_type n);

  template<class A, class T>
  unbounded_int<A,T> pow(const unbounded_int<A,T>& x, const unbounded_int<A,T>& n);

* [*Returns:] The `n`th power of `x`.
* [*Throws: ] `std::bad_alloc`.


  template<class A, class T>
  unbounded_int<A,T> modpow(const unbounded_int<A,T>& base,
                     const unbounded_int<A,T>& exp,
                     const unbounded_int<A,T>& mod);


* [*Returns: ] `(base ^ exp) % mod`.
* [*Throws: ] `std::bad_alloc`.


  template<class A, class T>
  unbounded_int<A,T> sqrt(const unbounded_int<A,T>& x);

* [*Returns:] The square root of `x`.
* [*Throws:]
  * `std::bad_alloc`
  * `std::domain_error` if `x` is negative.


  template<class A, class T>
  unbounded_int<A,T> nth_root(const unbounded_int<A,T>& x, typename unbounded_int<A,T>::digit_type n);

  template<class A, class T>
  unbounded_int<A,T> nth_root(const unbounded_int<A,T>& x, const unbounded_int<A,T>& n);

* [*Returns:] The `n`th root of `x`.
* [*Complexity:] O(log(N)).
* [*Throws:]
  * `std::bad_alloc`
  * `std::domain_error` if `x` is negative and `n` is odd.


[endsect][/unbounded_int reference]

