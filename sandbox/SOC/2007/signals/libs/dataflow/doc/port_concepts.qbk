[section PortCategory]

A [PortCategoryConcept] designates a category of port in the Dataflow library.
The library currently defines two [PortCategoryConcept]s:

 * `boost::dataflow::ports::producer`, and
 * `boost::dataflow::ports::consumer`

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[PT] [A [PortCategoryConcept] type.]]
]

[heading Requirements]

[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Opposite PortCategory]
        [`PT::complement`]
        [[PortCategoryConcept] type]
        [
            The complementing [PortCategoryConcept] of `PT`, meaning that connections
            can be made between [PortCategoryConcept]s of [PortCategoryConcept] `PT` and
            [PortConcept]s of [PortCategoryConcept] `PT::complement`.
        ]
    ]
]

[heading Header]

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[endsect][/portcategory]

[section PortTraits]

A ['[PortTraitsConcept]] specifies the traits of a [PortConcept].

[heading Notation]
[variablelist
    [[PC] [A PortTraits type.]]
    [[P] [A [PortConcept] type of producer category `PC`.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Mechanism]
        [`PC::mechanism`]
        [any type]
        [[MechanismConcept] type tag.]
    ]
    [
        [Port Category]
        [`PC::port_category`]
        [[PortCategoryConcept] type]
        [The category of the port]
    ]
    [
        [Port Concept]
        [`PC::port_concept`]
        [`concepts::port`, `concepts::keyed_port`]
        [The most refined producer concept that `P` satisfies.]
    ]
]

[heading Header]

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Notes]

[heading Examples]

[endsect][/producertraits]


[section:port Port (ProducerPort, ConsumerPort)]

A type `P` is a ['[PortConcept]] for a mechanism `M` and port category `PC`
if it specifies a [PortTraitsConcept] for that mechanism and port category.

In that case,

* If `PC` is `ports::producer`, then `P` is a `ProducerPort`
* If `PC` If `ports::consumer`, then `P` is a `ConsumerPort`

[heading Refinements]
* [SingleTypePort]
* [PhoenixPortConcept]

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[P] [A Port type.]]
    [[M] [A [MechanismConcept] type.]]
    [[PC] [A [PortCategoryConcept] type.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Port Traits]
        [`port_traits_of<M, PC, P>::type`
         [footnote `namespace boost::dataflow`]]
        [Any [PortTraitsConcept] type]
        [
            The [PortTraitsConcept] of the port.
        ]
    ]
    [
        [IsPort Trait]
        [`is_port<M, PC, P>::type`
         [footnote `namespace boost::dataflow`]]
        [Boolean metafunction that evaluates to true]
        [
            A trait encapsulating adherence to the Port
            concept.
        ]
    ]
]

[heading Header]

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Notes]

To specify that a type `P` is a [PortConcept],
it suffices to provide a specialization of `port_traits_of`.
This can either be done explicitly, or intrusively by providing
a `P::port_traits` member type specifying the
[PortTraitsConcept].  `P::port_traits` can either be a [PortTraitsConcept]
type, or an MPL sequence of [PortTraitsConcept] types.

The Dataflow library provides a convenience class
`port` which you can inherit instead of declaring the member type.

[heading Examples]

[endsect][/port]

[section ProxyPortTraits]
[endsect][/proxyporttraits]

[section ProxyPort]

A type `PP` is a ['[ProxyPortConcept]] if specifies the proxied producer
type, and if objects of the proxied type can be retreived from objects of
[ProxyPortConcept] type.  If the proxied producer type is a valid
[PortConcept], then 'PP' satisfies the [PortConcept] requirements
in the same way.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[PP] [A ProxyPort type.]]
    [[pp] [An object of type `PP`]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Proxy Port Category]
        [`proxy_producer_category_of<PP>::type`
         [footnote `namespace boost::dataflow`]]
        [Any type]
        [
            The category of the proxy producer, used for tag forwarding.
        ]
    ]
    [
        [Proxied Port Type]
        [`proxied_producer_of<PP>::type`
         [footnote `namespace boost::dataflow`]]
        [Any type]
        [
            The proxied producer type.
        ]
    ]
    [
        [Proxied Port]
        [`get_proxied_producer(pp)`
         [footnote `namespace boost::dataflow`]]
        []
        [
            Retrieves a reference to the proxied producer object.
        ]
    ]
]

[heading Header]

```
    #include <boost/dataflow/support/proxy_port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Notes]

To define a new [ProxyPortConcept] class type, it is sufficient to define
member typedefs `proxy_producer_category` and `proxy_producer_for`,
and member function `get_proxied_producer`.

[heading Examples]

[endsect][/proxyport]

[section PortMap]
[endsect][/port_map]