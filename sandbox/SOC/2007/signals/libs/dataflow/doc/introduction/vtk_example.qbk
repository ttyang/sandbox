[section:new_layer Implementing support for a new mechanism (VTK)]

This example shows how to implement support for a particular mechanism.
Our victim is [VTK], a 3D visualization toolkit, which uses a data pipeline
to move data from a source to the display (with possible transformations,
scene construction etc. on the way).  For example, here is an excerpt from
a VTK tutorial that sets up a whole source->render window pipeline:

```
    // allocate components
    vtkConeSource *cone = vtkConeSource::New();
    vtkPolyDataMapper *coneMapper = vtkPolyDataMapper::New();
    vtkActor *coneActor = vtkActor::New();
    vtkRenderer *ren1= vtkRenderer::New();
    vtkRenderWindow *renWin = vtkRenderWindow::New();

    // make the connections
    coneMapper->SetInputConnection( cone->GetOutputPort() );
    coneActor->SetMapper( coneMapper );
    ren1->AddActor( coneActor );
    renWin->AddRenderer( ren1 );
```

Our goal will be to simplify the connection-making code by providing
Dataflow support for VTK.  With that in place, we will be able to use the
following connection code:

```
    // make the connections
    connect(cone, coneMapper);
    connect(coneMapper, coneActor);
    connect(coneActor, ren1);
    connect(ren1, renWin);
```

or even more concisely and clearly,

```
    // make the connections
    // C++ rules prevent us from removing all of the pointer dereferencing here
    *cone >>= *coneMapper >>= *coneActor >>= *ren1 >>= *renWin;
```

[note Going through the following pages, you might think that implementing a VTK
support layer is a whole lot of effort for very little benefit.  Please keep the
following in mind:

* The support layer needs to be implemented only once (per mechanism).  Since
  this example takes care of [VTK], to get the
  benefits of the Dataflow library (which are admitedly few at the moment)
  all you need to do is include the provided header.

* Once more things are implemented on top of the generic Dataflow layer, having
  Dataflow library support will be more beneficial.
]

[heading Next]
[link dataflow.introduction.examples.new_layer.mechanism
    Setting up the Mechanism]

[section:mechanism Setting up the Mechanism]

The first thing we'll do is create a tag for the VTK [MechanismConcept], in
namespace `boost::dataflow::vtk`.  Since there are currently no requirements
for a [MechanismConcept], this is as simple as declaring a new type to be used
as the mechanism tag:

[vtk_mechanism]

We will now use this tag in reference to the [VTK] dataflow mechanism.

[heading Next]
[link dataflow.introduction.examples.new_layer.producerconsumer
    Setting up a ProducerPort and ConsumerPort] 
[endsect][/mechanism]

[section:producerconsumer Setting up a ProducerPort and ConsumerPort]

Now that we have the mechanism, let's cover the basic data pipeline,
which is implemented using the
[vtkAlgorithm] class.  This class provides input and output ports. Output ports
are accessible via `GetOuptutPort` member functions, which return a proxy
object ([vtkAlgorithmOutput] `*`) for an actual output port.

In Dataflow concepts, [vtkAlgorithmOutput] can be made a [ProducerPortConcept]
- it corresponds to a single data output point. We support it as such by
defining a [PortTraitsConcept] type, and associating it with
[vtkAlgorithmOutput]:

[vtk_algorithm_output_producer]

[note More details about registering [PortTraitsConcept] for a [PortConcept]
can be found on the [PortConcept] documentation page.]

Now that we have a [ProducerPortConcept], we need a [ConsumerPortConcept].
[vtkAlgorithm] can accept incoming connections using the `AddInputConnection`
and `SetInputConnection` member functions.  The code below provides support
for [vtkAlgorithm] accepting connections on its default input port:

[vtk_algorithm_consumer]

[heading Next]

[link dataflow.introduction.examples.new_layer.connectable
    Making things Connectable] 

[endsect][/producerconsumer]

[section:connectable Making things Connectable]

With the pair of [ProducerPortConcept] and [ConsumerPortConcept] registered, we
can make them [ConnectableConcept] and/or [OnlyConnectableConcept].
All we need to do is specialize the implementation for the appropriate
[PortTraitsConcept]:

[vtk_connect_impl_algorithm]

Connections are done through the `boost::dataflow::binary_operation` function
with either `operation::connect` or `operation::connect_only` operation tag,
and the specified mechanism. In the next step, we'll set up forwarding functions
and operators that will make connections easier.

[heading What we can do with what we have so far]

```
    // connect *cone to *coneMapper
    boost::dataflow::binary_operation<
        boost::dataflow::operation::connect,
        boost::dataflow::vtk::mechanism>
        (*cone->GetOutputPort(), *coneMapper);
    
    // make *cone the only thing connected to *coneMapper
    boost::dataflow::binary_operation<
        boost::dataflow::operation::connect_only,
        boost::dataflow::vtk::mechanism>
        (*cone->GetOutputPort(), *coneMapper);
    
```

[heading Next]
[link dataflow.introduction.examples.new_layer.forwarding
    Defining forwarding functions and operators] 

[endsect][/connectable]

[section:forwarding Defining forwarding functions and operators]

To make connecting
easier, we'll add forwarding connect and connect_only
functions in the global namespace (where vtk classes live) specific
to the vtk mechanism. The Dataflow library provides inlcude file templates
for this purpose.

Including `<boost/dataflow/templates/binary_operation.hpp>` with `#define`d
DATAFLOW_TEMPLATE_MECHANISM and DATAFLOW_TEMPLATE_BINARY_OPERATION will
define a forwarding function DATAFLOW_TEMPLATE_BINARY_OPERATION in the
current namespace.

Including `<boost/dataflow/templates/operator.hpp>`  with `#define`d
DATAFLOW_TEMPLATE_MECHANISM, DATAFLOW_TEMPLATE_BINARY_OPERATION, and
DATAFLOW_TEMPLATE_OPERATOR will define a forwarding operator in the current
namespace.

[vtk_specialize_connect]

[heading What we can do with what we have so far]

```
    // connect *cone to *coneMapper
    connect(*cone->GetOutputPort(), *coneMapper);
    // or
    *cone->GetOutputPort() >>= *coneMapper
    
    // make *cone the only thing connected to *coneMapper
    connect_only(*cone->GetOutputPort(), *coneMapper);
    // or
    *cone->GetOutputPort() ^= *coneMapper
    
```

[heading Next]
[link dataflow.introduction.examples.new_layer.proxyproducer
    Setting up a ProxyProducer] 

[endsect][/forwarding]

[section:proxyproducer Setting up a ProxyPort]

In the VTK example above, both `vtkConeSource` and `vtkPolyDataMapper`
inherit [vtkAlgorithm].  
With the [vtkAlgorithmOutput] [ProducerPortConcept] and
[vtkAlgorithm] [ConsumerPortConcept] we've set up,
we can do things like `connect(cone->GetOutputPort(), *coneMapper);`.
However, we would like to do `connect(*cone, *coneMapper)`.

To do that,
we need to make [vtkAlgorithm] a [ProducerPortConcept]. Since [vtkAlgorithm]
forms its output connections using [vtkAlgorithmOutput] objects
returned through the `GetOutputPort` member functions, and we've already
configured [vtkAlgorithmOutput] as a [ProducerPortConcept], we can make use
of the [ProxyPortConcept] concept provided by the dataflow library.
In effect, we will make [vtkAlgorithm] delegate it's [ProducerPortConcept]
functionality to [vtkAlgorithmOutput]:

[vtk_algorithm_proxy_producer]

Now, [vtkAlgorithm] is a [ProducerPortConcept].

[heading What we can do with what we have so far]

```
    connect(*cone, *coneMapper)
```

[heading Next]
[link dataflow.introduction.examples.new_layer.filter
    Setting up a filter (ProducerPort+ConsumerPort)] 

[endsect][/proxyproducer]

[section:filter Setting up a Filter (Producer+Consumer)]

In a VTK pipeline, a [vtkActor] consumes data from a [vtkMapper], and produces
data for a [vtkRenderer].  In this case, we can provide Dataflow support
for a [vtkActor] as both a [ProducerPortConcept] and a [ConsumerPortConcept]:

[vtk_actor_filter]

[heading Next]
[link dataflow.introduction.examples.new_layer.producermap
    Setting up a KeyedPort] 

[endsect][/filter]

[section:producermap Setting up a KeyedPort]

Sometimes, components can produce (or consume) multiple types of data.
For example, [vtkMapper] objects can produce data for [vtkActor] objects,
or (since [vtkMapper] inherits [vtkAlgorithm]) for other [vtkAlgorithm]
objects.  Correspondingly, connecting a [vtkMapper] to a [vtkActor] is not
the same as connecting a [vtkMapper] to another [vtkAlgorithm].

To accomodate such situations, the Dataflow library provides
[KeyedPortConcept]s, which are similar to [ProxyPortConcept]s but
the [PortConcept] they delegate to is keyed on the 
[PortConcept] they are being connected to.

[vtk_mapper_producer]

[heading Next]
[link dataflow.introduction.examples.new_layer.remaining
    Setting up the remaining components (more of the same)] 

[endsect][/producermap]

[section:remaining Setting up the remaining components (more of the same)]

[vtk_setup_rest]

[heading Next]
[link dataflow.introduction.examples.new_layer.pointers
    Supporting pointers] 

[endsect][/remaining]

[section:pointers Supporting pointers]

All of the concepts we adapted so far have been adapted for class types such
as [vtkAlgorithm] and [vtkAlgorithmOutput].  But [VTK] seems to exclusively
use pointers to class types rather than class types themselves.  So, with what
we have done so far, we can do `connect(*cone, *coneMapper)` but not
`connect(cone, coneMapper)`.  To provide support for pointers, we
simply make them adhere to the [ProxyPortConcept] concept, and delegate the
functionality to the object they point to.

[vtk_support_pointer]

[heading Next]
[link dataflow.introduction.examples.new_layer.using_support_layer
    Using the VTK support layer] 

[endsect][/pointers]

[section:using_support_layer Using the VTK support layer]

Now that we have developed a support layer for VTK, what do we get?

Well, at the moment, one of the largest practical benefits is a small
improvement to the connection syntax.  Here is a full VTK example which
has been modified to use the Dataflow library for making connections:

[vtk_example_Cone_cxx]

[endsect]

[endsect][/new_layer]
