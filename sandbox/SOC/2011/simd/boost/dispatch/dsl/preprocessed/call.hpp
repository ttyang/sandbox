namespace boost { namespace dispatch { namespace meta
{
  } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0> inline typename boost::enable_if < any< boost::proto::is_expr<boost::mpl::_> , A0 > , boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > >::type dispatching( Func, tag::formal_ , unspecified_<A0> const , adl_helper = adl_helper() ) { boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > that; return that; } } } } namespace boost { namespace dispatch { namespace meta { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1> inline typename boost::enable_if < any< boost::proto::is_expr<boost::mpl::_> , A0 , A1 > , boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > >::type dispatching( Func, tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , adl_helper = adl_helper() ) { boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > that; return that; } } } } namespace boost { namespace dispatch { namespace meta { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2> inline typename boost::enable_if < any< boost::proto::is_expr<boost::mpl::_> , A0 , A1 , A2 > , boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > >::type dispatching( Func, tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , unspecified_<A2> const , adl_helper = adl_helper() ) { boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > that; return that; } } } } namespace boost { namespace dispatch { namespace meta { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> inline typename boost::enable_if < any< boost::proto::is_expr<boost::mpl::_> , A0 , A1 , A2 , A3 > , boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > >::type dispatching( Func, tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , unspecified_<A2> const , unspecified_<A3> const , adl_helper = adl_helper() ) { boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > that; return that; } } } } namespace boost { namespace dispatch { namespace meta { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3 , class A4> inline typename boost::enable_if < any< boost::proto::is_expr<boost::mpl::_> , A0 , A1 , A2 , A3 , A4 > , boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > >::type dispatching( Func, tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , unspecified_<A2> const , unspecified_<A3> const , unspecified_<A4> const , adl_helper = adl_helper() ) { boost :: dispatch :: meta :: implement<Func(tag::ast_), tag::formal_ > that; return that; } } } } namespace boost { namespace dispatch { namespace meta {
  template<class Func,class Dummy>
  struct implement<Func(tag::ast_),tag::formal_,Dummy>
  {
    template<class Sig> struct result;
    template<class This,class A0> struct result<This(A0)> { typedef typename boost::proto::result_of:: make_expr < Func , boost::proto::deduce_domain , typename as_ref<A0 >::type >::type type; }; template<class A0> inline typename result<implement (A0 & a0) >::type operator()(A0 & a0) const { return boost::proto::detail:: make_expr_< Func , boost::proto:: deduce_domain , A0 & >()( a0 ); } template<class This,class A0 , class A1> struct result<This(A0 , A1)> { typedef typename boost::proto::result_of:: make_expr < Func , boost::proto::deduce_domain , typename as_ref<A0 >::type , typename as_ref<A1 >::type >::type type; }; template<class A0 , class A1> inline typename result<implement (A0 & a0 , A1 & a1) >::type operator()(A0 & a0 , A1 & a1) const { return boost::proto::detail:: make_expr_< Func , boost::proto:: deduce_domain , A0 & , A1 & >()( a0 , a1 ); } template<class This,class A0 , class A1 , class A2> struct result<This(A0 , A1 , A2)> { typedef typename boost::proto::result_of:: make_expr < Func , boost::proto::deduce_domain , typename as_ref<A0 >::type , typename as_ref<A1 >::type , typename as_ref<A2 >::type >::type type; }; template<class A0 , class A1 , class A2> inline typename result<implement (A0 & a0 , A1 & a1 , A2 & a2) >::type operator()(A0 & a0 , A1 & a1 , A2 & a2) const { return boost::proto::detail:: make_expr_< Func , boost::proto:: deduce_domain , A0 & , A1 & , A2 & >()( a0 , a1 , a2 ); } template<class This,class A0 , class A1 , class A2 , class A3> struct result<This(A0 , A1 , A2 , A3)> { typedef typename boost::proto::result_of:: make_expr < Func , boost::proto::deduce_domain , typename as_ref<A0 >::type , typename as_ref<A1 >::type , typename as_ref<A2 >::type , typename as_ref<A3 >::type >::type type; }; template<class A0 , class A1 , class A2 , class A3> inline typename result<implement (A0 & a0 , A1 & a1 , A2 & a2 , A3 & a3) >::type operator()(A0 & a0 , A1 & a1 , A2 & a2 , A3 & a3) const { return boost::proto::detail:: make_expr_< Func , boost::proto:: deduce_domain , A0 & , A1 & , A2 & , A3 & >()( a0 , a1 , a2 , a3 ); } template<class This,class A0 , class A1 , class A2 , class A3 , class A4> struct result<This(A0 , A1 , A2 , A3 , A4)> { typedef typename boost::proto::result_of:: make_expr < Func , boost::proto::deduce_domain , typename as_ref<A0 >::type , typename as_ref<A1 >::type , typename as_ref<A2 >::type , typename as_ref<A3 >::type , typename as_ref<A4 >::type >::type type; }; template<class A0 , class A1 , class A2 , class A3 , class A4> inline typename result<implement (A0 & a0 , A1 & a1 , A2 & a2 , A3 & a3 , A4 & a4) >::type operator()(A0 & a0 , A1 & a1 , A2 & a2 , A3 & a3 , A4 & a4) const { return boost::proto::detail:: make_expr_< Func , boost::proto:: deduce_domain , A0 & , A1 & , A2 & , A3 & , A4 & >()( a0 , a1 , a2 , a3 , a4 ); }
  };
} } }
