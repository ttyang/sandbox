namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type64_ <A0>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type64_ <A0>, boost::simd::tag::sse_ > const& , simd_< type64_ <A1>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type64_ <A0>, boost::simd::tag::sse_ > const& , simd_< type64_ <A1>, boost::simd::tag::sse_ > const& , simd_< type64_ <A2>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > , simd_< type64_ <A3>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type64_ <A0>, boost::simd::tag::sse_ > const& , simd_< type64_ <A1>, boost::simd::tag::sse_ > const& , simd_< type64_ <A2>, boost::simd::tag::sse_ > const& , simd_< type64_ <A3>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > , simd_< type64_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > , simd_< type64_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > , simd_< type64_ <A3>, boost::simd::tag::sse_ > , simd_< type64_ <A4>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type64_ <A0>, boost::simd::tag::sse_ > const& , simd_< type64_ <A1>, boost::simd::tag::sse_ > const& , simd_< type64_ <A2>, boost::simd::tag::sse_ > const& , simd_< type64_ <A3>, boost::simd::tag::sse_ > const& , simd_< type64_ <A4>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > , simd_< type64_ <A3>, boost::simd::tag::sse_ > , simd_< type64_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type64_ <A0>, boost::simd::tag::sse_ > , simd_< type64_ <A1>, boost::simd::tag::sse_ > , simd_< type64_ <A2>, boost::simd::tag::sse_ > , simd_< type64_ <A3>, boost::simd::tag::sse_ > , simd_< type64_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3) , fusion::at_c< 0>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3) , fusion::at_c< 1>(a4))) ); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type32_ <A0>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type32_ <A0>, boost::simd::tag::sse_ > const& , simd_< type32_ <A1>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type32_ <A0>, boost::simd::tag::sse_ > const& , simd_< type32_ <A1>, boost::simd::tag::sse_ > const& , simd_< type32_ <A2>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > , simd_< type32_ <A3>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type32_ <A0>, boost::simd::tag::sse_ > const& , simd_< type32_ <A1>, boost::simd::tag::sse_ > const& , simd_< type32_ <A2>, boost::simd::tag::sse_ > const& , simd_< type32_ <A3>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > , simd_< type32_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > , simd_< type32_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2) , fusion::at_c< 2>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2) , fusion::at_c< 3>(a3))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > , simd_< type32_ <A3>, boost::simd::tag::sse_ > , simd_< type32_ <A4>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type32_ <A0>, boost::simd::tag::sse_ > const& , simd_< type32_ <A1>, boost::simd::tag::sse_ > const& , simd_< type32_ <A2>, boost::simd::tag::sse_ > const& , simd_< type32_ <A3>, boost::simd::tag::sse_ > const& , simd_< type32_ <A4>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > , simd_< type32_ <A3>, boost::simd::tag::sse_ > , simd_< type32_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type32_ <A0>, boost::simd::tag::sse_ > , simd_< type32_ <A1>, boost::simd::tag::sse_ > , simd_< type32_ <A2>, boost::simd::tag::sse_ > , simd_< type32_ <A3>, boost::simd::tag::sse_ > , simd_< type32_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3) , fusion::at_c< 0>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3) , fusion::at_c< 1>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2) , fusion::at_c< 2>(a3) , fusion::at_c< 2>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2) , fusion::at_c< 3>(a3) , fusion::at_c< 3>(a4))) ); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type16_ <A0>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type16_ <A0>, boost::simd::tag::sse_ > const& , simd_< type16_ <A1>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type16_ <A0>, boost::simd::tag::sse_ > const& , simd_< type16_ <A1>, boost::simd::tag::sse_ > const& , simd_< type16_ <A2>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1) , fusion::at_c< 4>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1) , fusion::at_c< 5>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1) , fusion::at_c< 6>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1) , fusion::at_c< 7>(a2))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > , simd_< type16_ <A3>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type16_ <A0>, boost::simd::tag::sse_ > const& , simd_< type16_ <A1>, boost::simd::tag::sse_ > const& , simd_< type16_ <A2>, boost::simd::tag::sse_ > const& , simd_< type16_ <A3>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > , simd_< type16_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > , simd_< type16_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2) , fusion::at_c< 2>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2) , fusion::at_c< 3>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1) , fusion::at_c< 4>(a2) , fusion::at_c< 4>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1) , fusion::at_c< 5>(a2) , fusion::at_c< 5>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1) , fusion::at_c< 6>(a2) , fusion::at_c< 6>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1) , fusion::at_c< 7>(a2) , fusion::at_c< 7>(a3))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > , simd_< type16_ <A3>, boost::simd::tag::sse_ > , simd_< type16_ <A4>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type16_ <A0>, boost::simd::tag::sse_ > const& , simd_< type16_ <A1>, boost::simd::tag::sse_ > const& , simd_< type16_ <A2>, boost::simd::tag::sse_ > const& , simd_< type16_ <A3>, boost::simd::tag::sse_ > const& , simd_< type16_ <A4>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > , simd_< type16_ <A3>, boost::simd::tag::sse_ > , simd_< type16_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type16_ <A0>, boost::simd::tag::sse_ > , simd_< type16_ <A1>, boost::simd::tag::sse_ > , simd_< type16_ <A2>, boost::simd::tag::sse_ > , simd_< type16_ <A3>, boost::simd::tag::sse_ > , simd_< type16_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3) , fusion::at_c< 0>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3) , fusion::at_c< 1>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2) , fusion::at_c< 2>(a3) , fusion::at_c< 2>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2) , fusion::at_c< 3>(a3) , fusion::at_c< 3>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1) , fusion::at_c< 4>(a2) , fusion::at_c< 4>(a3) , fusion::at_c< 4>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1) , fusion::at_c< 5>(a2) , fusion::at_c< 5>(a3) , fusion::at_c< 5>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1) , fusion::at_c< 6>(a2) , fusion::at_c< 6>(a3) , fusion::at_c< 6>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1) , fusion::at_c< 7>(a2) , fusion::at_c< 7>(a3) , fusion::at_c< 7>(a4))) ); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type8_ <A0>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 8>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 9>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 10>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 11>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 12>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 13>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 14>(a0))) , details::maybe_genmask<stype>(f(fusion::at_c< 15>(a0))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type8_ <A0>, boost::simd::tag::sse_ > const& , simd_< type8_ <A1>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 8>(a0) , fusion::at_c< 8>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 9>(a0) , fusion::at_c< 9>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 10>(a0) , fusion::at_c< 10>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 11>(a0) , fusion::at_c< 11>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 12>(a0) , fusion::at_c< 12>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 13>(a0) , fusion::at_c< 13>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 14>(a0) , fusion::at_c< 14>(a1))) , details::maybe_genmask<stype>(f(fusion::at_c< 15>(a0) , fusion::at_c< 15>(a1))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type8_ <A0>, boost::simd::tag::sse_ > const& , simd_< type8_ <A1>, boost::simd::tag::sse_ > const& , simd_< type8_ <A2>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1) , fusion::at_c< 4>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1) , fusion::at_c< 5>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1) , fusion::at_c< 6>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1) , fusion::at_c< 7>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 8>(a0) , fusion::at_c< 8>(a1) , fusion::at_c< 8>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 9>(a0) , fusion::at_c< 9>(a1) , fusion::at_c< 9>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 10>(a0) , fusion::at_c< 10>(a1) , fusion::at_c< 10>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 11>(a0) , fusion::at_c< 11>(a1) , fusion::at_c< 11>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 12>(a0) , fusion::at_c< 12>(a1) , fusion::at_c< 12>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 13>(a0) , fusion::at_c< 13>(a1) , fusion::at_c< 13>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 14>(a0) , fusion::at_c< 14>(a1) , fusion::at_c< 14>(a2))) , details::maybe_genmask<stype>(f(fusion::at_c< 15>(a0) , fusion::at_c< 15>(a1) , fusion::at_c< 15>(a2))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > , simd_< type8_ <A3>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type8_ <A0>, boost::simd::tag::sse_ > const& , simd_< type8_ <A1>, boost::simd::tag::sse_ > const& , simd_< type8_ <A2>, boost::simd::tag::sse_ > const& , simd_< type8_ <A3>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > , simd_< type8_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > , simd_< type8_ <A3>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2) , fusion::at_c< 2>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2) , fusion::at_c< 3>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1) , fusion::at_c< 4>(a2) , fusion::at_c< 4>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1) , fusion::at_c< 5>(a2) , fusion::at_c< 5>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1) , fusion::at_c< 6>(a2) , fusion::at_c< 6>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1) , fusion::at_c< 7>(a2) , fusion::at_c< 7>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 8>(a0) , fusion::at_c< 8>(a1) , fusion::at_c< 8>(a2) , fusion::at_c< 8>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 9>(a0) , fusion::at_c< 9>(a1) , fusion::at_c< 9>(a2) , fusion::at_c< 9>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 10>(a0) , fusion::at_c< 10>(a1) , fusion::at_c< 10>(a2) , fusion::at_c< 10>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 11>(a0) , fusion::at_c< 11>(a1) , fusion::at_c< 11>(a2) , fusion::at_c< 11>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 12>(a0) , fusion::at_c< 12>(a1) , fusion::at_c< 12>(a2) , fusion::at_c< 12>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 13>(a0) , fusion::at_c< 13>(a1) , fusion::at_c< 13>(a2) , fusion::at_c< 13>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 14>(a0) , fusion::at_c< 14>(a1) , fusion::at_c< 14>(a2) , fusion::at_c< 14>(a3))) , details::maybe_genmask<stype>(f(fusion::at_c< 15>(a0) , fusion::at_c< 15>(a1) , fusion::at_c< 15>(a2) , fusion::at_c< 15>(a3))) ); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > , simd_< type8_ <A3>, boost::simd::tag::sse_ > , simd_< type8_ <A4>, boost::simd::tag::sse_ >) , boost::simd::tag::sse2_ > dispatching( boost::simd::tag::map_ const&, boost::simd::tag::sse2_ const& , unspecified_<Func> const& , simd_< type8_ <A0>, boost::simd::tag::sse_ > const& , simd_< type8_ <A1>, boost::simd::tag::sse_ > const& , simd_< type8_ <A2>, boost::simd::tag::sse_ > const& , simd_< type8_ <A3>, boost::simd::tag::sse_ > const& , simd_< type8_ <A4>, boost::simd::tag::sse_ > const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > , simd_< type8_ <A3>, boost::simd::tag::sse_ > , simd_< type8_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(unspecified_<Func> , simd_< type8_ <A0>, boost::simd::tag::sse_ > , simd_< type8_ <A1>, boost::simd::tag::sse_ > , simd_< type8_ <A2>, boost::simd::tag::sse_ > , simd_< type8_ <A3>, boost::simd::tag::sse_ > , simd_< type8_ <A4>, boost::simd::tag::sse_ > ) , boost::simd::tag::sse2_ , Dummy > { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) { return make<result_type>( details::maybe_genmask<stype>(f(fusion::at_c< 0>(a0) , fusion::at_c< 0>(a1) , fusion::at_c< 0>(a2) , fusion::at_c< 0>(a3) , fusion::at_c< 0>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 1>(a0) , fusion::at_c< 1>(a1) , fusion::at_c< 1>(a2) , fusion::at_c< 1>(a3) , fusion::at_c< 1>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 2>(a0) , fusion::at_c< 2>(a1) , fusion::at_c< 2>(a2) , fusion::at_c< 2>(a3) , fusion::at_c< 2>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 3>(a0) , fusion::at_c< 3>(a1) , fusion::at_c< 3>(a2) , fusion::at_c< 3>(a3) , fusion::at_c< 3>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 4>(a0) , fusion::at_c< 4>(a1) , fusion::at_c< 4>(a2) , fusion::at_c< 4>(a3) , fusion::at_c< 4>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 5>(a0) , fusion::at_c< 5>(a1) , fusion::at_c< 5>(a2) , fusion::at_c< 5>(a3) , fusion::at_c< 5>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 6>(a0) , fusion::at_c< 6>(a1) , fusion::at_c< 6>(a2) , fusion::at_c< 6>(a3) , fusion::at_c< 6>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 7>(a0) , fusion::at_c< 7>(a1) , fusion::at_c< 7>(a2) , fusion::at_c< 7>(a3) , fusion::at_c< 7>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 8>(a0) , fusion::at_c< 8>(a1) , fusion::at_c< 8>(a2) , fusion::at_c< 8>(a3) , fusion::at_c< 8>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 9>(a0) , fusion::at_c< 9>(a1) , fusion::at_c< 9>(a2) , fusion::at_c< 9>(a3) , fusion::at_c< 9>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 10>(a0) , fusion::at_c< 10>(a1) , fusion::at_c< 10>(a2) , fusion::at_c< 10>(a3) , fusion::at_c< 10>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 11>(a0) , fusion::at_c< 11>(a1) , fusion::at_c< 11>(a2) , fusion::at_c< 11>(a3) , fusion::at_c< 11>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 12>(a0) , fusion::at_c< 12>(a1) , fusion::at_c< 12>(a2) , fusion::at_c< 12>(a3) , fusion::at_c< 12>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 13>(a0) , fusion::at_c< 13>(a1) , fusion::at_c< 13>(a2) , fusion::at_c< 13>(a3) , fusion::at_c< 13>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 14>(a0) , fusion::at_c< 14>(a1) , fusion::at_c< 14>(a2) , fusion::at_c< 14>(a3) , fusion::at_c< 14>(a4))) , details::maybe_genmask<stype>(f(fusion::at_c< 15>(a0) , fusion::at_c< 15>(a1) , fusion::at_c< 15>(a2) , fusion::at_c< 15>(a3) , fusion::at_c< 15>(a4))) ); } }; } } }
