<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Motivation</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../dispatch.html" title="Chapter&#160;1.&#160;Dispatch">
<link rel="prev" href="../dispatch.html" title="Chapter&#160;1.&#160;Dispatch">
<link rel="next" href="defining_hierarchies.html" title="Defining hierarchies">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../dispatch.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../dispatch.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="defining_hierarchies.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="dispatch.motivation"></a><a class="link" href="motivation.html" title="Motivation">Motivation</a>
</h2></div></div></div>
<p>
      Let us consider a fairly artificial scenario, but representive of things that
      are quite common in generic programming: we want to define a unary function
      <code class="computeroutput"><span class="identifier">f</span></code>, for all built-in arithmetic
      types, that returns different values depending on the actual type of the argument.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          return 0 if it is floating point
        </li>
<li class="listitem">
          return 1 if it is a signed integer
        </li>
<li class="listitem">
          return 2 if it is an unsigned integer
        </li>
</ul></div>
<p>
      You could do this with two means: SFINAE or tag dispatching.
    </p>
<p>
      With SFINAE:
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">enable_if</span><span class="special">&lt;</span>
    <span class="identifier">is_floating_point</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span>
    <span class="keyword">int</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">enable_if</span><span class="special">&lt;</span>
    <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">and_</span><span class="special">&lt;</span>
        <span class="identifier">is_signed</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span>
        <span class="identifier">is_integral</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
    <span class="special">&gt;,</span>
    <span class="keyword">int</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">enable_if</span><span class="special">&lt;</span>
    <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">and_</span><span class="special">&lt;</span>
        <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span> <span class="identifier">is_signed</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
        <span class="identifier">is_integral</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
    <span class="special">&gt;,</span>
    <span class="keyword">int</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<p>
      Or, with tag dispatching:
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">fundamental_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">floating_point_tag</span> <span class="special">:</span> <span class="identifier">fundamental_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">integral_tag</span> <span class="special">:</span> <span class="identifier">fundamental_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">signed_integral_tag</span> <span class="special">:</span> <span class="identifier">integral_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">unsigned_integral_tag</span> <span class="special">:</span> <span class="identifier">integral_tag</span> <span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">category_of</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">category_of</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">floating_point_tag</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">category_of</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">floating_point_tag</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">category_of</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">signed_integral_tag</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">category_of</span><span class="special">&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">unsigned_integral_tag</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">/* etc. for all fundamental types... */</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">t</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">category_of</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">floating_point_tag</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">integral_tag</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">unsigned_integral_tag</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<p>
      The SFINAE approach clearly doesn't scale in terms of programming, since all
      overloads must be mutually exclusive, but also in terms of compilation times,
      since SFINAE-based overload resolution is linear.
    </p>
<p>
      Tag dispatching, on the other hand, can be very good: by using a hierarchy
      of inheriting types, it's possible to make use of the best-match feature of
      C++ overloading to introduce specializations without requiring them to be mutually
      exclusive. The <code class="computeroutput"><span class="identifier">iterator_category</span></code>
      system of standard iterators is a good example of that. <br> Doing this in
      a clean, concise, reusable and idiomatic manner is however of some difficulty,
      which is why that is only done in an ad-hoc way in practice.
    </p>
<p>
      Boost.Dispatch solves that problem through two related components:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          An extensible hierarchy system that contains ready-made hierarchies and
          that can be easily extended. This provides a powerful and idiomatic way
          to define inheriting category tags.
        </li>
<li class="listitem">
          A dispatching mechanism built on top of the hierarchies and overloading,
          that automates the use of tag dispatching with all arguments.
        </li>
</ul></div>
<p>
      Here is what the above looks like when written with Boost.Dispatch:
    </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// each function must have a type to be uniquely identified</span>
<span class="keyword">struct</span> <span class="identifier">f_</span> <span class="special">{};</span>

<span class="comment">// we define the free function f, that for now only does a static assert</span>
<span class="identifier">BOOST_DISPATCH_FUNCTION_IMPLEMENTATION</span><span class="special">(</span><span class="identifier">f_</span><span class="special">,</span> <span class="identifier">f</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span>

<span class="comment">// we define a specialization for real types</span>
<span class="identifier">BOOST_DISPATCH_FUNCTOR_IMPLEMENTATION</span><span class="special">(,</span>
    <span class="identifier">f_</span><span class="special">,</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">cpu_</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">A0</span><span class="special">),</span>
    <span class="special">(</span><span class="identifier">scalar_</span><span class="special">&lt;</span> <span class="identifier">floating_</span><span class="special">&lt;</span><span class="identifier">A0</span><span class="special">&gt;</span> <span class="special">&gt;)</span>
<span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// we define a specialization for integral types</span>
<span class="identifier">BOOST_DISPATCH_FUNCTOR_IMPLEMENTATION</span><span class="special">(,</span>
    <span class="identifier">f_</span><span class="special">,</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">cpu_</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">A0</span><span class="special">),</span>
    <span class="special">(</span><span class="identifier">scalar_</span><span class="special">&lt;</span> <span class="identifier">integer_</span><span class="special">&lt;</span><span class="identifier">A0</span><span class="special">&gt;</span> <span class="special">&gt;)</span>
<span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// we define a specialization for unsigned types</span>
<span class="identifier">BOOST_DISPATCH_FUNCTOR_IMPLEMENTATION</span><span class="special">(,</span>
    <span class="identifier">f_</span><span class="special">,</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">cpu_</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">A0</span><span class="special">),</span>
    <span class="special">(</span><span class="identifier">scalar_</span><span class="special">&lt;</span> <span class="identifier">unsigned_</span><span class="special">&lt;</span><span class="identifier">A0</span><span class="special">&gt;</span> <span class="special">&gt;)</span>
<span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
    </p>
<p>
      Here, the second specialization applies to any integral type, including unsigned
      ones. However, since there is also a specialization for unsigned types, the
      latter gets preferred, since <code class="computeroutput"><span class="identifier">unsigned_</span></code>
      is a refinement of <code class="computeroutput"><span class="identifier">integer_</span></code>
      in the built-in hierarchies.
    </p>
<p>
      Additionally, with Boost.Dispatch, all specializations are registered in an
      ADL context. That means that you can introduce specializations after the function
      is used in template contexts and those new specializations will still get used
      when that code is instantiated. This is not the case with regular function
      overloads, which usually perform name lookup eagerly.
    </p>
<p>
      The approach also turns all incriminated functions into polymorphic function
      objects, which has a lot of uses in generic and functional programming.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2003-2011 LASMEA
      UMR 6602 CNRS/Univ. Clermont II<br>Copyright &#169; 2009-2011 LRI UMR 8623
      CNRS/Univ Paris Sud XI<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../dispatch.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../dispatch.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="defining_hierarchies.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
