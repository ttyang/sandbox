
[library Boost.Utility/IdentityType
    [quickbook 1.5]
    [version 1.0.0]
    [copyright 2009-2012 Lorenzo Caminiti]
    [purpose wraps types with round parenthesis]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or a copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [Caminiti <email>lorcaminiti@gmail.com</email>, Lorenzo]]
    [category Utilities]
]

This library allows to wrap type expressions within round parenthesis so they can be passed as macro parameters even if they contain commas.

[import ../test/var_err.cpp]
[import ../test/var_ok.cpp]

[section Introduction]

Consider the following macro which declares a variable named `var_`/postfix/ with the specified /type/:

[test_var_err]

The first macro invocation works correctly declaring a variable name `var_a` of type `int`.
However, the second macro invocation fails generating a preprocessor error similar to the following:

[pre
    error: macro "VAR" passed 3 arguments, but takes just 2
]

That is because the `std::map` type passed as the first macro parameter contains a comma `,` not wrapped by round parenthesis `()`.
The preprocessor interprets that unwrapped comma as separation between macro parameters concluding that a of three (and not two) parameters are passed to the macro in the following order:

# `std::map<char`
# `int>`
# `2`

Note that, differently from the compiler, the preprocessor only recognizes round parameters `()`.
Therefore angular `<>` or squared `[]` parenthesis are not detected by the preprocessor (as shown by the example above) when parsing the macro parameters.

This library defines a macro [macroref BOOST_IDENTITY_TYPE] which can be used to workaround this issue:

[test_var_ok]

This macro works on any __CPP03__ compilers (it does not require __variadic_macro__ support)

[endsect]

[section Tutorial]

The macro defined by this library allows to pass type expressions that contain unwrapped commas as a single macro parameter.
For example (see also [@../../../test/var_ok.cpp =var_ok.cpp=]):

[test_var_ok]

This macro expands to an expression that evaluates (at compile-time) to the specified type.
The specified type is never split into multiple macro parameters because it must be always wrapped by a set of extra round parenthesis `()` (for a total of two set of round parenthesis: The parenthesis to invoke the macro `BOOST_IDENTITY_TYPE(...)` plus the parenthesis to wrap the type `BOOST_IDENTITY_TYPE((...))`).

This macro works on any __CPP03__ compiler and it does not require __variadic_macro__ support.
Using variadic macros, it would be possible to use a single set of parenthesis `()` instead of two `(())` but variadic macros are not part of the __CPP03__ (even if nowadays they are supported by most modern compilers and also part of __CPP11__).

[section Templates]

This macro must be prefixed by `typename` when used within templates:

[test_var_tpl]

[endsect]

[section Abstract Types]

On some compilers (e.g., GCC), using this macro on abstract types (classes with one or more pure virtual function) generates a compiler error.
This can be worked around by manipulating the type adding and removing a reference to it:

[test_var_abstract]

[endsect]

[endsect]

[xinclude reference.xml]

