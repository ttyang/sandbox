<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Macro BOOST_IDENTITY_TYPE</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Chapter&#160;1.&#160;Boost.Utility/IdentityType 1.0.0">
<link rel="up" href="reference.html#header.boost.utility.identity_type_hpp" title="Header &lt;boost/utility/identity_type.hpp&gt;">
<link rel="prev" href="reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="reference.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="reference.html#header.boost.utility.identity_type_hpp"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a>
</div>
<div class="refentry">
<a name="BOOST_IDENTITY_TYPE"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Macro BOOST_IDENTITY_TYPE</span></h2>
<p>BOOST_IDENTITY_TYPE &#8212; This macro wraps the specified type expression within extra parenthesis so the type can be passed as a single macro parameter even if it contains commas (not already wrapped within round parenthesis). </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="comment">// In header: &lt;<a class="link" href="reference.html#header.boost.utility.identity_type_hpp" title="Header &lt;boost/utility/identity_type.hpp&gt;">boost/utility/identity_type.hpp</a>&gt;

</span>BOOST_IDENTITY_TYPE(parenthesized_type)</pre></div>
<div class="refsect1">
<a name="id779697"></a><h2>Description</h2>
<p>This macro expands to an expression that can be passed as a single macro parameter even if it contains commas and that evaluates to the specified type at compile-time (see the {Advanced_Topics, Advanced Topics} section).</p>
<p>For example <code class="computeroutput">BOOST_IDENTITY_TYPE((std::map&lt;int, double&gt;))</code> can be passed as a single macro parameter when instead <code class="computeroutput">std::map&lt;int, double&gt;</code> cannot (because <code class="computeroutput">std::map&lt;int, double&gt;</code> contains a comma not wrapped by round parenthesis so it will be interpreted as two separate macro parameters by the preprocessor).</p>
<p>In many cases it might be possible to use alternatives to this macro that will make the code more readable. For example, it might be possible to use define a new type <code class="computeroutput">typedef std::map&lt;int, duble&gt; map_type</code> prior to the macro and then pass the newly defined type <code class="computeroutput">map_type</code> which contains no comma as the macro parameter.</p>
<p>This macro must be prefixed by <code class="computeroutput">typename</code> when used within a type-dependant context (for example, within a template).</p>
<p>On some compilers (like GCC), using this macro on abstract types (classes with one or more pure virtual functions) generate a compile-time error. This can be worked around by manipulating the type adding and removing a reference to it: </p>
<pre class="programlisting">  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">remove_reference</span><span class="special">&lt;</span> <span class="identifier">BOOST_IDENTITY_TYPE</span><span class="special">(</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">add_reference</span><span class="special">&lt;</span>
      <span class="identifier">my_abstract_type</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="keyword">double</span> <span class="special">&gt;</span>
  <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span><span class="special">)</span><span class="special">)</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span>
</pre>
<p><span class="bold"><strong>Parameters:</strong></span> </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><span class="bold"><strong><code class="computeroutput">parenthesized_type</code></strong></span></td>
<td>The type expression to be passed as macro parameter wrapped by a single set of round parenthesis <code class="computeroutput">(...)</code>. This type expression can contain an arbitrary number of commas.  </td>
</tr></tbody>
</table></div>
<p>
</p>
<p><span class="bold"><strong>Note:</strong></span> This macro works on C++03 compilers (it does not require variadic macros). It expands to code equivalent to <code class="computeroutput">boost::function_traits&lt;void parenthesized_type&gt;::arg1_type</code>.</p>
<p><span class="bold"><strong>Warning:</strong></span> The compiler will not be able to automatically deduce any template parameter type part of the type expression specified by this macro. For example, if this macro is used to wrap the type <code class="computeroutput">std::map&lt;T, V&gt;</code> where <code class="computeroutput">T</code> and <code class="computeroutput">V</code> are template parameters, the compiler will not be able to automatically deduce <code class="computeroutput">T</code> and <code class="computeroutput">V</code> which will have to be explicitly specified when invoking the template expression. (This is never a concern for local functions because they cannot be templates.)</p>
<p><span class="bold"><strong>See:</strong></span> {Advanced_Topics, Advanced Topics} section. </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009-2012 Lorenzo
      Caminiti<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or a copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="reference.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="reference.html#header.boost.utility.identity_type_hpp"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a>
</div>
</body>
</html>
