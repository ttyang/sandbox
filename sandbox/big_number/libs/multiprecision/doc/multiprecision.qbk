[/ 
  Copyright 2011 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[library Boost.Multiprecision
    [quickbook 1.5]
    [copyright 2011 John Maddock]
    [purpose Multiprecision Number library]
    [license
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [authors, various]]
    [/last-revision $Date: 2011-07-08 18:51:46 +0100 (Fri, 08 Jul 2011) $]
]

[import ../example/gmp_snips.cpp]
[import ../example/mpfr_snips.cpp]
[import ../example/cpp_float_snips.cpp]
[import ../example/tommath_snips.cpp]
[import ../example/fixed_int_snips.cpp]

[template mpfr[] [@http://www.mpfr.org MPFR]]
[template gmp[] [@http://gmplib.org GMP]]
[template mpf_class[] [@http://gmplib.org/manual/C_002b_002b-Interface-Floats.html#C_002b_002b-Interface-Floats mpfr_class]]
[template mpfr_class[] [@http://math.berkeley.edu/~wilken/code/gmpfrxx/ mpfr_class]]
[template mpreal[] [@http://www.holoborodko.com/pavel/mpfr/ mpreal]]
[template mpir[] [@http://mpir.org/ MPIR]]

[section:intro Introduction]

The Multiprecision library comes in two distinct parts:

* An expression-template-enabled front end `mp_number`
that handles all the operator overloading, expression evaluation optimization, and code reduction.
* A selection of backends that implement the actual arithmetic operations, and need conform only to the
reduced interface requirements of the front end.

The library is often used via one of the predefined typedefs: for example if you wanted an arbitrary precision
integer type using [gmp] as the underlying implementation then you could use:

   #include <boost/multiprecision/gmp.hpp>  // Defines the wrappers around the GMP library's types

   boost::multiprecision::mpz_int myint;    // Arbitrary precision integer type.

Alternatively, you can compose your own multiprecision type, by combining `mp_number` with one of the
predefined backend types.  For example, suppose you wanted a 300 decimal digit floating-point type
based on the [mpfr] library. In this case, there's no predefined typedef with that level of precision,
so instead we compose our own:

   #include <boost/multiprecision/mpfr.hpp>  // Defines the Backend type that wraps MPFR

   namespace mp = boost::multiprecision;     // Reduce the typing a bit later...

   typedef mp::mp_number<mp::mpfr_float_backend<300> >  my_float;

   my_float a, b, c; // These variables have 300 decimal digits precision

[h4 Expression Templates]

Class `mp_number` is expression-template-enabled: that means that rather than having a multiplication
operator that looks like this:

   template <class Backend>
   mp_number<Backend> operator * (const mp_number<Backend>& a, const mp_number<Backend>& b)
   {
      mp_number<Backend> result(a);
      result *= b;
      return result;
   }

Instead the operator looks more like this:

   template <class Backend>
   ``['unmentionable-type]`` operator * (const mp_number<Backend>& a, const mp_number<Backend>& b);

Where the "unmentionable" return type is an implementation detail that, rather than containing the result
of the multiplication, contains instructions on how to compute the result.  In effect it's just a pair
of references to the arguments of the function, plus some compile-time information that stores what the operation
is.

The great advantage of this method is the ['elimination of temporaries]: for example the "naive" implementation
of `operator*` above, requires one temporary for computing the result, and at least another one to return it.  It's true 
that sometimes this overhead can be reduced by using move-semantics, but it can't be eliminated completely.  For example, 
lets suppose we're evaluating a polynomial via Horners method, something like this:

    T a[7] = { /* some values */ };
    //....
    y = (((((a[6] * x + a[5]) * x + a[4]) * x + a[3]) * x + a[2]) * x + a[1]) * x + a[0];

If type `T` is an `mp_number`, then this expression is evaluated ['without creating a single temporary value].  In contrast,
if we were using the C++ wrapper that ships with [gmp] - [mpf_class] - then this expression would result in no less than 11
temporaries (this is true even though [mpf_class] does use expression templates to reduce the number of temporaries somewhat).  Had
we used an even simpler wrapper around [gmp] or [mpfr] like `mpclass` things would have been even worse and no less that 24 temporaries
are created for this simple expression (note - we actually measure the number of memory allocations performed rather than 
the number of temporaries directly).

This library also extends expression template support to standard library functions like `abs` or `sin` with `mp_number`
arguments.  This means that an expression such as:

   y = abs(x);

can be evaluated without a single temporary being calculated.  Even expressions like:

   y = sin(x);

get this treatment, so that variable 'y' is used as "working storage" within the implementation of `sin`,
thus reducing the number of temporaries used by one.  Of course, should you write:

   x = sin(x);

Then we clearly can't use `x` as working storage during the calculation, so then a temporary variable
is created in this case.

Given the comments above, you might be forgiven for thinking that expression-templates are some kind of universal-panacea:
sadly though, all tricks like this have their downsides.  For one thing, expression template libraries
like this one, tend to be slower to compile than their simpler cousins, they're also harder to debug
(should you actually want to step through our code!), and rely on compiler optimizations being turned
on to give really good performance.  Also, since the return type from expressions involving `mp_number`'s
is an "unmentionable implementation detail", you have to be careful to cast the result of an expression
to the actual number type when passing an expression to a template function.  For example, given:

   template <class T>
   void my_proc(const T&);

Then calling:

   my_proc(a+b);

Will very likely result in obscure error messages inside the body of `my_proc` - since we've passed it
an expression template type, and not a number type.  Instead we probably need:

   my_proc(my_mp_number_type(a+b));

Having said that, these situations don't occur that often - or indeed not at all for non-template functions.
In addition, all the functions in the Boost.Math library will automatically convert expression-template arguments
to the underlying number type without you having to do anything, so:

   mpfr_float_100 a(20), delta(0.125);
   boost::math::gamma_p(a, a + delta);

Will work just fine, with the `a + delta` expression template argument getting converted to an `mpfr_float_100`
internally by the Boost.Math library.

One other potential pitfall that's only possible in C++11: you should never store an expression template using:

   auto my_expression = a + b - c;

unless you're absolutely sure that the lifetimes of `a`, `b` and `c` will outlive that of `my_expression`.

And finally... the performance improvements from an expression template library like this are often not as
dramatic as the reduction in number of temporaries would suggest.  For example if we compare this library with 
[mpfr_class] and [mpreal], with all three using the underlying [mpfr] library at 50 decimal digits precision then
we see the following typical results for polynomial execution:

[table Evaluation of Order 6 Polynomial.
[[Library][Relative Time][Relative number of memory allocations]]
[[mp_number][1.0 (0.00793s)][1.0 (2996 total)]]
[[[mpfr_class]][1.2 (0.00931s)][4.3 (12976 total)]]
[[[mpreal]][1.9 (0.0148s)][9.3 (27947 total)]]
]

As you can see, the execution time increases a lot more slowly than the number of memory allocations.  There are 
a number of reasons for this:

* The cost of extended-precision multiplication and division is so great, that the times taken for these tend to
swamp everything else.
* The cost of an in-place multiplication (using `operator*=`) tends to be more than an out-of-place
`operator*` (typically `operator *=` has to create a temporary workspace to carry out the multiplication, where
as `operator*` can use the target variable as workspace).  Since the expression templates carry out their
magic by converting out-of-place operators to in-place ones, we necessarily take this hit.  Even so the
transformation is more efficient than creating the extra temporary variable, just not by as much as
one would hope.

We'll conclude this section by providing some more performance comparisons between these three libraries,
again, all are using [mpfr] to carry out the underlying arithmetic, and all are operating at the same precision
(50 decimal digits):

[table Evaluation of Boost.Math's Bessel function test data
[[Library][Relative Time][Relative Number of Memory Allocations]]
[[mp_number][1.0 (6.21s)][1.0 (2685469)]]
[[[mpfr_class]][1.04 (6.45s)][1.47 (3946007)]]
[[[mpreal]][1.53 (9.52s)][4.92 (13222940)]]
]

[table Evaluation of Boost.Math's Non-Central T distribution test data
[[Library][Relative Time][Relative Number of Memory Allocations]]
[[mp_number][1.0 (269s)][1.0 (139082551)]]
[[[mpfr_class]][1.04 (278s)][1.81 (252400791)]]
[[[mpreal]][1.49 (401s)][3.22 (447009280)]]
]

[endsect]

[section:tut Tutorial]

In order to use this library you need to make two choices: what kind of number do I want, and
which backend do I want to perform the actual arithmetic?

[section:ints Integer Types]

The following backends provide integer arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`gmp_int`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient backend.][Dependency on GNU licenced [gmp] library.]]
[[`mp_int`][boost/multiprecision/tommath.hpp][2][libtommath][Public domain backend with no licence restrictions.][Slower than [gmp].]]
[[`fixed_int`][boost/multiprecision/fixed_int.hpp][2][None][Boost licenced fixed precision modular arithmetic integer.][Slower than [gmp].]]
]

[h4 gmp_int]

   namespace boost{ namespace multiprecision{

   class gmp_int;

   typedef mp_number<gmp_int >         mpz_int;

   }} // namespaces

The `gmp_int` backend is used via the typedef `boost::multiprecision::mpz_int`.  It acts as a thin wrapper around the [gmp] `mpz_t`
to provide an integer type that is a drop-in replacement for the native C++ integer types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, type `mpz_int` is copy constructible and assignable from:

* The [gmp] native types: `mpf_t`, `mpz_t`, `mpq_t`.
* Instances of `mp_number<T>` that are wrappers around those types: `mp_number<gmp_float<N> >`, `mp_number<gmp_rational>`.

It's also possible to access the underlying `mpz_t` via the `data()` member function of `gmp_int`.

Things you should know when using this type:

* No changes are made to the GMP library's global settings - so you can safely mix this type with
existing code that uses [gmp].
* Default constructed `gmp_int`'s have the value zero (this is GMP's default behavior).
* Formatted IO for this type does not support octal or hexadecimal notation for negative values, 
as a result performing formatted output on this type when the argument is negative and either of the flags
`std::ios_base::oct` or `std::ios_base::hex` are set, will result in a `std::runtime_error` will be thrown.
* Division by zero is handled by the [gmp] library - it will trigger a division by zero signal.
* Although this type is a wrapper around [gmp] it will work equally well with [mpir].  Indeed use of [mpir]
is recomended on Win32.

[h5 Example:]

[mpz_eg]

[h4 mp_int]

   namespace boost{ namespace multiprecision{

   class tommath_int;

   typedef mp_number<tommath_int >         mp_int;

   }} // namespaces

The `tommath_int` backend is used via the typedef `boost::multiprecision::mp_int`.  It acts as a thin wrapper around the libtommath `mp_int`
to provide an integer type that is a drop-in replacement for the native C++ integer types, but with unlimited precision.

Things you should know when using this type:

* Default constructed objects have the value zero (this is libtommath's default behavior).
* Although `mp_int` is mostly a drop in replacement for the builtin integer types, it should be noted that it is a
rather strange beast as it's a signed type that is not a 2's complement type.  As a result the bitwise operations
`| & ^` will throw a `std::runtime_error` exception if either of the arguments is negative.  Similarly the complement
operator`~` is deliberately not implemented for this type.
* Formatted IO for this type does not support octal or hexadecimal notation for negative values, 
as a result performing formatted output on this type when the argument is negative and either of the flags
`std::ios_base::oct` or `std::ios_base::hex` are set, will result in a `std::runtime_error` will be thrown.
* Division by zero will result in a hardware signal being raised by libtommath.

[h5 Example:]

[tommath_eg]

[h4 fixed_int]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits, bool Signed>
   class fixed_int;

   typedef mp_number<fixed_int<128, false> > mp_uint128_t;
   typedef mp_number<fixed_int<256, false> > mp_uint256_t;
   typedef mp_number<fixed_int<512, false> > mp_uint512_t;

   typedef mp_number<fixed_int<128, true> > mp_int128_t;
   typedef mp_number<fixed_int<256, true> > mp_int256_t;
   typedef mp_number<fixed_int<512, true> > mp_int512_t;

   }} // namespaces

The `fixed_int` backend is used via one of the typedefs `boost::multiprecision::mp_uint128_t`, `boost::multiprecision::mp_uint256_t`,
`boost::multiprecision::mp_uint512_t`, `boost::multiprecision::mp_int128_t`, `boost::multiprecision::mp_int256_t`
or `boost::multiprecision::mp_int512_t`.  It provides both signed and unsigned integer types with a fixed precision
and modular arithmetic with a 2's complement representation for negative values.  In other words it's designed to work just 
like a typical built in integer type, but with larger precision.

Things you should know when using this type:

* Default constructed `fixed_int`'s have indeterminate value - just like normal built in integers.
* Division by zero results in a `std::runtime_error` being thrown.
* Construction from a string that contains invalid non-numeric characters results in a `std::runtime_error` being thrown.
* Since the precision of `fixed_int` is necessarily limited, care should be taken to avoid numeric overflow when using this type
unless you actually want modulo-arithmetic behavior.

[h5 Example:]

[fixed_int_eg]

[endsect]

[section:reals Real Numbers]

The following backends provide real number arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`mpf_float<N>`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient backend.][Dependency on GNU licenced [gmp] library.]]
[[`mpfr_float<N>`][boost/multiprecision/mpfr.hpp][2][[gmp] and [mpfr]][Very fast and efficient backend, with its own standard library implementation.][Dependency on GNU licenced [gmp] and [mpfr] libraries.]]
[[`cpp_dec_float<N>`][boost/multiprecision/cpp_dec_float.hpp][10][None][Header only, all C++ implementation. Boost licence.][Approximately 2x slower than the [mpfr] or [gmp] libraries.]]
]

[h4 gmp_float]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class gmp_float;

   typedef mp_number<gmp_float<50> >    mpf_float_50;
   typedef mp_number<gmp_float<100> >   mpf_float_100;
   typedef mp_number<gmp_float<500> >   mpf_float_500;
   typedef mp_number<gmp_float<1000> >  mpf_float_1000;
   typedef mp_number<gmp_float<0> >     mpf_float;

   }} // namespaces

The `gmp_float` backend is used in conjunction with `mp_number` : it acts as a thin wrapper around the [gmp] `mpf_t`
to provide an real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `gmp_float` can be used at fixed precision by specifying a non-zero `Digits10` template parameter, or
at variable precision by setting the template argument to zero.  The typedefs mpf_float_50, mpf_float_100,
mpf_float_500, mpf_float_1000 provide arithmetic types at 50, 100, 500 and 1000 decimal digits precision
respectively.  The typedef mpf_float provides a variable precision type whose precision can be controlled via the
`mp_number`'s member functions.

[note This type only provides standard library and `numeric_limits` support when the precision is fixed at compile time.]

As well as the usual conversions from arithmetic and string types, instances of `mp_number<mpf_float<N> >` are
copy constructible and assignable from:

* The [gmp] native types `mpf_t`, `mpz_t`, `mpq_t`.
* The `mp_number` wrappers around those types: `mp_number<mpf_float<M> >`, `mp_number<gmp_int>`, `mp_number<gmp_rational>`.

It's also possible to access the underlying `mpf_t` via the `data()` member function of `gmp_float`.

Things you should know when using this type:

* Default constructed `gmp_float`'s have the value zero (this is the [gmp] library's default behavior).
* No changes are made to the [gmp] library's global settings, so this type can be safely mixed with
existing [gmp] code.
* It is not possible to round-trip objects of this type to and from a string and get back
exactly the same value.  This appears to be a limitation of [gmp].
* Since the underlying [gmp] types have no notion of infinities or NaN's, care should be taken
to avoid numeric overflow or division by zero.  That latter will trigger a hardware exception, 
while generating excessively large exponents may result in instability of the underlying [gmp]
library (in testing, converting a number with an excessively large or small exponent 
to a string caused [gmp] to segfault).
* This type can equally be used with [mpir] as the underlying implementation - indeed that is
the recommended option on Win32.

[h5 [gmp] example:]

[mpf_eg]

[h4 mpfr_float]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class mpfr_float_backend;

   typedef mp_number<mpfr_float_backend<50> >    mpfr_float_50;
   typedef mp_number<mpfr_float_backend<100> >   mpfr_float_100;
   typedef mp_number<mpfr_float_backend<500> >   mpfr_float_500;
   typedef mp_number<mpfr_float_backend<1000> >  mpfr_float_1000;
   typedef mp_number<mpfr_float_backend<0> >     mpfr_float;

   }} // namespaces

The `mpfr_float_backend` type is used in conjunction with `mp_number`: It acts as a thin wrapper around the [mpfr] `mpfr_t`
to provide an real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `mpfr_float_backend` can be used at fixed precision by specifying a non-zero `Digits10` template parameter, or
at variable precision by setting the template argument to zero.  The typedefs mpfr_float_50, mpfr_float_100,
mpfr_float_500, mpfr_float_1000 provide arithmetic types at 50, 100, 500 and 1000 decimal digits precision
respectively.  The typedef mpfr_float provides a variable precision type whose precision can be controlled via the
`mp_number`'s member functions.

[note This type only provides `numeric_limits` support when the precision is fixed at compile time.]

As well as the usual conversions from arithmetic and string types, instances of `mp_number<mpfr_float_backend<N> >` are
copy constructible and assignable from:

* The [gmp] native types `mpf_t`, `mpz_t`, `mpq_t`.
* The [mpfr] native type `mpfr_t`.
* The `mp_number` wrappers around those types: `mp_number<mpfr_float_backend<M> >`, `mp_number<mpf_float<M> >`, `mp_number<gmp_int>`, `mp_number<gmp_rational>`.

It's also possible to access the underlying `mpf_t` via the data() member function of `gmp_float`.

Things you should know when using this type:

* A default constructed `mpfr_float_backend` is set to a NaN (this is the default [mpfr] behavior).
* All operations use round to nearest.
* No changes are made to [gmp] or [mpfr] global settings, so this type can coexist with existing
[mpfr] or [gmp] code.
* The code can equally use [mpir] in place of [gmp] - indeed that is the prefered option on Win32.

[h5 [mpfr] example:]

[mpfr_eg]

[h4 cpp_dec_float]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class cpp_dec_float;

   typedef mp_number<cpp_dec_float<50> > cpp_float_50;
   typedef mp_number<cpp_dec_float<100> > cpp_float_100;

   }} // namespaces

The `cpp_dec_float` backend is used in conjunction with `mp_number`: It acts as an entirely C++ (header only and dependency free)
real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `cpp_dec_float` can be used at fixed precision by specifying a non-zero `Digits10` template parameter.  
The typedefs cpp_float_50 and cpp_float_100 provide arithmetic types at 50 and 100 decimal digits precision
respectively.

There is full standard library and `numeric_limits` support available for this type.

Things you should know when using this type:

* Default constructed `cpp_dec_float`'s have a value of zero.
* The radix of this type is 10.  As a result it can behave subtly differently from base-2 types.
* It is not possible to round-trip this type to and from a string and get back to exactly the same value
(this is a result of the type having some hidden internal guard digits).
* The type has a number of internal guard digits over and above those specified in the template argument.
Normally these should not be visible to the user.

[h5 cpp_dec_float example:]

[cpp_float_eg]

[endsect]

[section:rational Rational Number Types]

The following backends provide rational number arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`gmp_rational`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient backend.][Dependency on GNU licenced [gmp] library.]]
[[`tommath_rational`][boost/multiprecision/tommath.hpp][2][libtommath][All C/C++ implementation that's Boost Software Licence compatible.][Slower than [gmp].]]
[[`rational_adapter`][boost/multiprecision/rational_adapter.hpp][N/A][none][All C++ adapter that allows any inetger backend type to be used as a rational type.][Requires an underlying integer backend type.]]
[[`boost::rational`][boost/rational.hpp][N/A][None][A C++ rational number type that can used with any `mp_number` integer type.][The expression templates used by `mp_number` end up being "hidden" inside `boost::rational`: performance may well suffer as a result.]]
]

[h4 gmp_rational]

   namespace boost{ namespace multiprecision{

   class gmp_rational;

   typedef mp_number<gmp_rational >         mpq_rational;

   }} // namespaces

The `gmp_rational` backend is used via the typedef `boost::multiprecision::mpq_rational`.  It acts as a thin wrapper around the [gmp] `mpq_t`
to provide a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, instances of `mp_number<gmp_rational>` are copy constructible
and assignable from:

* The [gmp] native types: `mpz_t`, `mpq_t`.
* `mp_number<gmp_int>`.

There are also non-member functions:

   mpz_int numerator(const mpq_rational&);
   mpz_int denominator(const mpq_rational&);

which return the numerator and denominator of the number.

It's also possible to access the underlying `mpq_t` via the `data()` member function of `mpq_rational`.

Things you should know when using this type:

* Default constructed `mpq_rational`'s have the value zero (this is the [gmp] default behavior).
* Division by zero results in a hardware exception inside the [gmp] library.
* No changes are made to the [gmp] library's global settings, so this type can coexist with existing
[gmp] code.
* The code can equally be used with [mpir] as the underlying library - indeed that is the prefered option on Win32.

[h5 Example:]

[mpq_eg]

[h4 tommath_rational]

   namespace boost{ namespace multiprecision{

   typedef rational_adpater<tommath_int>        tommath_rational;
   typedef mp_number<tommath_rational >         mp_rational;

   }} // namespaces

The `tommath_rational` backend is used via the typedef `boost::multiprecision::mp_rational`.  It acts as a thin wrapper around 
`boost::rational<mp_int>`
to provide a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

The advantage of using this type rather than `boost::rational<mp_int>` directly, is that it is expression-template enabled,
greatly reducing the number of temporaries created in complex expressions.

There are also non-member functions:

   mp_int numerator(const mp_rational&);
   mp_int denominator(const mp_rational&);

which return the numerator and denominator of the number.

Things you should know when using this type:

* Default constructed `mp_rational`'s have the value zero (this the inherited Boost.Rational behavior).
* Division by zero results in a `boost::bad_rational` exception being thrown (see the rational number library's docs for more information).
* No changes are made to libtommath's global state, so this type can safely coexist with other libtommath code.
* Performance of this type has been found to be pretty poor - this need further investigation - but it appears that Boost.Rational
needs some improvement in this area.

[h5 Example:]

[mp_rat_eg]

[h4 Use With Boost.Rational]

All of the inetger types in this library can be used as template arguments to `boost::rational<IntType>`.

Note that using the library in this way largely negates the effect of the expression templates in `mp_number`.

[h4 rational_adapter]

   namespace boost{ namespace multiprecision{

   template <class IntBackend> 
   class rational_adpater;

   }}

The class template `rational_adapter` is a backend for `mp_number` which converts any existing integer backend
into a rational-number backend.

So for example, given an integer backend type `MyIntegerBackend`, the use would be something like:

   typedef mp_number<MyIntegerBackend>                    MyInt;
   typedef mp_number<rational_adapter<MyIntegerBackend> > MyRational;

   MyRational r = 2;
   r /= 3;
   MyInt i = numerator(r);
   assert(i == 2);


[endsect]

[endsect]

[section:ref Reference]

[section:mp_number mp_number]

[h4 Synopsis]

   namespace boost{ namespace multiprecision{

   template <class Backend>
   class mp_number
   {
      mp_number();
      mp_number(see-below);
      mp_number& operator=(see-below);

      // Member operators
      mp_number& operator+=(const ``['see-below]``&);
      mp_number& operator-=(const ``['see-below]``&);
      mp_number& operator*=(const ``['see-below]``&);
      mp_number& operator/=(const ``['see-below]``&);
      mp_number& operator++();
      mp_number& operator--();
      mp_number  operator++(int);
      mp_number  operator--(int);

      mp_number& operator%=(const ``['see-below]``&);
      mp_number& operator&=(const ``['see-below]``&);
      mp_number& operator|=(const ``['see-below]``&);
      mp_number& operator^=(const ``['see-below]``&);
      mp_number& operator<<=(const ``['integer-type]``&);
      mp_number& operator>>=(const ``['integer-type]``&);

      // Use in Boolean context:
      operator ``['convertible-to-bool-type]``()const;
      // swap:
      void swap(mp_number& other);
      // Sign:
      bool is_zero()const;
      int sign()const;
      // string conversion:
      std::string str()const;
      // Generic conversion mechanism
      template <class T>
      T convert_to()const;
      // precision control:
      static unsigned default_precision();
      static void default_precision(unsigned digits10);
      unsigned precision()const;
      void precision(unsigned digits10);
      // Comparison:
      int compare(const mp_number<Backend>& o)const;
      template <class V>
      typename enable_if<is_arithmetic<V>, int>::type compare(const V& o)const;
      // Access to the underlying implementation:
      Backend& backend();
      const Backend& backend()const;
   };

   // Non member operators:
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator*(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator/(const ``['see-below]``&, const ``['see-below]``&);
   // Integer only operations:
   ``['unmentionable-expression-template-type]`` operator%(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator&(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator|(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator^(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator<<(const ``['see-below]``&, const ``['integer-type]``&);
   ``['unmentionable-expression-template-type]`` operator>>(const ``['see-below]``&, const ``['integer-type]``&);
   // Comparison operators:
   bool operator==(const ``['see-below]``&, const ``['see-below]``&);
   bool operator!=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator< (const ``['see-below]``&, const ``['see-below]``&);
   bool operator> (const ``['see-below]``&, const ``['see-below]``&);
   bool operator<=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator>=(const ``['see-below]``&, const ``['see-below]``&);

   // Swap:
   template <class Backend>
   void swap(mp_number<Backend>& a, mp_number<Backend>& b);

   // iostream support:
   template <class Backend>
   std::ostream& operator << (std::ostream& os, const mp_number<Backend>& r);
   std::ostream& operator << (std::ostream& os, const ``['unmentionable-expression-template-type]``& r);
   template <class Backend>
   std::istream& operator >> (std::istream& is, mp_number<Backend>& r);

   // Non-member function standard library support:
   ``['unmentionable-expression-template-type]``    abs    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fabs   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sqrt   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    floor  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ceil   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    trunc  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    itrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ltrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lltrunc(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    round  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    iround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    llround(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    exp    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log10    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cos    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sin    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tan    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    acos   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    asin   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cosh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sinh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tanh   (const ``['mp_number-or-expression-template-type]``&);

   ``['unmentionable-expression-template-type]``    ldexp (const ``['mp_number-or-expression-template-type]``&, int);
   ``['unmentionable-expression-template-type]``    frexp (const ``['mp_number-or-expression-template-type]``&, int*);
   ``['unmentionable-expression-template-type]``    pow   (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fmod  (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan2 (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);

   // Traits support:
   template <class T>
   struct component_type;
   template <class T>
   struct number_category;

   // Rational number support:
   typename component_type<``['mp_number-or-expression-template-type]``>::type numerator  (const ``['mp_number-or-expression-template-type]``&);
   typename component_type<``['mp_number-or-expression-template-type]``>::type denominator(const ``['mp_number-or-expression-template-type]``&);

   }} // namespaces

   namespace boost{ namespace math{

   // Boost.Math interoperability functions:
   int                                              fpclassify     (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isfinite       (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isnan          (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isinf          (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isnormal       (const ``['mp_number-or-expression-template-type]``&, int);

   }} // namespaces

   // numeric_limits support:
   namespace std{

   template <class Backend>
   struct numeric_limits<boost::multiprecision<Backend> >
   {
      /* Usual members here */
   };

   }

[h4 Description]

   mp_number();
   mp_number(see-below);
   mp_number& operator=(see-below);

Type `mp_number` is default constructible, and both copy constructible and assignable from:

* Itself.
* An expression template which is the result of one of the arithmetic operators.
* Any builtin arithmetic type.
* A `std::string` or any type which is convertible to `const char*`.
* Any type that the Backend is constructible or assignable from.

In addition, if the type has multiple components (for example rational or complex number types), then there is a
two argument constructor:

   mp_number(arg1, arg2);

Where the two args must either be arithmetic types, or types that are convertible to the two components of `this`.

      mp_number& operator+=(const ``['see-below]``&);
      mp_number& operator-=(const ``['see-below]``&);
      mp_number& operator*=(const ``['see-below]``&);
      mp_number& operator/=(const ``['see-below]``&);
      mp_number& operator++();
      mp_number& operator--();
      mp_number  operator++(int);
      mp_number  operator--(int);
      // Integer only operations:
      mp_number& operator%=(const ``['see-below]``&);
      mp_number& operator&=(const ``['see-below]``&);
      mp_number& operator|=(const ``['see-below]``&);
      mp_number& operator^=(const ``['see-below]``&);
      mp_number& operator<<=(const ``['integer-type]``&);
      mp_number& operator>>=(const ``['integer-type]``&);

These operators all take their usual arithmetic meanings.

The arguments to these operators is either:

* Another `mp_number<Backend>`.
* A builtin arithmetic type.
* An expression template derived from `mp_number<Backend>`.

For the left and right shift operations, the argument must be a builtin
integer type with a positive value (negative values result in a `std::runtime_error` being thrown).

      operator ``['convertible-to-bool-type]``()const;

Returns an ['unmentionable-type] that is usable in Boolean contexts (this allows `mp_number` to be used in any
Boolean context - if statements, conditional statements, or as an argument to a logical operator - without
type `mp_number` being convertible to type `bool`.

This operator also enables the use of `mp_number` with any of the following operators:
`!`, `||`, `&&` and `?:`.

      void swap(mp_number& other);

Swaps `*this` with `other`.

      bool is_zero()const;

Returns `true` is `*this` is zero, otherwise `false`.

      int sign()const;

Returns a value less than zero if `*this` is negative, a value greater than zero if `*this` is positive, and zero
if `*this` is zero.

      std::string str(unsigned precision, bool scientific = true)const;

Returns the number formatted as a string, with at least /precision/ digits, and in scientific format
if /scientific/ is true.

      template <class T>
      T convert_to()const;

Provides a generic conversion mechanism to convert `*this` to type `T`.  Type `T` may be any arithmetic type.
Optionally other types may also be supported by specific `Backend` types.


      static unsigned default_precision();
      static void default_precision(unsigned digits10);
      unsigned precision()const;
      void precision(unsigned digits10);

These functions are only available if the Backend template parameter supports runtime changes to precision.  They get and set
the default precision and the precision of `*this` respectively.

      int compare(const mp_number<Backend>& o)const;
      template <class V>
      typename enable_if<is_arithmetic<V>, int>::type compare(const V& other)const;

Returns:

* A value less that 0 for `*this < other`
* A value greater that 0 for `*this > other`
* Zero for `*this == other`

      Backend& backend();
      const Backend& backend()const;

Returns the underlying backend instance used by `*this`.

[h4 Non-member operators]

   // Non member operators:
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator*(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator/(const ``['see-below]``&, const ``['see-below]``&);
   // Integer only operations:
   ``['unmentionable-expression-template-type]`` operator%(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator&(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator|(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator^(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator<<(const ``['see-below]``&, const ``['integer-type]``&);
   ``['unmentionable-expression-template-type]`` operator>>(const ``['see-below]``&, const ``['integer-type]``&);
   // Comparison operators:
   bool operator==(const ``['see-below]``&, const ``['see-below]``&);
   bool operator!=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator< (const ``['see-below]``&, const ``['see-below]``&);
   bool operator> (const ``['see-below]``&, const ``['see-below]``&);
   bool operator<=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator>=(const ``['see-below]``&, const ``['see-below]``&);

These operators all take their usual arithmetic meanings.

The arguments to these functions must contain at least one of the following:

* An `mp_number`.
* An expression template type derived from `mp_number`.

In addition, one of the two arguments may be a builtin arithmetic type.

With the exception of the comparison operators (which always evaluate their arguments and return a `bool` result),
these operators return an "unmentionable" expression template type which defers evaluation of the operator
until the result is actually required.

Finally note that the second argument to the left and right shift operations must be a builtin integer type, 
and that the argument must be positive (negative arguments result in a `std::runtime_error` being thrown).

[h4 swap]

   template <class Backend>
   void swap(mp_number<Backend>& a, mp_number<Backend>& b);

Swaps `a` and `b`.

[h4 Iostream Support]

   template <class Backend>
   std::ostream& operator << (std::ostream& os, const mp_number<Backend>& r);
   template <class Backend>
   std::ostream& operator << (std::ostream& os, const unmentionable-expression-template& r);
   template <class Backend>
   inline std::istream& operator >> (std::istream& is, mp_number<Backend>& r)

These operators provided formatted input-output operations on `mp_number` types, and expression templates derived from them.

It's down to the backend type to actually implement string conversion.  However, the backends provided with
this library support all of the iostream formatting flags, field width and precision settings.

[h4 Non-member standard library function support]

   ``['unmentionable-expression-template-type]``    abs    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fabs   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sqrt   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    floor  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ceil   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    trunc  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    itrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ltrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lltrunc(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    round  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    iround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    llround(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    exp    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log10    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cos    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sin    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tan    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    acos   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    asin   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cosh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sinh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tanh   (const ``['mp_number-or-expression-template-type]``&);

   ``['unmentionable-expression-template-type]``    ldexp (const ``['mp_number-or-expression-template-type]``&, int);
   ``['unmentionable-expression-template-type]``    frexp (const ``['mp_number-or-expression-template-type]``&, int*);
   ``['unmentionable-expression-template-type]``    pow   (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fmod  (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan2 (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);

These functions all behave exactly as their standard library counterparts do: their argument is either an instance of `mp_number` or
an expression template derived from it; their return value is always an expression template.

These functions are normally implemented by the Backend type.  However, default versions are provided for Backend types that
don't have native support for these functions.  Please note however, that this default support requires the precision of the type
to be a compile time constant - this means for example that the [gmp] MPF Backend will not work with these functions when that type is 
used at variable precision.

Also note that with the exception of `abs` that these functions can only be used with floating-point Backend types.

[h4 Traits Class Support]

   template <class T>
   struct component_type;

If this is a type with mutiple components (for example rational or complex types), then this trait has a single member
`type` that is the type of those components.

   template <class T>
   struct number_category;

A traits class that inherits from `mpl::int_<N>` where `N` is one of the enumerated values `number_kind_integer`, `number_kind_floating_point`,
`number_kind_rational` or `number_kind_fixed_point`.

[h4 Rational Number Functions]

   typename component_type<``['mp_number-or-expression-template-type]``>::type numerator  (const ``['mp_number-or-expression-template-type]``&);
   typename component_type<``['mp_number-or-expression-template-type]``>::type denominator(const ``['mp_number-or-expression-template-type]``&);

These functions return the numerator and denominator of a rational number respectively.

[h4 Boost.Math Interoperability Support]

   namespace boost{ namespace math{

   int  fpclassify     (const ``['mp_number-or-expression-template-type]``&, int);
   bool isfinite       (const ``['mp_number-or-expression-template-type]``&, int);
   bool isnan          (const ``['mp_number-or-expression-template-type]``&, int);
   bool isinf          (const ``['mp_number-or-expression-template-type]``&, int);
   bool isnormal       (const ``['mp_number-or-expression-template-type]``&, int);

   }} // namespaces

These floating-point classification functions behave exactly as their Boost.Math equivalents.

Other Boost.Math functions and templates may also be
specialized or overloaded to ensure interoperability.

[h4 std::numeric_limits support]

   namespace std{

   template <class Backend>
   struct numeric_limits<boost::multiprecision<Backend> >
   {
      /* Usual members here */
   };

   }

Class template `std::numeric_limits` is specialized for all instantiations of `mp_number` whose precision is known at compile time, plus those
types whose precision is unlimited (though it is much less useful in those cases).  It is not specialized for types
whose precision can vary at compile time (such as `mpf_float`).

[endsect]

[section:backendconc Backend Requirements]

[template super[x]'''<superscript>'''[x]'''</superscript>''']

The requirements on the `Backend` template argument to `mp_number` are split up into
compulsory requirements, and optional requirements that are either to improve performance
or provide optional features.

In the following tables, type B is the `Backend` template arument to `mp_number`, `b` is
a variable of B, `cb` and `cb2` are constant variables of type B, `a` is a variable of Arithmetic type, 
`s` is a variable of type `const char*`, `ui` is a variable of type `unsigned`, `bb` is a variable of type `bool`,
`pa` is a variable of type pointer-to-arithmetic-type, `exp` is a variable of type `B::exp_type`,
`pexp` is a variable of type `B::exp_type*`, B2 is another type that meets these requirements, b2 is a variable
of type B2.

[table Compulsory Requirements on the Backend type.
[[Expression][Return Type][Comments]]
[[`B::signed_types`][`mpl::list<type-list>`][A list of signed integral types that can be assigned to type B.  The types shall be
                   listed in order of size, smallest first, and shall terminate in the type that is `std::intmax_t`.]]
[[`B::unsigned_types`][`mpl::list<type-list>`][A list of unsigned integral types that can be assigned to type B.  The types shall be
                   listed in order of size, smallest first, and shall terminate in the type that is `std::uintmax_t`.]]
[[`B::float_types`][`mpl::list<type-list>`][A list of floating-point types that can be assigned to type B.The types shall be
                   listed in order of size, smallest first, and shall terminate in type `long double`.]]
[[`B::exponent_type`][A signed integral type.][The type of the exponent of type B.]]
[[`B()`][ ][Default constructor.]]
[[`B(cb)`][ ][Copy Constructor.]]
[[`b = b`][`B&`][Assignment operator.]]
[[`b = a`][`B&`][Assignment from an Arithmetic type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`b = s`][`B&`][Assignment from a string.]]
[[`b.swap(b)`][`void`][Swaps the contents of its arguments.]]
[[`cb.str(ui, bb)`][`std::string`][Returns the string representation of `b` with `ui` digits and in scientific format if `bb` is `true`.
                  If `ui` is zero, then returns as many digits as are required to reconstruct the original value.]]
[[`b.negate()`][`void`][Negates `b`.]]
[[`cb.compare(cb2)`][`int`][Compares `cb` and `cb2`, returns a value less than zero if `cb < cb2`, a value greater than zero if `cb > cb2` and zero
                   if `cb == cb2`.]]
[[`cb.compare(a)`][`int`][Compares `cb` and `a`, returns a value less than zero if `cb < a`, a value greater than zero if `cb > a` and zero
                   if `cb == a`.  The type of `a` shall be listed in one of the type lists
                   `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`add(b, cb)`][`void`][Adds `cb` to `b`.]]
[[`subtract(b, cb)`][`void`][Subtracts `cb` from `b`.]]
[[`multiply(b, cb)`][`void`][Multiplies `b` by `cb`.]]
[[`divide(b, cb)`][`void`][Divides `b` by `cb`.]]
[[`modulus(b, cb)`][`void`][Computes `b %= cb`, only required when `B` is an integer type.]]
[[`bitwise_and(b, cb)`][`void`][Computes `b &= cb`, only required when `B` is an integer type.]]
[[`bitwise_or(b, cb)`][`void`][Computes `b |= cb`, only required when `B` is an integer type.]]
[[`bitwise_xor(b, cb)`][`void`][Computes `b ^= cb`, only required when `B` is an integer type.]]
[[`complement(b, cb)`][`void`][Computes the ones-complement of `cb` and stores the result in `b`, only required when `B` is an integer type.]]
[[`left_shift(b, ui)`][`void`][Computes `b <<= ui`, only required when `B` is an integer type.]]
[[`right_shift(b, ui)`][`void`][Computes `b >>= ui`, only required when `B` is an integer type.]]
[[`convert_to(pa, cb)`][`void`][Converts `cb` to the type of `*pa` and store the result in `*pa`.  Type `B` shall support
                     conversion to at least types `std::intmax_t`, `std::uintmax_t` and `long long`.
                     Conversion to other arithmetic types can then be synthesised using other operations.
                     Conversions to other types are entirely optional.]]
[[`eval_frexp(b, cb, pexp)`][`void`][Stores values in `b` and `*pexp` such that the value of `cb` is b * 2[super *pexp], only required when `B` is a floating-point type.]]
[[`eval_ldexp(b, cb, exp)`][`void`][Stores a value in `b` that is cb * 2[super exp], only required when `B` is a floating-point type.]]
[[`eval_floor(b, cb)`][`void`][Stores the floor of `cb` in `b`, only required when `B` is a floating-point type.]]
[[`eval_ceil(b, cb)`][`void`][Stores the ceiling of `cb` in `b`, only required when `B` is a floating-point type.]]
[[`eval_sqrt(b, cb)`][`void`][Stores the square root of `cb` in `b`, only required when `B` is a floating-point type.]]
[[`boost::multiprecision::number_category<B>::type`][`mpl::int_<N>`][`N` is one of the values `number_kind_integer`, `number_kind_floating_point`, `number_kind_rational` or `number_kind_fixed_point`.
                                                Defaults to `number_kind_floating_point`.]]
]

[table Optional Requirements on the Backend Type
[[Expression][Returns][Comments]]
[[`B(b2)`][`B`][Copy constructor from a different backend type.]]
[[`b = b2`][`b&`][Assignment operator from a different backend type.]]
[[`assign_components(b, a, a)`][`void`][Assigns to `b` the two components in the following arguments.  
                           Only applies to rational and complex number types.]]
[[`assign_components(b, b2, b2)`][`void`][Assigns to `b` the two components in the following arguments.  
                           Only applies to rational and complex number types.]]
[[`add(b, a)`][`void`][Adds `a` to `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`subtract(b, a)`][`void`][Subtracts `a` from `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`multiply(b, a)`][`void`][Multiplies `b` by `a`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`divide(b, a)`][`void`][Divides `b` by `a`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`modulus(b, a)`][`void`][Computes `b %= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_and(b, a)`][`void`][Computes `b &= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_or(b, a)`][`void`][Computes `b |= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_xor(b, a)`][`void`][Computes `b ^= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`add(b, cb, cb2)`][`void`][Add `cb` to `cb2` and stores the result in `b`.]]
[[`subtract(b, cb, cb2)`][`void`][Subtracts `cb2` from `cb` and stores the result in `b`.]]
[[`multiply(b, cb, cb2)`][`void`][Multiplies `cb` by `cb2` and stores the result in `b`.]]
[[`divide(b, cb, cb2)`][`void`][Divides `cb` by `cb2` and stores the result in `b`.]]
[[`add(b, cb, a)`][`void`][Add `cb` to `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`subtract(b, cb, a)`][`void`][Subtracts `a` from `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`multiply(b, cb, a)`][`void`][Multiplies `cb` by `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`divide(b, cb, a)`][`void`][Divides `cb` by `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`modulus(b, cb, cb2)`][`void`][Computes `cb % cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`bitwise_and(b, cb, cb2)`][`void`][Computes `cb & cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`bitwise_or(b, cb, cb2)`][`void`][Computes `cb | cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`bitwise_xor(b, cb, cb2)`][`void`][Computes `cb ^ cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`add(b, a, cb)`][`void`][Add `a` to `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`subtract(b, a, cb)`][`void`][Subtracts `cb` from `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`multiply(b, a, cb)`][`void`][Multiplies `a` by `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`divide(b, a, cb)`][`void`][Divides `a` by `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`modulus(b, cb, a)`][`void`][Computes `cb % a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_and(b, cb, a)`][`void`][Computes `cb & a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_or(b, cb, a)`][`void`][Computes `cb | a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_xor(b, cb, a)`][`void`][Computes `cb ^ a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`modulus(b, a, cb)`][`void`][Computes `cb % a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_and(b, a, cb)`][`void`][Computes `cb & a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_or(b, a, cb)`][`void`][Computes `cb | a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`bitwise_xor(b, a, cb)`][`void`][Computes `a ^ cb` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`left_shift(b, cb, ui)`][`void`][Computes `cb << ui` and stores the result in `b`, only required when `B` is an integer type.]]
[[`right_shift(b, cb, ui)`][`void`][Computes `cb >> ui` and stores the result in `b`, only required when `B` is an integer type.]]
[[`increment(b)`][void][Increments the value of `b` by one.]]
[[`decrement(b)`][void][Decrements the value of `b` by one.]]
[[`is_zero(cb)`][`bool`][Returns `true` if `cb` is zero, otherwise `false`]]
[[`get_sign(cb)`][`int`][Returns a value < zero if `cb` is negative, a value > zero if `cb` is positive, and zero if `cb` is zero.]]
[[`eval_abs(b, cb)`][`void`][Set `b` to the absolute value of `cb`.]]
[[`eval_fabs(b, cb)`][`void`][Set `b` to the absolute value of `cb`.]]
[[`eval_fpclassify(cb)`][`int`][Returns one of the same values returned by `std::fpclassify`.  Only required when `B` is an floating-point type.]]
[[`eval_trunc(b, cb)`][`void`][Performs the equivalent operation to `std::trunc` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_round(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::round` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_exp(b, cb)`][`void`][Performs the equivalent operation to `std::exp` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_log(b, cb)`][`void`][Performs the equivalent operation to `std::log` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_log10(b, cb)`][`void`][Performs the equivalent operation to `std::log10` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_sin(b, cb)`][`void`][Performs the equivalent operation to `std::sin` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_cos(b, cb)`][`void`][Performs the equivalent operation to `std::cos` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_tan(b, cb)`][`void`][Performs the equivalent operation to `std::exp` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_asin(b, cb)`][`void`][Performs the equivalent operation to `std::asin` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_acos(b, cb)`][`void`][Performs the equivalent operation to `std::acos` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_atan(b, cb)`][`void`][Performs the equivalent operation to `std::atan` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_sinh(b, cb)`][`void`][Performs the equivalent operation to `std::sinh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_cosh(b, cb)`][`void`][Performs the equivalent operation to `std::cosh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_tanh(b, cb)`][`void`][Performs the equivalent operation to `std::tanh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_fmod(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::fmod` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_pow(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::pow` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_atan2(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::atan` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.]]
]

[endsect]

[endsect]

[section:perf Performance Comparison]

[section:realworld Real World Tests]

These tests test the total time taken to execute all of Boost.Math's test cases for these functions.
In each case the best performing library gets a relative score of 1, with the total execution time
given in brackets.  The first three libraries listed are the various floating point types provided
by this library, while for comparison, two popular C++ frontends to [mpfr] ([mpfr_class] and [mpreal])
are also shown.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Bessel Function Performance
[[Library][50 Decimal Digits][100 Decimal Digits]]
[[mpfr_float][[*1.0] (6.472s)][1.193 (10.154s)]]
[[mpf_float][1.801 (11.662s)][[*1.0](8.511s)]]
[[cpp_dec_float][3.13 (20.285s)][2.46 (21.019s)]]
[[[mpfr_class]][1.001 (6.480s)][1.15(9.805s)]]
[[[mpreal]][1.542 (9.981s)][1.61 (13.702s)]]
]

[table Non-Central T Distribution Performance
[[Library][50 Decimal Digits][100 Decimal Digits]]
[[mpfr_float][1.308 (258.09s)][1.30 (516.74s)]]
[[mpf_float][[*1.0] (197.30s)][[*1.0](397.30s)]]
[[cpp_dec_float][1.695 (334.50s)][2.68 (1064.53s)]]
[[[mpfr_class]][1.35 (266.39s)][1.323 (525.74s)]]
[[[mpreal]][1.75 (346.64s)][1.635 (649.94s)]]
]

[endsect]

[section:float_performance Float Algorithm Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticsm, and real-world peformance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Operator +
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.02382s)][[*1] (0.0294619s)][[*1] (0.058466s)]]
[[gmp_float][4.55086 (0.108402s)][3.86443 (0.113853s)][2.6241 (0.15342s)]]
[[mpfr_float][2.52036 (0.060035s)][2.1833 (0.0643242s)][1.37736 (0.0805287s)]]
]
[table Operator +(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.56759 (0.0527023s)][1.74629 (0.0618102s)][1.68077 (0.105927s)]]
[[gmp_float][[*1] (0.0336201s)][[*1] (0.0353951s)][[*1] (0.0630232s)]]
[[mpfr_float][3.14875 (0.105861s)][3.15499 (0.111671s)][1.92831 (0.121528s)]]
]
[table Operator -
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.0265783s)][[*1] (0.031465s)][[*1] (0.0619405s)]]
[[gmp_float][4.66954 (0.124108s)][3.72645 (0.117253s)][2.67536 (0.165713s)]]
[[mpfr_float][2.7909 (0.0741774s)][2.48557 (0.0782083s)][1.50944 (0.0934957s)]]
]
[table Operator -(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.0577674s)][[*1] (0.0633795s)][[*1] (0.11146s)]]
[[gmp_float][2.31811 (0.133911s)][2.07251 (0.131355s)][1.67161 (0.186319s)]]
[[mpfr_float][2.45081 (0.141577s)][2.29174 (0.145249s)][1.395 (0.155487s)]]
]
[table Operator *
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.07276 (0.287898s)][1.47724 (0.584569s)][1.55145 (5.09969s)]]
[[gmp_float][[*1] (0.268372s)][[*1] (0.395718s)][[*1] (3.28705s)]]
[[mpfr_float][1.27302 (0.341642s)][1.17649 (0.465557s)][1.14029 (3.7482s)]]
]
[table Operator *(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][2.89945 (0.11959s)][4.56335 (0.197945s)][9.03602 (0.742044s)]]
[[gmp_float][[*1] (0.0412457s)][[*1] (0.0433772s)][[*1] (0.0821206s)]]
[[mpfr_float][3.6951 (0.152407s)][3.71977 (0.161353s)][3.30958 (0.271785s)]]
]
[table Operator /
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][3.24327 (4.00108s)][5.00532 (8.12985s)][6.79566 (54.2796s)]]
[[gmp_float][[*1] (1.23366s)][[*1] (1.62424s)][[*1] (7.9874s)]]
[[mpfr_float][1.32521 (1.63486s)][1.38967 (2.25716s)][1.72413 (13.7713s)]]
]
[table Operator /(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.45093 (0.253675s)][1.83306 (0.419569s)][2.3644 (1.64187s)]]
[[gmp_float][[*1] (0.174836s)][[*1] (0.22889s)][[*1] (0.694411s)]]
[[mpfr_float][1.16731 (0.204088s)][1.13211 (0.259127s)][1.02031 (0.708513s)]]
]
[table Operator str
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.4585 (0.0188303s)][1.55515 (0.03172s)][[*1] (0.131962s)]]
[[gmp_float][[*1] (0.0129107s)][[*1] (0.0203967s)][1.04632 (0.138075s)]]
[[mpfr_float][2.19015 (0.0282764s)][1.84679 (0.0376683s)][1.20295 (0.158743s)]]
]
]
[endsect]

[section:integer_performance Integer Algorithm Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticsm, and real-world peformance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

Note that Linux x64 tests showed significantly worse performance for `fixed_int` division
than on Win32 (or possibly [gmp] behaves much better in that case).  Otherwise the results
are much the same.

[table Operator +
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.0031291s)][[*1] (0.00703043s)][[*1] (0.0163669s)][[*1] (0.0326567s)][[*1] (0.0603087s)]]
[[gmp_int][12.4866 (0.0390717s)][6.01034 (0.0422553s)][2.65628 (0.0434751s)][1.54295 (0.0503875s)][1.16477 (0.0702458s)]]
[[tommath_int][6.03111 (0.018872s)][3.08173 (0.0216659s)][1.84243 (0.0301548s)][1.30199 (0.0425188s)][1.18909 (0.0717123s)]]
]
[table Operator +(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00335294s)][[*1] (0.00376116s)][[*1] (0.00985174s)][[*1] (0.0119345s)][[*1] (0.0170918s)]]
[[gmp_int][9.47407 (0.031766s)][8.44794 (0.0317741s)][4.23857 (0.0417573s)][5.40856 (0.0645488s)][6.31314 (0.107903s)]]
[[tommath_int][67.0025 (0.224655s)][60.4203 (0.22725s)][25.1834 (0.2481s)][23.2996 (0.27807s)][17.1743 (0.293538s)]]
]
[table Operator -
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00339191s)][[*1] (0.0073172s)][[*1] (0.0166428s)][[*1] (0.0349375s)][[*1] (0.0600083s)]]
[[gmp_int][12.5182 (0.0424608s)][5.57936 (0.0408253s)][2.78496 (0.0463496s)][1.48373 (0.051838s)][1.29928 (0.0779673s)]]
[[tommath_int][7.00782 (0.0237699s)][3.69919 (0.0270677s)][2.29645 (0.0382195s)][1.39777 (0.0488346s)][1.28243 (0.0769566s)]]
]
[table Operator -(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00250933s)][[*1] (0.00358055s)][[*1] (0.0103282s)][[*1] (0.0119127s)][[*1] (0.0176089s)]]
[[gmp_int][12.093 (0.0303454s)][8.50898 (0.0304669s)][3.9284 (0.0405733s)][5.03037 (0.0599252s)][5.96617 (0.105058s)]]
[[tommath_int][80.8477 (0.202873s)][57.8371 (0.207089s)][21.3372 (0.220375s)][23.526 (0.280258s)][14.793 (0.260488s)]]
]
[table Operator *
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.0223481s)][[*1] (0.0375288s)][[*1] (0.120353s)][[*1] (0.439147s)][[*1] (1.46969s)]]
[[gmp_int][2.50746 (0.0560369s)][1.76676 (0.0663044s)][1.06052 (0.127636s)][1.22558 (0.53821s)][1.03538 (1.52168s)]]
[[tommath_int][3.00028 (0.0670506s)][2.97696 (0.111722s)][2.86257 (0.34452s)][2.26661 (0.995374s)][2.12926 (3.12935s)]]
]
[table Operator *(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00444316s)][[*1] (0.0135739s)][[*1] (0.0192615s)][[*1] (0.0328339s)][1.18198 (0.0567364s)]]
[[gmp_int][4.57776 (0.0203397s)][1.79901 (0.0244196s)][1.32814 (0.025582s)][1.01453 (0.033311s)][[*1] (0.048001s)]]
[[tommath_int][53.8709 (0.239357s)][18.3773 (0.249452s)][14.2088 (0.273682s)][14.0907 (0.462652s)][9.10761 (0.437175s)]]
]
[table Operator /
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.0991632s)][[*1] (0.172328s)][[*1] (0.309492s)][[*1] (0.573815s)][[*1] (1.06356s)]]
[[gmp_int][7.81859 (0.775316s)][5.11069 (0.880715s)][2.93514 (0.908404s)][1.80497 (1.03572s)][1.21878 (1.29625s)]]
[[tommath_int][18.0766 (1.79253s)][12.3939 (2.13582s)][9.80438 (3.03438s)][8.74047 (5.01541s)][10.8288 (11.517s)]]
]
[table Operator /(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][1.04098 (0.0443082s)][1.61317 (0.110308s)][2.18324 (0.229148s)][2.36331 (0.442167s)][2.45159 (0.866172s)]]
[[gmp_int][[*1] (0.042564s)][[*1] (0.06838s)][[*1] (0.104957s)][[*1] (0.187096s)][[*1] (0.35331s)]]
[[tommath_int][32.4072 (1.37938s)][23.7471 (1.62383s)][22.1907 (2.32908s)][19.9054 (3.72421s)][24.2219 (8.55783s)]]
]
[table Operator %
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.0946529s)][[*1] (0.170561s)][[*1] (0.328458s)][[*1] (0.575884s)][[*1] (1.05006s)]]
[[gmp_int][7.77525 (0.73595s)][4.39387 (0.749422s)][2.35075 (0.772122s)][1.51922 (0.874894s)][1.02263 (1.07382s)]]
[[tommath_int][27.1503 (2.56986s)][12.8743 (2.19585s)][9.43965 (3.10053s)][8.24936 (4.75068s)][10.9719 (11.5211s)]]
]
[table Operator %(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][1.25034 (0.0425984s)][1.91617 (0.106226s)][2.02166 (0.195577s)][2.14437 (0.387067s)][2.23514 (0.776075s)]]
[[gmp_int][[*1] (0.0340695s)][[*1] (0.0554367s)][[*1] (0.0967406s)][[*1] (0.180504s)][[*1] (0.347216s)]]
[[tommath_int][42.8781 (1.46083s)][29.879 (1.65639s)][23.4323 (2.26685s)][19.932 (3.5978s)][25.0046 (8.682s)]]
]
[table Operator str
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.000465841s)][[*1] (0.00102073s)][[*1] (0.00207212s)][1.02618 (0.0062017s)][1.32649 (0.0190043s)]]
[[gmp_int][2.83823 (0.00132216s)][2.17537 (0.00222046s)][1.46978 (0.00304557s)][[*1] (0.00604351s)][[*1] (0.0143268s)]]
[[tommath_int][15.76 (0.00734164s)][15.9879 (0.0163193s)][21.7337 (0.0450349s)][19.7183 (0.119168s)][26.3445 (0.377431s)]]
]
[table Operator <<
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.0119095s)][[*1] (0.0131746s)][[*1] (0.0213483s)][[*1] (0.0247552s)][[*1] (0.0339579s)]]
[[gmp_int][1.9355 (0.0230509s)][1.94257 (0.0255925s)][1.49684 (0.031955s)][1.79202 (0.0443618s)][2.0846 (0.0707887s)]]
[[tommath_int][2.64273 (0.0314737s)][2.95612 (0.0389456s)][3.05842 (0.065292s)][3.79496 (0.0939451s)][4.82142 (0.163725s)]]
]
[table Operator >>
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.006361s)][[*1] (0.00880189s)][[*1] (0.0180295s)][[*1] (0.0220786s)][[*1] (0.0325312s)]]
[[gmp_int][4.26889 (0.0271544s)][3.14669 (0.0276968s)][1.74396 (0.0314426s)][1.45928 (0.0322188s)][1.24596 (0.0405327s)]]
[[tommath_int][39.4379 (0.250865s)][28.6225 (0.251932s)][16.4543 (0.296661s)][14.2167 (0.313884s)][15.5842 (0.506974s)]]
]
[table Operator &
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00298048s)][[*1] (0.00546222s)][[*1] (0.0127546s)][[*1] (0.01985s)][[*1] (0.0349286s)]]
[[gmp_int][16.0105 (0.0477189s)][9.67027 (0.0528211s)][5.12678 (0.0653902s)][4.62316 (0.0917698s)][4.00837 (0.140007s)]]
[[tommath_int][43.6665 (0.130147s)][23.8003 (0.130002s)][11.4242 (0.145711s)][7.83416 (0.155508s)][9.50103 (0.331858s)]]
]
[table Operator &(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00222291s)][[*1] (0.0035522s)][[*1] (0.0110247s)][[*1] (0.0154281s)][[*1] (0.0275044s)]]
[[gmp_int][70.8538 (0.157502s)][42.1478 (0.149717s)][13.9023 (0.153268s)][10.3271 (0.159328s)][6.0529 (0.166481s)]]
[[tommath_int][154.134 (0.342626s)][93.2035 (0.331077s)][31.9151 (0.351853s)][23.6515 (0.364899s)][22.0042 (0.605213s)]]
]
[table Operator ^
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00307714s)][[*1] (0.00538197s)][[*1] (0.0127717s)][[*1] (0.0198304s)][[*1] (0.0345822s)]]
[[gmp_int][13.9543 (0.0429392s)][9.92785 (0.0534314s)][4.80398 (0.0613552s)][4.35864 (0.0864335s)][3.887 (0.134421s)]]
[[tommath_int][41.5958 (0.127996s)][24.2396 (0.130457s)][11.3666 (0.145171s)][8.01016 (0.158845s)][9.84853 (0.340584s)]]
]
[table Operator ^(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00236664s)][[*1] (0.0035339s)][[*1] (0.0100442s)][[*1] (0.0155814s)][[*1] (0.0293253s)]]
[[gmp_int][61.4272 (0.145376s)][41.6319 (0.147123s)][14.9744 (0.150405s)][9.64857 (0.150338s)][5.46649 (0.160306s)]]
[[tommath_int][145.509 (0.344367s)][93.9055 (0.331853s)][35.0456 (0.352003s)][22.7371 (0.354275s)][19.1373 (0.561207s)]]
]
[table Operator |
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00295261s)][[*1] (0.00560832s)][[*1] (0.0127056s)][[*1] (0.0200759s)][[*1] (0.034651s)]]
[[gmp_int][14.1091 (0.0416586s)][8.52475 (0.0478096s)][4.74593 (0.0602998s)][4.19694 (0.0842575s)][3.85525 (0.133588s)]]
[[tommath_int][44.8889 (0.132539s)][25.2503 (0.141612s)][11.0488 (0.140382s)][7.39273 (0.148416s)][9.75809 (0.338127s)]]
]
[table Operator |(int)
[[Backend][64 Bits][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[fixed_int][[*1] (0.00244005s)][[*1] (0.0040142s)][[*1] (0.00983777s)][[*1] (0.0155223s)][[*1] (0.0293444s)]]
[[gmp_int][64.6148 (0.157663s)][34.5827 (0.138822s)][14.2764 (0.140448s)][10.3248 (0.160264s)][5.33565 (0.156572s)]]
[[tommath_int][137.825 (0.3363s)][81.1074 (0.325581s)][34.8737 (0.343079s)][22.3727 (0.347276s)][18.912 (0.554963s)]]
]
[endsect]

[endsect]

[section:map Roadmap]

[section:hist History]

[endsect]

[section:todo TODO]

More a list of what ['could] be done, rather than what ['should] be done (which may be a much smaller list!).

* Add backend support for libdecNumber.
* Add an adapter backend for complex number types.

[endsect]

[endsect]