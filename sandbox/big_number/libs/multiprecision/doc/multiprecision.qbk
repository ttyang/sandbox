[/ 
  Copyright 2011 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[library Boost.Multiprecision
    [quickbook 1.5]
    [copyright 2002-2012 John Maddock and Christopher Kormanyos]
    [purpose Multiprecision Number library]
    [license
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [Maddock, John], [Kormanyos, Christopher]]
    [/last-revision $Date: 2011-07-08 18:51:46 +0100 (Fri, 08 Jul 2011) $]
]

[include html4_symbols.qbk]
[import ../example/gmp_snips.cpp]
[import ../example/mpfr_snips.cpp]
[import ../example/cpp_dec_float_snips.cpp]
[import ../example/tommath_snips.cpp]
[import ../example/cpp_int_snips.cpp]
[import ../example/random_snips.cpp]
[import ../example/safe_prime.cpp]
[import ../example/mixed_integer_arithmetic.cpp]

[template mpfr[] [@http://www.mpfr.org MPFR]]
[template gmp[] [@http://gmplib.org GMP]]
[template mpf_class[] [@http://gmplib.org/manual/C_002b_002b-Interface-Floats.html#C_002b_002b-Interface-Floats mpf_class]]
[template mpfr_class[] [@http://math.berkeley.edu/~wilken/code/gmpfrxx/ mpfr_class]]
[template mpreal[] [@http://www.holoborodko.com/pavel/mpfr/ mpreal]]
[template mpir[] [@http://mpir.org/ MPIR]]
[template tommath[] [@http://libtom.org/?page=features&newsitems=5&whatfile=ltm libtommath]]

[template super[x]'''<superscript>'''[x]'''</superscript>''']
[template sub[x]'''<subscript>'''[x]'''</subscript>''']

[template equation[name]  '''<inlinemediaobject>
<imageobject role="html">
<imagedata fileref="../'''[name]'''.png"></imagedata>
</imageobject>
<imageobject role="print">
<imagedata fileref="../'''[name]'''.svg"></imagedata>
</imageobject>
</inlinemediaobject>''']

[def __cpp_int [link boost_multiprecision.tut.ints.cpp_int cpp_int]]
[def __gmp_int [link boost_multiprecision.tut.ints.gmp_int gmp_int]]
[def __tom_int [link boost_multiprecision.tut.ints.tom_int tom_int]]
[def __gmp_float [link boost_multiprecision.tut.floats.gmp_float gmp_float]]
[def __mpf_float [link boost_multiprecision.tut.floats.gmp_float gmp_float]]
[def __mpfr_float_backend [link boost_multiprecision.tut.floats.mpfr_float mpfr_float]]
[def __cpp_dec_float [link boost_multiprecision.tut.floats.cpp_dec_float cpp_dec_float]]
[def __gmp_rational [link boost_multiprecision.tut.rational.gmp_rational gmp_rational]]
[def __cpp_rational [link boost_multiprecision.tut.rational.cpp_rational cpp_rational]]
[def __tommath_rational [link boost_multiprecision.tut.rational.tommath_rational tommath_rational]]

[section:intro Introduction]

The Multiprecision Library provides ['User-defined] integer, rational and floating-point C++ types which
try to emulate as closely as practicable the C++ built-in types, but provide for more range and
precision.  Depending upon the number type, precision may be arbitrarily large (limited only by available memory),
fixed at compile time values, for example 50 decimal
digits, or a variable controlled at run-time by member functions.  The types are
expression-template-enabled for better performance than naive user-defined types.

The Multiprecision library comes in two distinct parts:

* An expression-template-enabled front-end `number`
that handles all the operator overloading, expression evaluation optimization, and code reduction.
* A selection of back-ends that implement the actual arithmetic operations, and need conform only to the
reduced interface requirements of the front-end.

Separation of front-end and back-end allows use of highly refined, but restricted license libraries
where possible, but provides Boost license alternatives for users who must have a portable
unconstrained license.  Which is to say some back-ends rely on 3rd party libraries, but a header-only Boost license version is always
available (if somewhat slower).

Should you just wish to cut to the chase and use a fully Boost-licensed number type, then skip to
__cpp_int for multiprecision integers, __cpp_dec_float for multiprecision floating point types
and __cpp_rational for rational types.

The library is often used via one of the predefined typedefs: for example if you wanted an [@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision]
integer type using [gmp] as the underlying implementation then you could use:

   #include <boost/multiprecision/gmp.hpp>  // Defines the wrappers around the GMP library's types

   boost::multiprecision::mpz_int myint;    // Arbitrary precision integer type.

Alternatively, you can compose your own multiprecision type, by combining `number` with one of the
predefined back-end types.  For example, suppose you wanted a 300 decimal digit floating-point type
based on the [mpfr] library. In this case, there's no predefined typedef with that level of precision,
so instead we compose our own:

   #include <boost/multiprecision/mpfr.hpp>  // Defines the Backend type that wraps MPFR

   namespace mp = boost::multiprecision;     // Reduce the typing a bit later...

   typedef mp::number<mp::mpfr_float_backend<300> >  my_float;

   my_float a, b, c; // These variables have 300 decimal digits precision

We can repeat the above example, but with the expression templates disabled (for faster compile times, but slower runtimes)
by passing a second template argument to `number`:

   #include <boost/multiprecision/mpfr.hpp>  // Defines the Backend type that wraps MPFR

   namespace mp = boost::multiprecision;     // Reduce the typing a bit later...

   typedef mp::number<mp::mpfr_float_backend<300>, et_off>  my_float;

   my_float a, b, c; // These variables have 300 decimal digits precision

We can also mix arithmetic operations between different types, provided there is an unambiguous implicit conversion from one
type to the other:

   #include <boost/multiprecision/cpp_int.hpp>

   namespace mp = boost::multiprecision;     // Reduce the typing a bit later...

   mp::int128_t a(3), b(4);
   mp::int512_t c(50), d;

   d = c * a;   // OK, result of mixed arithmetic is an int512_t

Conversions are also allowed:

   d = a; // OK, widening conversion.
   d = a * b;  // OK, can convert from an expression template too.

However conversions that are inherently lossy are either declared explicit or else forbidden altogether:

   d = 3.14;  // Error implicit conversion from float not allowed.
   d = static_cast<mp::int512_t>(3.14);  // OK explicit construction is allowed

Mixed arithmetic will fail if the conversion is either ambiguous or explicit:

   number<cpp_int_backend<>, et_off> a(2);
   number<cpp_int_backend<>, et_on>  b(3);

   b = a * b; // Error, implicit conversion could go either way.
   b = a * 3.14; // Error, no operator overload if the conversion would be explicit.

[h4 Move Semantics]

On compilers that support rvalue-references, class `number` is move-enabled if the underlying backend is.

In addition the non-expression template operator overloads (see below) are move aware and have overloads 
that look something like:

   template <class B>
   number<B, et_off> operator + (number&& a, const number& b)
   {
       return std::move(a += b);
   }

These operator overloads ensure that many expressions can be evaluated without actually generating any temporaries.
However, there are still many simple expressions such as:

   a = b * c;

Which don't noticeably benefit from move support.  Therefore, optimal performance comes from having both
move-support, and expression templates enabled.

Note that while "moved-from" objects are left in a sane state, they have an unspecified value, and the only permitted 
operations on them are destruction or the assignment of a new value.  Any other operation should be considered
a programming error and all of our backends will trigger an assertion if any other operation is attempted.  This behavior
allows for optimal performance on move-construction (i.e. no allocation required, we just take ownership of the existing
object's internal state), while maintaining usability in the standard library containers.

[h4 Expression Templates]

Class `number` is expression-template-enabled: that means that rather than having a multiplication
operator that looks like this:

   template <class Backend>
   number<Backend> operator * (const number<Backend>& a, const number<Backend>& b)
   {
      number<Backend> result(a);
      result *= b;
      return result;
   }

Instead the operator looks more like this:

   template <class Backend>
   ``['unmentionable-type]`` operator * (const number<Backend>& a, const number<Backend>& b);

Where the "unmentionable" return type is an implementation detail that, rather than containing the result
of the multiplication, contains instructions on how to compute the result.  In effect it's just a pair
of references to the arguments of the function, plus some compile-time information that stores what the operation
is.

The great advantage of this method is the ['elimination of temporaries]: for example the "naive" implementation
of `operator*` above, requires one temporary for computing the result, and at least another one to return it.  It's true 
that sometimes this overhead can be reduced by using move-semantics, but it can't be eliminated completely.  For example, 
lets suppose we're evaluating a polynomial via Horner's method, something like this:

    T a[7] = { /* some values */ };
    //....
    y = (((((a[6] * x + a[5]) * x + a[4]) * x + a[3]) * x + a[2]) * x + a[1]) * x + a[0];

If type `T` is a `number`, then this expression is evaluated ['without creating a single temporary value].  In contrast,
if we were using the [mpfr_class] C++ wrapper for [mpfr] - then this expression would result in no less than 11
temporaries (this is true even though [mpfr_class] does use expression templates to reduce the number of temporaries somewhat).  Had
we used an even simpler wrapper around [mpfr] like [mpreal] things would have been even worse and no less that 24 temporaries
are created for this simple expression (note - we actually measure the number of memory allocations performed rather than 
the number of temporaries directly, note also that the [mpf_class] wrapper that will be supplied with GMP-5.1 reduces the number of 
temporaries to pretty much zero).  Note that if we compile with expression templates disabled and rvalue-reference support
on, then actually still have no wasted memory allocations as even though temporaries are created, their contents are moved
rather than copied.
[footnote The actual number generated will depend on the compiler, how well it optimises the code, and whether it supports
rvalue references.  The number of 11 temporaries was generated with Visual C++ 10]

[important
Expression templates can radically reorder the operations in an expression, for example:

   a = (b * c) * a;

Will get transformed into:

   a *= c;
   a *= b;

If this is likely to be an issue for a particular application, then they should be disabled.
]

This library also extends expression template support to standard library functions like `abs` or `sin` with `number`
arguments.  This means that an expression such as:

   y = abs(x);

can be evaluated without a single temporary being calculated.  Even expressions like:

   y = sin(x);

get this treatment, so that variable 'y' is used as "working storage" within the implementation of `sin`,
thus reducing the number of temporaries used by one.  Of course, should you write:

   x = sin(x);

Then we clearly can't use `x` as working storage during the calculation, so then a temporary variable
is created in this case.

Given the comments above, you might be forgiven for thinking that expression-templates are some kind of universal-panacea:
sadly though, all tricks like this have their downsides.  For one thing, expression template libraries
like this one, tend to be slower to compile than their simpler cousins, they're also harder to debug
(should you actually want to step through our code!), and rely on compiler optimizations being turned
on to give really good performance.  Also, since the return type from expressions involving `number`s
is an "unmentionable implementation detail", you have to be careful to cast the result of an expression
to the actual number type when passing an expression to a template function.  For example, given:

   template <class T>
   void my_proc(const T&);

Then calling:

   my_proc(a+b);

Will very likely result in obscure error messages inside the body of `my_proc` - since we've passed it
an expression template type, and not a number type.  Instead we probably need:

   my_proc(my_number_type(a+b));

Having said that, these situations don't occur that often - or indeed not at all for non-template functions.
In addition, all the functions in the Boost.Math library will automatically convert expression-template arguments
to the underlying number type without you having to do anything, so:

   mpfr_float_100 a(20), delta(0.125);
   boost::math::gamma_p(a, a + delta);

Will work just fine, with the `a + delta` expression template argument getting converted to an `mpfr_float_100`
internally by the Boost.Math library.

One other potential pitfall that's only possible in C++11: you should never store an expression template using:

   auto my_expression = a + b - c;

unless you're absolutely sure that the lifetimes of `a`, `b` and `c` will outlive that of `my_expression`.

And finally... the performance improvements from an expression template library like this are often not as
dramatic as the reduction in number of temporaries would suggest.  For example if we compare this library with 
[mpfr_class] and [mpreal], with all three using the underlying [mpfr] library at 50 decimal digits precision then
we see the following typical results for polynomial execution:

[table Evaluation of Order 6 Polynomial.
[[Library][Relative Time][Relative number of memory allocations]]
[[number][1.0 (0.00793s)][1.0 (2996 total)]]
[[[mpfr_class]][1.2 (0.00931s)][4.3 (12976 total)]]
[[[mpreal]][1.9 (0.0148s)][9.3 (27947 total)]]
]

As you can see, the execution time increases a lot more slowly than the number of memory allocations.  There are 
a number of reasons for this:

* The cost of extended-precision multiplication and division is so great, that the times taken for these tend to
swamp everything else.
* The cost of an in-place multiplication (using `operator*=`) tends to be more than an out-of-place
`operator*` (typically `operator *=` has to create a temporary workspace to carry out the multiplication, where
as `operator*` can use the target variable as workspace).  Since the expression templates carry out their
magic by converting out-of-place operators to in-place ones, we necessarily take this hit.  Even so the
transformation is more efficient than creating the extra temporary variable, just not by as much as
one would hope.

Finally, note that `number` takes a second template argument, which, when set to `et_off` disables all
the expression template machinery.  The result is much faster to compile, but slower at runtime.

We'll conclude this section by providing some more performance comparisons between these three libraries,
again, all are using [mpfr] to carry out the underlying arithmetic, and all are operating at the same precision
(50 decimal digits):

[table Evaluation of Boost.Math's Bessel function test data
[[Library][Relative Time][Relative Number of Memory Allocations]]
[[mpfr_float_50]                            [1.0 (5.66s)] [1.0 (1611963)]]
[[number<mpfr_float_backend<50>, et_off>[br](but with rvalue reference support)]   
                                            [1.10 (6.25s)][2.64 (4260868)]]
[[[mpfr_class]]                             [1.09 (6.16s)][2.45 (3948316)]]
[[[mpreal]]                                 [1.65 (9.34s)][8.21 (13226029)]]
]

[table Evaluation of Boost.Math's Non-Central T distribution test data
[[Library][Relative Time][Relative Number of Memory Allocations]]
[[number]                                   [1.0 (257s)][1.0 (127710873)]]
[[number<mpfr_float_backend<50>, et_off>[br](but with rvalue reference support)]   
                                            [1.0 (257s)][1.2 (156797871)]]
[[[mpfr_class]]                             [1.1 (280s)][2.1 (268336640)]]
[[[mpreal]]                                 [1.4 (363s)][3.6 (466960653)]]
]

The above results were generated on Win32 compiling with Visual C++ 2010, all optimizations on (/Ox),
with MPFR 3.0 and MPIR 2.3.0.

[endsect]

[section:tut Tutorial]

In order to use this library you need to make two choices: what kind of number do I want, and
which back-end do I want to perform the actual arithmetic?

[section:ints Integer Types]

The following back-ends provide integer arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`cpp_int`][boost/multiprecision/cpp_int.hpp][2][None]
            [Very versatile, Boost licensed, all C++ integer type which support both [@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision] and fixed precision integer types.][Slower than [gmp], though typically not as slow as [tommath]]]
[[`gmp_int`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient back-end.][Dependency on GNU licensed [gmp] library.]]
[[`tom_int`][boost/multiprecision/tommath.hpp][2][[tommath]][Public domain back-end with no licence restrictions.][Slower than [gmp].]]
]

[section:cpp_int cpp_int]

`#include <boost/multiprecision/cpp_int.hpp>`

   namespace boost{ namespace multiprecision{

   typedef unspecified-type limb_type;

   enum cpp_integer_type    { signed_magnitude, unsigned_magnitude };
   enum cpp_int_check_type  { checked, unchecked };

   template <unsigned MinDigits = 0, 
             unsigned MaxDits = 0, 
             cpp_integer_type SignType = signed_magnitude, 
             cpp_int_check_type Checked = unchecked, 
             class Allocator = std::allocator<limb_type> >
   class cpp_int_backend;
   //
   // Expression templates default to et_off if there is no allocator:
   //
   template <unsigned MinDigits, unsigned MaxDigits, cpp_integer_type SignType, cpp_int_check_type Checked>
   struct expression_template_default<cpp_int_backend<MinDigits, MaxDigits, SignType, Checked, void> >
   { static const expression_template_option value = et_off; };

   typedef number<cpp_int_backend<> >              cpp_int;    // arbitrary precision integer
   typedef rational_adapter<cpp_int_backend<> >    cpp_rational_backend;
   typedef number<cpp_rational_backend>            cpp_rational; // arbitrary precision rational number

   // Fixed precision unsigned types:
   typedef number<cpp_int_backend<128, 128, unsigned_magnitude, unchecked, void> >   uint128_t;
   typedef number<cpp_int_backend<256, 256, unsigned_magnitude, unchecked, void> >   uint256_t;
   typedef number<cpp_int_backend<512, 512, unsigned_magnitude, unchecked, void> >   uint512_t;
   typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, unchecked, void> > uint1024_t;

   // Fixed precision signed types:
   typedef number<cpp_int_backend<128, 128, signed_magnitude, unchecked, void> >     int128_t;
   typedef number<cpp_int_backend<256, 256, signed_magnitude, unchecked, void> >     int256_t;
   typedef number<cpp_int_backend<512, 512, signed_magnitude, unchecked, void> >     int512_t;
   typedef number<cpp_int_backend<1024, 1024, signed_magnitude, unchecked, void> >   int1024_t;

   // Over again, but with checking enabled this time:
   typedef number<cpp_int_backend<0, 0, signed_magnitude, checked> >                 checked_cpp_int;
   typedef rational_adapter<cpp_int_backend<0, 0, signed_magnitude, checked> >       checked_cpp_rational_backend;
   typedef number<cpp_rational_backend>                                              checked_cpp_rational;

   // Checked fixed precision unsigned types:
   typedef number<cpp_int_backend<128, 128, unsigned_magnitude, checked, void> >     checked_uint128_t;
   typedef number<cpp_int_backend<256, 256, unsigned_magnitude, checked, void> >     checked_uint256_t;
   typedef number<cpp_int_backend<512, 512, unsigned_magnitude, checked, void> >     checked_uint512_t;
   typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, checked, void> >   checked_uint1024_t;

   // Fixed precision signed types:
   typedef number<cpp_int_backend<128, 128, signed_magnitude, checked, void> >       checked_int128_t;
   typedef number<cpp_int_backend<256, 256, signed_magnitude, checked, void> >       checked_int256_t;
   typedef number<cpp_int_backend<512, 512, signed_magnitude, checked, void> >       checked_int512_t;
   typedef number<cpp_int_backend<1024, 1024, signed_magnitude, checked, void> >     checked_int1024_t;

   }} // namespaces

The `cpp_int_backend` type is normally used via one of the convenience typedefs given above.  

This back-end is the "Swiss Army Knife" of integer types as it can represent both fixed and 
[@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision]
integer types, and both signed and unsigned types.  There are five template arguments:

[variablelist
[[MinBits][Determines the number of Bits to store directly within the object before resorting to dynamic memory
           allocation.  When zero, this field is determined automatically based on how many bits can be stored
           in union with the dynamic storage header: setting a larger value may improve performance as larger integer
           values will be stored internally before memory allocation is required.]]
[[MaxBits][Determines the maximum number of bits to be stored in the type: resulting in a fixed precision type.
           When this value is the same as MinBits, then the Allocator parameter is ignored, as no dynamic
           memory allocation will ever be performed: in this situation the Allocator parameter should be set to
           type `void`.  Note that this parameter should not be used simply to prevent large memory
           allocations, not only is that role better performed by the allocator, but fixed precision
           integers have a tendency to allocate all of MaxBits of storage more often than one would expect.]]
[[SignType][Determines whether the resulting type is signed or not.  Note that for 
[@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision] types
          this parameter must be `signed_magnitude`.  For fixed precision
          types then this type may be either `signed_magnitude` or `unsigned_magnitude`.]]
[[Checked][This parameter has two values: `checked` or `unchecked`.  See below.]]
[[Allocator][The allocator to use for dynamic memory allocation, or type `void` if MaxBits == MinBits.]]
]

When the template parameter Checked is set to `checked` then the result is a ['checked-integer], checked 
and unchecked integers have the following properties:

[table
[[Condition][Checked-Integer][Unchecked-Integer]]
[[Numeric overflow in fixed precision arithmetic][Throws a `std::overflow_error`.][Performs arithmetic modulo 2[super MaxBits]]]
[[Constructing an integer from a value that can not be represented in the target type][Throws a `std::range_error`.]
[Converts the value modulo 2[super MaxBits], signed to unsigned conversions extract the last MaxBits bits of the
2's complement representation of the input value.]]
[[Unsigned subtraction yielding a negative value.][Throws a `std::range_error`.][Yields the value that would
result from treating the unsigned type as a 2's complement signed type.]]
[[Attempting a bitwise operation on a negative value.][Throws a `std::range_error`][Yields the value, but not the bit pattern,
that would result from performing the operation on a 2's complement integer type.]]
]

Things you should know when using this type:

* Default constructed `cpp_int_backend`s have the value zero.
* Division by zero results in a `std::overflow_error` being thrown.
* Construction from a string that contains invalid non-numeric characters results in a `std::runtime_error` being thrown.
* Since the precision of `cpp_int_backend` is necessarily limited when the allocator parameter is void, 
care should be taken to avoid numeric overflow when using this type
unless you actually want modulo-arithmetic behavior.
* The type uses a sign-magnitude representation internally, so type `int128_t` has 128-bits of precision plus an extra sign bit.
In this respect the behaviour of these types differs from built-in 2's complement types.  In might be tempting to use a
127-bit type instead, and indeed this does work, but behaviour is still slightly different from a 2's complement built-in type
as the min and max values are identical (apart from the sign), where as they differ by one for a true 2's complement type.
That said it should be noted that there's no requirement for built-in types to be 2's complement either - it's simply that this
is the most common format by far.
* Attempting to print negative values as either an Octal or Hexadecimal string results in a `std::runtime_error` being thrown,
this is a direct consequence of the sign-magnitude representation.
* The fixed precision types `[checked_][u]intXXX_t` have expression template support turned off - it seems to make little 
difference to the performance of these types either way - so we may as well have the faster compile times by turning
the feature off.
* Unsigned types support subtraction - the result is "as if" a 2's complement operation had been performed as long as they are not 
 ['checked-integers] (see above).
 In other words they behave pretty much as a built in integer type would in this situation.  So for example if we were using
 `uint128_t` then `uint128_t(1)-4` would result in the value `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD`
 of type `uint128_t`.  However, had this operation been performed on `checked_uint128_t` then a `std::range_error` would have
 been thrown.
* Unary negation of unsigned types results in a compiler error (static assertion).
* This backend supports rvalue-references and is move-aware, making instantiations of `number` on this backend move aware.
* When used at fixed precision, the size of this type is always one machine word larger than you would expect for an N-bit integer: 
the extra word stores both the sign, and how many machine words in the integer are actually in use.  
The latter is an optimisation for larger fixed precision integers, so that a 1024-bit integer has almost the same performance
characterists as a 128-bit integer, rather than being 4 times slower for addition and 16 times slower for multiplication
 (assuming the values involved would always fit in 128 bits).
Typically this means you can use
an integer type wide enough for the "worst case senario" with only minor performance degradation even if most of the time
the arithmetic could in fact be done with a narrower type.
* When used at fixed precision and MaxBits is smaller than the number of bits in the largest native integer type, then
internally `cpp_int_backend` switches to a "trivial" implementation where it is just a thin wrapper around a single
integer.  Note that it will still be slightly slower than a bare native integer, as it emulates a 
signed-magnitude representation rather than simply using the platforms native sign representation: this ensures
there is no step change in behavior as a cpp_int grows in size.
 

[h5 Example:]

[cpp_int_eg]

[endsect]

[section:gmp_int gmp_int]

`#include <boost/multiprecision/gmp.hpp>`

   namespace boost{ namespace multiprecision{

   class gmp_int;

   typedef number<gmp_int >         mpz_int;

   }} // namespaces

The `gmp_int` back-end is used via the typedef `boost::multiprecision::mpz_int`.  It acts as a thin wrapper around the [gmp] `mpz_t`
to provide an integer type that is a drop-in replacement for the native C++ integer types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, type `mpz_int` is copy constructible and assignable from:

* The [gmp] native types: `mpf_t`, `mpz_t`, `mpq_t`.
* Instances of `number<T>` that are wrappers around those types: `number<gmp_float<N> >`, `number<gmp_rational>`.

It's also possible to access the underlying `mpz_t` via the `data()` member function of `gmp_int`.

Things you should know when using this type:

* No changes are made to the GMP library's global settings - so you can safely mix this type with
existing code that uses [gmp].
* Default constructed `gmp_int`s have the value zero (this is GMP's default behavior).
* Formatted IO for this type does not support octal or hexadecimal notation for negative values, 
as a result performing formatted output on this type when the argument is negative and either of the flags
`std::ios_base::oct` or `std::ios_base::hex` are set, will result in a `std::runtime_error` will be thrown.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be interpreted 
as a valid integer.
* Division by zero results in a `std::overflow_error` being thrown.
* Although this type is a wrapper around [gmp] it will work equally well with [mpir].  Indeed use of [mpir]
is recommended on Win32.
* This backend supports rvalue-references and is move-aware, making instantiations of `number` on this backend move aware.

[h5 Example:]

[mpz_eg]

[endsect]

[section:tom_int tom_int]

`#include <boost/multiprecision/tommath.hpp>`

   namespace boost{ namespace multiprecision{

   class tommath_int;

   typedef number<tommath_int >         tom_int;

   }} // namespaces

The `tommath_int` back-end is used via the typedef `boost::multiprecision::tom_int`.  It acts as a thin wrapper around the [tommath] `tom_int`
to provide an integer type that is a drop-in replacement for the native C++ integer types, but with unlimited precision.

Things you should know when using this type:

* Default constructed objects have the value zero (this is [tommath]'s default behavior).
* Although `tom_int` is mostly a drop in replacement for the builtin integer types, it should be noted that it is a
rather strange beast as it's a signed type that is not a 2's complement type.  As a result the bitwise operations
`| & ^` will throw a `std::runtime_error` exception if either of the arguments is negative.  Similarly the complement
operator`~` is deliberately not implemented for this type.
* Formatted IO for this type does not support octal or hexadecimal notation for negative values, 
as a result performing formatted output on this type when the argument is negative and either of the flags
`std::ios_base::oct` or `std::ios_base::hex` are set, will result in a `std::runtime_error` will be thrown.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be interpreted 
as a valid integer.
* Division by zero results in a `std::overflow_error` being thrown.

[h5 Example:]

[tommath_eg]

[endsect]

[section:egs Examples]

[import ../example/integer_examples.cpp]

[section:factorials Factorials]
[FAC1]
[endsect]

[section:bitops Bit Operations]
[BITOPS]
[endsect]

[endsect]

[endsect]

[section:floats Floating Point Numbers]

The following back-ends provide floating point arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`cpp_dec_float<N>`][boost/multiprecision/cpp_dec_float.hpp][10][None][Header only, all C++ implementation. Boost licence.][Approximately 2x slower than the [mpfr] or [gmp] libraries.]]
[[`mpf_float<N>`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient back-end.][Dependency on GNU licensed [gmp] library.]]
[[`mpfr_float<N>`][boost/multiprecision/mpfr.hpp][2][[gmp] and [mpfr]][Very fast and efficient back-end, with its own standard library implementation.][Dependency on GNU licensed [gmp] and [mpfr] libraries.]]
]

[section:cpp_dec_float cpp_dec_float]

`#include <boost/multiprecision/cpp_dec_float.hpp>`

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10, class ExponentType = boost::int32_t, class Allocator = void>
   class cpp_dec_float;

   typedef number<cpp_dec_float<50> > cpp_dec_float_50;
   typedef number<cpp_dec_float<100> > cpp_dec_float_100;

   }} // namespaces

The `cpp_dec_float` back-end is used in conjunction with `number`: It acts as an entirely C++ (header only and dependency free)
floating-point number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `cpp_dec_float` can be used at fixed precision by specifying a non-zero `Digits10` template parameter.  
The typedefs `cpp_dec_float_50` and `cpp_dec_float_100` provide arithmetic types at 50 and 100 decimal digits precision
respectively.  Optionally, you can specify an integer type to use for the exponent, this defaults to a 32-bit integer type
which is more than large enough for the vast majority of use cases, but larger types such as `long long` can also be specified
if you need a truely huge exponent range.

Normally `cpp_dec_float` allocates no memory: all of the space required for its digits are allocated
directly within the class.  As a result care should be taken not to use the class with too high a digit count
as stack space requirements can grow out of control.  If that represents a problem then providing an allocator
as the final template parameter causes `cpp_dec_float` to dynamically allocate the memory it needs: this
significantly reduces the size of `cpp_dec_float` and increases the viable upper limit on the number of digits
at the expense of performance.  However, please bear in mind that arithmetic operations rapidly become ['very] expensive
as the digit count grows: the current implementation really isn't optimized or designed for large digit counts.

There is full standard library and `numeric_limits` support available for this type.

Things you should know when using this type:

* Default constructed `cpp_dec_float`s have a value of zero.
* The radix of this type is 10.  As a result it can behave subtly differently from base-2 types.
* The type has a number of internal guard digits over and above those specified in the template argument.
Normally these should not be visible to the user.
* The type supports both infinities and NaN's.  An infinity is generated whenever the result would overflow,
and a NaN is generated for any mathematically undefined operation.
* There is a `std::numeric_limits` specialisation for this type.
* Any `number` instantiated on this type, is convertible to any other `number` instantiated on this type - 
for example you can convert from `number<cpp_dec_float<50> >` to `number<cpp_dec_float<SomeOtherValue> >`.
Narrowing conversions are truncating and `explicit`.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be interpreted
as a valid floating point number.
* The actual precision of a `cpp_dec_float` is always slightly higher than the number of digits specified in
the template parameter, actually how much higher is an implementation detail but is always at least 8 decimal 
digits.
* Operations involving `cpp_dec_float` are always truncating.  However, note that since their are guard digits 
in effect, in practice this has no real impact on accuracy for most use cases.

[h5 cpp_dec_float example:]

[cpp_dec_float_eg]

[endsect]

[section:gmp_float gmp_float]

`#include <boost/multiprecision/gmp.hpp>`

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class gmp_float;

   typedef number<gmp_float<50> >    mpf_float_50;
   typedef number<gmp_float<100> >   mpf_float_100;
   typedef number<gmp_float<500> >   mpf_float_500;
   typedef number<gmp_float<1000> >  mpf_float_1000;
   typedef number<gmp_float<0> >     mpf_float;

   }} // namespaces

The `gmp_float` back-end is used in conjunction with `number` : it acts as a thin wrapper around the [gmp] `mpf_t`
to provide an real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `gmp_float` can be used at fixed precision by specifying a non-zero `Digits10` template parameter, or
at variable precision by setting the template argument to zero.  The typedefs mpf_float_50, mpf_float_100,
mpf_float_500, mpf_float_1000 provide arithmetic types at 50, 100, 500 and 1000 decimal digits precision
respectively.  The typedef mpf_float provides a variable precision type whose precision can be controlled via the
`number`s member functions.

[note This type only provides standard library and `numeric_limits` support when the precision is fixed at compile time.]

As well as the usual conversions from arithmetic and string types, instances of `number<mpf_float<N> >` are
copy constructible and assignable from:

* The [gmp] native types `mpf_t`, `mpz_t`, `mpq_t`.
* The `number` wrappers around those types: `number<mpf_float<M> >`, `number<gmp_int>`, `number<gmp_rational>`.

It's also possible to access the underlying `mpf_t` via the `data()` member function of `gmp_float`.

Things you should know when using this type:

* Default constructed `gmp_float`s have the value zero (this is the [gmp] library's default behavior).
* No changes are made to the [gmp] library's global settings, so this type can be safely mixed with
existing [gmp] code.
* This backend supports rvalue-references and is move-aware, making instantiations of `number` on this backend move aware.
* It is not possible to round-trip objects of this type to and from a string and get back
exactly the same value.  This appears to be a limitation of [gmp].
* Since the underlying [gmp] types have no notion of infinities or NaN's, care should be taken
to avoid numeric overflow or division by zero.  That latter will result in a std::overflow_error being thrown, 
while generating excessively large exponents may result in instability of the underlying [gmp]
library (in testing, converting a number with an excessively large or small exponent 
to a string caused [gmp] to segfault).
* This type can equally be used with [mpir] as the underlying implementation - indeed that is
the recommended option on Win32.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be interpreted 
as a valid floating point number.
* Division by zero results in a `std::overflow_error` being thrown.

[h5 [gmp] example:]

[mpf_eg]

[endsect]

[section:mpfr_float mpfr_float]

`#include <boost/multiprecision/mpfr_float.hpp>`

   namespace boost{ namespace multiprecision{

   enum mpfr_allocation_type
   {
      allocate_stack,
      allocate_dynamic
   };

   template <unsigned Digits10, mpfr_allocation_type AllocateType = allocate_dynamic>
   class mpfr_float_backend;

   typedef number<mpfr_float_backend<50> >    mpfr_float_50;
   typedef number<mpfr_float_backend<100> >   mpfr_float_100;
   typedef number<mpfr_float_backend<500> >   mpfr_float_500;
   typedef number<mpfr_float_backend<1000> >  mpfr_float_1000;
   typedef number<mpfr_float_backend<0> >     mpfr_float;

   typedef number<mpfr_float_backend<50, allocate_stack> >    static_mpfr_float_50;
   typedef number<mpfr_float_backend<100, allocate_stack> >   static_mpfr_float_100;

   }} // namespaces

The `mpfr_float_backend` type is used in conjunction with `number`: It acts as a thin wrapper around the [mpfr] `mpfr_t`
to provide an real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `mpfr_float_backend` can be used at fixed precision by specifying a non-zero `Digits10` template parameter, or
at variable precision by setting the template argument to zero.  The typedefs mpfr_float_50, mpfr_float_100,
mpfr_float_500, mpfr_float_1000 provide arithmetic types at 50, 100, 500 and 1000 decimal digits precision
respectively.  The typedef mpfr_float provides a variable precision type whose precision can be controlled via the
`number`s member functions.

In addition the second template parameter lets you choose between dynamic allocation (the default,
and uses MPFR's normal allocation routines),
or stack allocation (where all the memory required for the underlying data types is stored
within `mpfr_float_backend`).  The latter option can result in significantly faster code, at the
expense of growing the size of `mpfr_float_backend`.  It can only be used at fixed precision, and
should only be used for lower digit counts.  Note that we can not guarentee that using `allocate_stack`
won't cause any calls to mpfr's allocation routines, as mpfr may call these inside it's own code.
The following table gives an idea of the performance tradeoff's at 50 decimal digits 
precision[footnote Compiled with VC++10 and /Ox, with MPFR-3.0.0 and MPIR-2.3.0]:

[table
[[Type][Bessel function evaluation, relative times]]
[[`number<mpfr_float_backend<50, allocate_static>, et_on>`][1.0 (5.5s)]]
[[`number<mpfr_float_backend<50, allocate_static>, et_off>`][1.05 (5.8s)]]
[[`number<mpfr_float_backend<50, allocate_dynamic>, et_on>`][1.05 (5.8s)]]
[[`number<mpfr_float_backend<50, allocate_dynamic>, et_off>`][1.16 (6.4s)]]
]

[note This type only provides `numeric_limits` support when the precision is fixed at compile time.]

As well as the usual conversions from arithmetic and string types, instances of `number<mpfr_float_backend<N> >` are
copy constructible and assignable from:

* The [gmp] native types `mpf_t`, `mpz_t`, `mpq_t`.
* The [mpfr] native type `mpfr_t`.
* The `number` wrappers around those types: `number<mpfr_float_backend<M> >`, `number<mpf_float<M> >`, `number<gmp_int>`, `number<gmp_rational>`.

It's also possible to access the underlying `mpf_t` via the data() member function of `gmp_float`.

Things you should know when using this type:

* A default constructed `mpfr_float_backend` is set to a NaN (this is the default [mpfr] behavior).
* All operations use round to nearest.
* No changes are made to [gmp] or [mpfr] global settings, so this type can coexist with existing
[mpfr] or [gmp] code.
* The code can equally use [mpir] in place of [gmp] - indeed that is the preferred option on Win32.
* This backend supports rvalue-references and is move-aware, making instantiations of `number` on this backend move aware.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be interpreted 
as a valid floating point number.
* Division by zero results in an infinity.

[h5 [mpfr] example:]

[mpfr_eg]

[endsect]

[section:fp_eg Examples]

[import ../example/floating_point_examples.cpp]

[section:aos Area of Circle]

[AOS1]
[AOS2]
[AOS3]

[endsect]

[section:jel Defining a Lambda Function.]

[JEL]

[endsect]

[section:nd Calculating a Derivative]

[ND1]
[ND2]
[ND3]

[endsect]

[section:gi Calculating an Integral]

[GI1]
[GI2]

[endsect]

[section:poly_eg Polynomial Evaluation]

[POLY]

[endsect]

[endsect]

[endsect]

[section:rational Rational Number Types]

The following back-ends provide rational number arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`cpp_rational`][boost/multiprecision/cpp_int.hpp][2][None][An all C++ Boost-licensed implementation.][Slower than [gmp].]]
[[`gmp_rational`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient back-end.][Dependency on GNU licensed [gmp] library.]]
[[`tommath_rational`][boost/multiprecision/tommath.hpp][2][[tommath]][All C/C++ implementation that's Boost Software Licence compatible.][Slower than [gmp].]]
[[`rational_adapter`][boost/multiprecision/rational_adapter.hpp][N/A][none][All C++ adapter that allows any integer back-end type to be used as a rational type.][Requires an underlying integer back-end type.]]
[[`boost::rational`][boost/rational.hpp][N/A][None][A C++ rational number type that can used with any `number` integer type.][The expression templates used by `number` end up being "hidden" inside `boost::rational`: performance may well suffer as a result.]]
]

[section:cpp_rational cpp_rational]

`#include <boost/multiprecision/cpp_int.hpp>`

   namespace boost{ namespace multiprecision{

   typedef rational_adapter<cpp_int_backend<> >    cpp_rational_backend;

   typedef number<cpp_rational_backend>         cpp_rational;

   }} // namespaces

The `cpp_rational_backend` type is used via the typedef `boost::multiprecision::cpp_rational`.  It provides
a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, instances of `cpp_rational` are copy constructible
and assignable from type `cpp_int`.

There is also a two argument constructor that accepts a numerator and denominator: both of type `cpp_int`.

There are also non-member functions:

   cpp_int numerator(const cpp_rational&);
   cpp_int denominator(const cpp_rational&);

which return the numerator and denominator of the number.

Things you should know when using this type:

* Default constructed `cpp_rational`s have the value zero.
* Division by zero results in a `std::overflow_error` being thrown.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be
interpreted as a valid rational number.

[h5 Example:]

[cpp_rational_eg]

[endsect]

[section:gmp_rational gmp_rational]

`#include <boost/multiprecision/gmp.hpp>`

   namespace boost{ namespace multiprecision{

   class gmp_rational;

   typedef number<gmp_rational >         mpq_rational;

   }} // namespaces

The `gmp_rational` back-end is used via the typedef `boost::multiprecision::mpq_rational`.  It acts as a thin wrapper around the [gmp] `mpq_t`
to provide a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, instances of `number<gmp_rational>` are copy constructible
and assignable from:

* The [gmp] native types: `mpz_t`, `mpq_t`.
* `number<gmp_int>`.

There is also a two-argument constructor that accepts a numerator and denominator (both of type `number<gmp_int>`).

There are also non-member functions:

   mpz_int numerator(const mpq_rational&);
   mpz_int denominator(const mpq_rational&);

which return the numerator and denominator of the number.

It's also possible to access the underlying `mpq_t` via the `data()` member function of `mpq_rational`.

Things you should know when using this type:

* Default constructed `mpq_rational`s have the value zero (this is the [gmp] default behavior).
* Division by zero results in a `std::overflow_error` being thrown.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be
interpreted as a valid rational number.
* No changes are made to the [gmp] library's global settings, so this type can coexist with existing
[gmp] code.
* The code can equally be used with [mpir] as the underlying library - indeed that is the preferred option on Win32.

[h5 Example:]

[mpq_eg]

[endsect]

[section:tommath_rational tommath_rational]

`#include <boost/multiprecision/tommath.hpp>`

   namespace boost{ namespace multiprecision{

   typedef rational_adpater<tommath_int>        tommath_rational;
   typedef number<tommath_rational >         tom_rational;

   }} // namespaces

The `tommath_rational` back-end is used via the typedef `boost::multiprecision::tom_rational`.  It acts as a thin wrapper around 
`boost::rational<tom_int>`
to provide a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

The advantage of using this type rather than `boost::rational<tom_int>` directly, is that it is expression-template enabled,
greatly reducing the number of temporaries created in complex expressions.

There are also non-member functions:

   tom_int numerator(const tom_rational&);
   tom_int denominator(const tom_rational&);

which return the numerator and denominator of the number.

Things you should know when using this type:

* Default constructed `tom_rational`s have the value zero (this the inherited Boost.Rational behavior).
* Division by zero results in a `std::overflow_error` being thrown.
* Conversion from a string results in a `std::runtime_error` being thrown if the string can not be
interpreted as a valid rational number.
* No changes are made to [tommath]'s global state, so this type can safely coexist with other [tommath] code.
* Performance of this type has been found to be pretty poor - this need further investigation - but it appears that Boost.Rational
needs some improvement in this area.

[h5 Example:]

[mp_rat_eg]

[endsect]

[section:br Use With Boost.Rational]

All of the integer types in this library can be used as template arguments to `boost::rational<IntType>`.

Note that using the library in this way largely negates the effect of the expression templates in `number`.

[endsect]

[section:rational_adapter rational_adapter]

   namespace boost{ namespace multiprecision{

   template <class IntBackend> 
   class rational_adpater;

   }}

The class template `rational_adapter` is a back-end for `number` which converts any existing integer back-end
into a rational-number back-end.

So for example, given an integer back-end type `MyIntegerBackend`, the use would be something like:

   typedef number<MyIntegerBackend>                    MyInt;
   typedef number<rational_adapter<MyIntegerBackend> > MyRational;

   MyRational r = 2;
   r /= 3;
   MyInt i = numerator(r);
   assert(i == 2);

[endsect]

[endsect]

[section:conversions Constructing and Interconverting Between Number Types]

All of the number types that are based on `number` have certain conversion rules in common.
In particular:

* Any number type can be constructed (or assigned) from any builtin arithmetic type, as long
  as the conversion isn't lossy (for example float to int conversion):

   cpp_dec_float_50 df(0.5);   // OK construction from double
   cpp_int          i(450);    // OK constructs from signed int
   cpp_int          j = 3.14;  // Error, lossy conversion.

* A number can be explicitly constructed from an arithmetic type, even when the conversion is lossy:

   cpp_int          i(3.14);       // OK explicit conversion
   i = static_cast<cpp_int>(3.14)  // OK explicit conversion
   i.assign(3.14);                 // OK, explicit assign and avoid a temporary from the cast above
   i = 3.14;                       // Error, no implicit assignment operator for lossy conversion.
   cpp_int          j = 3.14;      // Error, no implicit constructor for lossy conversion.

* A `number` can be converted to any built in type, via the `convert_to` member function:

   mpz_int z(2);
   int i = z.template convert_to<int>(); // sets i to 2

Additional conversions may be supported by particular backends.

* A `number` can be converted to any built in type, via an explicit conversion operator: 
this functionality is only available on compilers supporting C++11's explicit conversion syntax.

   mpz_int z(2);
   int i = z;                     // Error, implicit conversion not allowed.
   int j = static_cast<int>(z);   // OK explicit conversion.

* Any number type can be ['explicitly] constructed (or assigned) from a `const char*` or a `std::string`:

   // pi to 50 places from a string:
   cpp_dec_float_50 df("3.14159265358979323846264338327950288419716939937510");
   // Integer type will automatically detect "0x" and "0" prefixes and parse the string accordingly:
   cpp_int          i("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000");
   // Invalid input always results in a std::runtime_error being thrown:
   i = static_cast<cpp_int>("3.14");
   // implicit conversions from strings are not allowed:
   i = "23"; // Error, no assignment operator for implicit conversion from string
   // assign member function, avoids having to create a temporary via a static_cast:
   i.assign("23");  // OK

* Any number type will interoperate with the builtin types in arithmetic expressions as long as the conversions
are not lossy:

   // pi to 50 places from a string:
   cpp_dec_float_50 df = "3.14159265358979323846264338327950288419716939937510";
   // Multiply by 2 - using an integer literal here is usually more efficient
   // than constructing a temporary:
   df *= 2;

   // You can't mix integer types with floats though:
   cpp_int i = 2;
   i *= 3.14;  // Error, no *= operator will be found.

* Any number type can be streamed to and from the C++ iostreams:
   

   cpp_dec_float_50 df = "3.14159265358979323846264338327950288419716939937510";
   // Now print at full precision:
   std::cout << std::setprecision(std::numeric_limits<cpp_dec_float_50>::max_digits10)
      << df << std::endl
   cpp_int i = 1;
   i <<= 256;
   // Now print in hex format with prefix:
   std::cout << std::hex << std::showbase << i << std::endl;

* Interconversions between number types of the same family are allowed and are implicit conversions if no
loss of precision is involved, and explicit if it is:

   int128_t     i128 = 0;
   int266_t     i256 = i128;  // OK implicit widening conversion
   i128_t            = i256;  // Error, no assignment operator found, narrowing conversion is explict
   i128_t            = static_cast<int128_t>(i256); // OK, explicit narrowing conversion

   mpz_int      z    = 0;
   mpf_float    f    = z;    // OK, GMP handles this conversion natively, and it's not lossy and therefore implicit
   
   mpf_float_50 f50  = 2;
   f                 = f50;  // OK, conversion from fixed to variable precision, f will have 50 digits precision.
   f50               = f;    // Error, conversion from variable to fixed precision is potentially lossy, explicit cast required.

* Some interconversions between number types are completely generic, and are always available, albeit the conversions are always ['explicit]:

   cpp_int cppi(2);
   // We can always convert between numbers of the same category - 
   // int to int, rational to rational, or float to float, so this is OK
   // as long as we use an explicit conversion:
   mpz_int z(cppi);
   // We can always promote from int to rational, int to float, or rational to float:
   cpp_rational     cppr(cppi);  // OK, int to rational
   cpp_dec_float_50 df(cppi);    // OK, int to float
   df                  = static_cast<cpp_dec_float_50>(cppr);  // OK, explicit rational to float conversion
   // However narrowing and/or implicit conversions always fail:
   cppi                =   df;    // Compiler error, conversion not allowed

* Other interconversions may be allowed as special cases, whenever the backend allows it:

   mpf_t     m;           // Native GMP type.
   mpf_init_set_ui(m, 0); // set to a value;
   mpf_float i(m);        // copies the value of the native type.

More information on what additional types a backend supports conversions from are given in the tutorial for each backend.
The converting constructor will be implict if the backend's converting constructor is also implicit, and explicit if the
backends converting constructor is also explicit.

[endsect]

[section:random Generating Random Numbers]

Random numbers are generated in conjunction with Boost.Random.  However, since Boost.Random is unaware
of [@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision] numbers, it's necessary to include the header:

   #include <boost/multiprecision/random.hpp>

In order to act as a bridge between the two libraries.

Integers with /N/ random bits are generated using `independent_bits_engine`:

[random_eg1]

Alternatively we can generate integers in a given range using `uniform_int_distribution`, this will
invoke the underlying engine multiple times to build up the required number of bits in the result:

[random_eg2]

Floating point values in \[0,1) are generated using `uniform_01`, the trick here is to ensure
that the underlying generator produces as many random bits as there are digits in the floating
point type.  As above `independent_bits_engine` can be used for this purpose, note that we also have to
convert decimal digits (in the floating point type) to bits (in the random number generator):

[random_eg3]

Finally, we can modify the above example to produce numbers distributed according to some distribution:

[random_eg4]

[endsect]

[section:primetest Primality Testing]

The library implements a Miller-Rabin test for primality:

   #include <boost/multiprecision/miller_rabin.hpp>

   template <class Backend, expression_template_option ExpressionTemplates, class Engine>
   bool miller_rabin_test(const number<Backend, ExpressionTemplates>& n, unsigned trials, Engine& gen);

   template <class Backend, expression_template_option ExpressionTemplates, class Engine>
   bool miller_rabin_test(const number<Backend, ExpressionTemplates>& n, unsigned trials);

These functions perform a Miller-Rabin test for primality, if the result is `false` then /n/ is definitely composite,
while if the result is `true` then /n/ is prime with probability ['0.25^trials].  The algorithm used performs some
trial divisions to exclude small prime factors, does one Fermat test to exclude many more composites, and then
uses the Miller-Rabin algorithm straight out of
Knuth Vol 2, which recommends 25 trials for a pretty strong likelihood that /n/ is prime.

The third optional argument is for a Uniform Random Number Generator from Boost.Random.  When not provided the `mt19937`
generator is used.   Note that when producing random primes then you should probably use a different random number generator 
to produce candidate prime numbers for testing, than is used internally by `miller_rabin_test` for determining 
whether the value is prime.  It also helps of course to seed the generators with some source of randomness.

The following example searches for a prime `p` for which `(p-1)/2` is also probably prime:

[safe_prime]

[endsect]

[section:lits Literal Types and `constexpr` Support]

There is limited support for `constexpr` in the library, currently the `number` front end supports `constexpr`
on default construction and all forwarding constructors, but not on any of the non-member operators.  So if 
some type `B` is a literal type, then `number<B>` is also a literal type, and you will be able to 
compile-time-construct such a type from any literal that `B` is compile-time-constructible from.
However, you will not be able to perform compile-time arithmetic on such types.

Currently the only backend type provided by the library that is also a literal type are instantiations
of `cpp_int_backend` where the Allocator parameter is type `void`, and the Checked parameter is 
`boost::multiprecision::unchecked`.

For example:

   using namespace boost::multiprecision;

   constexpr int128_t            i = 0;     // OK, fixed precision int128_t has no allocator.
   constexpr uint1024_t          j = 0xFFFFFFFF00000000uLL;  // OK, fixed precision uint1024_t has no allocator.

   constexpr checked_uint128_t   k = -1; // Error, checked type is not a literal type as we need runtime error checking.
   constexpr cpp_int             l = 2;  // Error, type is not a literal as it performs memory management.

[endsect]

[section:rounding Rounding Rules for Conversions]

As a general rule, all conversions between unrelated types are performed using basic arithmetic operations, therefore
conversions are either exact, or follow the same rounding rules as arithmetic for the type in question.

The following table summarises the situation for conversions from native types:

[table
[[Backend][Rounding Rules]]
[[__cpp_int][Conversions from integer types are exact if the target has sufficient precision, otherwise they
            truncate to the first 2^MaxBits bits (modulo arithmetic).  Conversions from floating point types
            are truncating to the nearest integer.]]
[[__gmp_int][Conversions are performed by the GMP library except for conversion from `long double` which is truncating.]]
[[__tom_int][Conversions from floating point types are truncating, all others are performed by libtommath and are exact.]]
[[__gmp_float][Conversions are performed by the GMP library except for conversion from `long double` which should be exact
            provided the target type has as much precision as a `long double`.]]
[[__mpfr_float_backend][All conversions are performed by the underlying MPFR library.]]
[[__cpp_dec_float][All conversions are performed using basic arithmetic operations and are truncating.]]
[[__gmp_rational][See __gmp_int]]
[[__cpp_rational][See __cpp_int]]
[[__tommath_rational][See __tom_int]]
]

[endsect]

[section:mixed Mixed Precision Arithmetic]

Mixed precision arithmetic is fully supported by the library, there are two different forms:

* Where the operands are of different precision.
* Where the operands are of the same precision, but yield a higher precision result.

[h4 Mixing Operands of Differing Precision]

If the arguments to a binary operator are of different precision, then the operation is allowed
as long as there is an unambiguous implicit conversion from one argument type to the other.
In all cases the arithmetic is performed "as if" the lower precision type is promoted to the
higher precision type before applying the operator.  However, particular backends may optimise
this and avoid actually creating a temporary if they are able to do so.

For example:

   mpfr_float_50         a(2), b;
   mpfr_float_100        c(3), d;
   static_mpfr_float_50  e(5), f;
   mpz_int               i(20);

   d = a * c;  // OK, result of operand is an mpfr_float_100.
   b = a * c;  // Error, can't convert the result to an mpfr_float_50 as it will lose digits.
   f = a * e;  // Error, operator is ambiguous, result could be of either type.
   f = e * i;  // OK, unambiguous conversion from mpz_int to static_mpfr_float_50

[h4 Operands of the Same Precision]

Sometimes you want to apply an operator to two arguments of the same precision in 
such a way as to obtain a result of higher precision.  The most common situation
occurs with fixed precision integers, where you want to multiply two N-bit numbers
to obtain a 2N-bit result.  This is supported in this library by the following
free functions:

   template <class ResultType, class Source1 class Source2>
   ResultType& add(ResultType& result, const Source1& a, const Source2& b);

   template <class ResultType, class Source1 class Source2>
   ResultType& subtract(ResultType& result, const Source1& a, const Source2& b);

   template <class ResultType, class Source1 class Source2>
   ResultType& multiply(ResultType& result, const Source1& a, const Source2& b);

These functions apply the named operator to the arguments ['a] and ['b] and store the
result in ['result], returning ['result].  In all cases they behave "as if" 
arguments ['a] and ['b] were first promoted to type `ResultType` before applying the
operator, though particular backends may well avoid that step by way of an optimization.

The type `ResultType` must be an instance of class `number`, and the types `Source1` and `Source2`
may be either instances of class `number` or native integer types.  The latter is an optimization
that allows arithmetic to be performed on native integer types producing an extended precision result.

For example:

[mixed_eg]

Produces the output:

[mixed_output]

[h4 Backends With Optimized Mixed Precision Arithmetic]

The following backends have at least some direct support for mixed precision arithmetic, 
and therefore avoid creating unnecessary temporaries when using the interfaces above.
Therefore when using these types it's more efficient to use mixed precision arithmetic, 
than it is to explicitly cast the operands to the result type:

__mpfr_float_backend, __mpf_float, __cpp_int.

[endsect]

[endsect]

[section:ref Reference]

[section:number number]

[h4 Synopsis]

   namespace boost{ namespace multiprecision{

   enum expression_template_option { et_on = 1, et_off = 0 };

   template <class Backend> struct expression_template_default 
   { static const expression_template_option value = et_on; };

   template <class Backend, expression_template_option ExpressionTemplates = expression_template_default<Backend>::value>
   class number
   {
      number();
      number(see-below);
      number& operator=(see-below);
      number& assign(see-below);

      // Member operators
      number& operator+=(const ``['see-below]``&);
      number& operator-=(const ``['see-below]``&);
      number& operator*=(const ``['see-below]``&);
      number& operator/=(const ``['see-below]``&);
      number& operator++();
      number& operator--();
      number  operator++(int);
      number  operator--(int);

      number& operator%=(const ``['see-below]``&);
      number& operator&=(const ``['see-below]``&);
      number& operator|=(const ``['see-below]``&);
      number& operator^=(const ``['see-below]``&);
      number& operator<<=(const ``['integer-type]``&);
      number& operator>>=(const ``['integer-type]``&);

      // Use in Boolean context:
      operator ``['convertible-to-bool-type]``()const;
      // swap:
      void swap(number& other);
      // Sign:
      bool is_zero()const;
      int sign()const;
      // string conversion:
      std::string str()const;
      // Generic conversion mechanism
      template <class T>
      T convert_to()const;
      template <class T>
      explicit operator T ()const;
      // precision control:
      static unsigned default_precision();
      static void default_precision(unsigned digits10);
      unsigned precision()const;
      void precision(unsigned digits10);
      // Comparison:
      int compare(const number<Backend>& o)const;
      template <class V>
      typename enable_if<is_convertible<V, number<Backend, ExpressionTemplates> >, int>::type 
         compare(const V& o)const;
      // Access to the underlying implementation:
      Backend& backend();
      const Backend& backend()const;
   };

   // Non member operators:
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator*(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator/(const ``['see-below]``&, const ``['see-below]``&);
   // Integer only operations:
   ``['unmentionable-expression-template-type]`` operator%(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator&(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator|(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator^(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator<<(const ``['see-below]``&, const ``['integer-type]``&);
   ``['unmentionable-expression-template-type]`` operator>>(const ``['see-below]``&, const ``['integer-type]``&);
   // Comparison operators:
   bool operator==(const ``['see-below]``&, const ``['see-below]``&);
   bool operator!=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator< (const ``['see-below]``&, const ``['see-below]``&);
   bool operator> (const ``['see-below]``&, const ``['see-below]``&);
   bool operator<=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator>=(const ``['see-below]``&, const ``['see-below]``&);

   // Swap:
   template <class Backend, expression_template_option ExpressionTemplates>
   void swap(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b);

   // iostream support:
   template <class Backend, expression_template_option ExpressionTemplates>
   std::ostream& operator << (std::ostream& os, const number<Backend, ExpressionTemplates>& r);
   std::ostream& operator << (std::ostream& os, const ``['unmentionable-expression-template-type]``& r);
   template <class Backend, expression_template_option ExpressionTemplates>
   std::istream& operator >> (std::istream& is, number<Backend, ExpressionTemplates>& r);

   // Arithmetic with a higher precision result:
   template <class ResultType, class Source1 class Source2>
   ResultType& add(ResultType& result, const Source1& a, const Source2& b);
   template <class ResultType, class Source1 class Source2>
   ResultType& subtract(ResultType& result, const Source1& a, const Source2& b);
   template <class ResultType, class Source1 class Source2>
   ResultType& multiply(ResultType& result, const Source1& a, const Source2& b);

   // Non-member function standard library support:
   ``['unmentionable-expression-template-type]``    abs    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fabs   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sqrt   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    floor  (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ceil   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    trunc  (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    itrunc (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ltrunc (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lltrunc(const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    round  (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    iround (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lround (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    llround(const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    exp    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log10    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cos    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sin    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tan    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    acos   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    asin   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cosh   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sinh   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tanh   (const ``['number-or-expression-template-type]``&);

   ``['unmentionable-expression-template-type]``    ldexp (const ``['number-or-expression-template-type]``&, int);
   ``['unmentionable-expression-template-type]``    frexp (const ``['number-or-expression-template-type]``&, int*);
   ``['unmentionable-expression-template-type]``    pow   (const ``['number-or-expression-template-type]``&, const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fmod  (const ``['number-or-expression-template-type]``&, const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan2 (const ``['number-or-expression-template-type]``&, const ``['number-or-expression-template-type]``&);

   // Traits support:
   template <class T>
   struct component_type;
   template <class T>
   struct number_category;
   template <class T>
   struct is_number;
   template <class T>
   struct is_number_expression;

   // Integer specific functions:
   ``['unmentionable-expression-template-type]``    pow(const ``['number-or-expression-template-type]``&, unsigned);
   ``['unmentionable-expression-template-type]``    powm(const ``['number-or-expression-template-type]``& b, const ``['number-or-expression-template-type]``& p, const ``['number-or-expression-template-type]``& m);
   template <class Backend, expression_template_option ExpressionTemplates>
   void divide_qr(const ``['number-or-expression-template-type]``& x, const ``['number-or-expression-template-type]``& y,
                  number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r);
   template <class Integer>
   Integer integer_modulus(const ``['number-or-expression-template-type]``& x, Integer val);
   unsigned lsb(const ``['number-or-expression-template-type]``& x);
   template <class Backend, class ExpressionTemplates>
   bool bit_test(const number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Backend, class ExpressionTemplates>
   number<Backend, ExpressionTemplates>& bit_set(number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Backend, class ExpressionTemplates>
   number<Backend, ExpressionTemplates>& bit_unset(number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Backend, class ExpressionTemplates>
   number<Backend, ExpressionTemplates>& bit_flip(number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Engine>
   bool miller_rabin_test(const ``['number-or-expression-template-type]``& n, unsigned trials, Engine& gen);
   bool miller_rabin_test(const ``['number-or-expression-template-type]``& n, unsigned trials);

   // Rational number support:
   typename component_type<``['number-or-expression-template-type]``>::type numerator  (const ``['number-or-expression-template-type]``&);
   typename component_type<``['number-or-expression-template-type]``>::type denominator(const ``['number-or-expression-template-type]``&);

   }} // namespaces

   namespace boost{ namespace math{

   // Boost.Math interoperability functions:
   int                                              fpclassify     (const ``['number-or-expression-template-type]``&, int);
   bool                                             isfinite       (const ``['number-or-expression-template-type]``&, int);
   bool                                             isnan          (const ``['number-or-expression-template-type]``&, int);
   bool                                             isinf          (const ``['number-or-expression-template-type]``&, int);
   bool                                             isnormal       (const ``['number-or-expression-template-type]``&, int);

   }} // namespaces

   // numeric_limits support:
   namespace std{

   template <class Backend, expression_template_option ExpressionTemplates>
   struct numeric_limits<boost::multiprecision<Backend, ExpressionTemplates> >
   {
      /* Usual members here */
   };

   }

[h4 Description]

   enum expression_template_option { et_on = 1, et_off = 0 };

This enumerated type is used to specify whether expression templates are turned on (et_on) or turned off (et_off).

   template <class Backend> struct expression_template_default 
   { static const expression_template_option value = et_on; };

This traits class specifies the default expression template option to be used with a particular Backend type.
It defaults to `et_on`.

   template <class Backend, expression_template_option ExpressionTemplates = expression_template_default<Backend>::value>
   class number;

Class `number` has two template arguments:

[variablelist
[[Backend][The actual arithmetic back-end that does all the work.]]
[[ExpressionTemplates][A Boolean value: when `et_on`, then expression templates are enabled, otherwise when set to `et_off` they are disabled.
   The default for this parameter is computed via the traits class `expression_template_default` whose member `value` defaults to `et_on` unless
   the the traits class is specialized for a particular backend.]]
]

   number();
   number(see-below);
   number& operator=(see-below);
   number& assign(see-below);

Type `number` is default constructible, and both copy constructible and assignable from:

* Itself.
* An expression template which is the result of one of the arithmetic operators.
* Any builtin arithmetic type, as long as the result would not be lossy (for example float to integer conversion).
* Any type that the Backend is implicitly constructible or assignable from.
* An rvalue reference to another `number`.  Move-semantics are used for construction if the backend also
supports rvalue reference construction.  In the case of assignment, move semantics are always supported
when the argument is an rvalue reference irrespective of the backend.
* Any type in the same family, as long as no loss of precision is involved.  For example from `int128_t` to `int256_t`,
or `cpp_dec_float_50` to `cpp_dec_float_100`.

Type `number` is explicitly constructible from:

* Any type mentioned above.
* A `std::string` or any type which is convertible to `const char*`.
* Any arithmetic type (including those that would result in lossy conversions).
* Any type in the same family, including those that result in loss of precision.
* Any type that the Backend is explicitly constructible from.
* Any pair of types for which a generic interconversion exists: that is from integer to integer, integer
to rational, integer to float, rational to rational, rational to float, or float to float.

The assign member function is available for any type for which an explicit converting constructor exists.
It is intended to be used where a temporary generated from an explicit assignment would be expensive, for example:

   mpfr_float_50    f50;
   mpfr_float_100   f100;

   f50 = static_cast<mpfr_float_50>(f100);  // explicit cast create a temporary
   f50.assign(f100);                        // explicit call to assign create no temporary

In addition, if the type has multiple components (for example rational or complex number types), then there is a
two argument constructor:

   number(arg1, arg2);

Where the two args must either be arithmetic types, or types that are convertible to the two components of `this`.

      number& operator+=(const ``['see-below]``&);
      number& operator-=(const ``['see-below]``&);
      number& operator*=(const ``['see-below]``&);
      number& operator/=(const ``['see-below]``&);
      number& operator++();
      number& operator--();
      number  operator++(int);
      number  operator--(int);
      // Integer only operations:
      number& operator%=(const ``['see-below]``&);
      number& operator&=(const ``['see-below]``&);
      number& operator|=(const ``['see-below]``&);
      number& operator^=(const ``['see-below]``&);
      number& operator<<=(const ``['integer-type]``&);
      number& operator>>=(const ``['integer-type]``&);

These operators all take their usual arithmetic meanings.

The arguments to these operators is either:

* Another `number<Backend, ExpressionTemplates>`.
* An expression template derived from `number<Backend>`.
* Any type implicitly convertible to `number<Backend, ExpressionTemplates>`, including some other instance of class `number`.

For the left and right shift operations, the argument must be a builtin
integer type with a positive value (negative values result in a `std::runtime_error` being thrown).

      operator ``['convertible-to-bool-type]``()const;

Returns an ['unmentionable-type] that is usable in Boolean contexts (this allows `number` to be used in any
Boolean context - if statements, conditional statements, or as an argument to a logical operator - without
type `number` being convertible to type `bool`.

This operator also enables the use of `number` with any of the following operators:
`!`, `||`, `&&` and `?:`.

      void swap(number& other);

Swaps `*this` with `other`.

      bool is_zero()const;

Returns `true` is `*this` is zero, otherwise `false`.

      int sign()const;

Returns a value less than zero if `*this` is negative, a value greater than zero if `*this` is positive, and zero
if `*this` is zero.

      std::string str(unsigned precision, bool scientific = true)const;

Returns the number formatted as a string, with at least /precision/ digits, and in scientific format
if /scientific/ is true.

      template <class T>
      T convert_to()const;

      template <class T>
      explicit operator T ()const;

Provides a generic conversion mechanism to convert `*this` to type `T`.  Type `T` may be any arithmetic type.
Optionally other types may also be supported by specific `Backend` types.


      static unsigned default_precision();
      static void default_precision(unsigned digits10);
      unsigned precision()const;
      void precision(unsigned digits10);

These functions are only available if the Backend template parameter supports runtime changes to precision.  They get and set
the default precision and the precision of `*this` respectively.

      int compare(const number<Backend, ExpressionTemplates>& o)const;
      template <class V>
      typename enable_if<is_convertible<V, number<Backend, ExpressionTemplates> >, int>::type 
         compare(const V& other)const;

Returns:

* A value less that 0 for `*this < other`
* A value greater that 0 for `*this > other`
* Zero for `*this == other`

      Backend& backend();
      const Backend& backend()const;

Returns the underlying back-end instance used by `*this`.

[h4 Non-member operators]

   // Non member operators:
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator*(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator/(const ``['see-below]``&, const ``['see-below]``&);
   // Integer only operations:
   ``['unmentionable-expression-template-type]`` operator%(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator&(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator|(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator^(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator<<(const ``['see-below]``&, const ``['integer-type]``&);
   ``['unmentionable-expression-template-type]`` operator>>(const ``['see-below]``&, const ``['integer-type]``&);
   // Comparison operators:
   bool operator==(const ``['see-below]``&, const ``['see-below]``&);
   bool operator!=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator< (const ``['see-below]``&, const ``['see-below]``&);
   bool operator> (const ``['see-below]``&, const ``['see-below]``&);
   bool operator<=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator>=(const ``['see-below]``&, const ``['see-below]``&);

These operators all take their usual arithmetic meanings.

The arguments to these functions must contain at least one of the following:

* A `number`.
* An expression template type derived from `number`.
* Any type for which `number` has an implicit constructor - for example a builtin arithmetic type.

The return type of these operators is either:

* An ['unmentionable-type] expression template type when `ExpressionTemplates` is `true`.
* Type `number<Backend, et_off>` when `ExpressionTemplates` is `false`.
* Type `bool` if the operator is a comparison operator.

Finally note that the second argument to the left and right shift operations must be a builtin integer type, 
and that the argument must be positive (negative arguments result in a `std::runtime_error` being thrown).

[h4 swap]

   template <class Backend, ExpressionTemplates>
   void swap(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b);

Swaps `a` and `b`.

[h4 Iostream Support]

   template <class Backend, expression_template_option ExpressionTemplates>
   std::ostream& operator << (std::ostream& os, const number<Backend, ExpressionTemplates>& r);
   template <class Unspecified...>
   std::ostream& operator << (std::ostream& os, const unmentionable-expression-template& r);
   template <class Backend, expression_template_option ExpressionTemplates>
   inline std::istream& operator >> (std::istream& is, number<Backend, ExpressionTemplates>& r)

These operators provided formatted input-output operations on `number` types, and expression templates derived from them.

It's down to the back-end type to actually implement string conversion.  However, the back-ends provided with
this library support all of the iostream formatting flags, field width and precision settings.

[h4 Arithmetic with a higher precision result]

   template <class ResultType, class Source1 class Source2>
   ResultType& add(ResultType& result, const Source1& a, const Source2& b);

   template <class ResultType, class Source1 class Source2>
   ResultType& subtract(ResultType& result, const Source1& a, const Source2& b);

   template <class ResultType, class Source1 class Source2>
   ResultType& multiply(ResultType& result, const Source1& a, const Source2& b);

These functions apply the named operator to the arguments ['a] and ['b] and store the
result in ['result], returning ['result].  In all cases they behave "as if" 
arguments ['a] and ['b] were first promoted to type `ResultType` before applying the
operator, though particular backends may well avoid that step by way of an optimization.

The type `ResultType` must be an instance of class `number`, and the types `Source1` and `Source2`
may be either instances of class `number` or native integer types.  The latter is an optimization
that allows arithmetic to be performed on native integer types producing an extended precision result.

[h4 Non-member standard library function support]

   ``['unmentionable-expression-template-type]``    abs    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fabs   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sqrt   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    floor  (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ceil   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    trunc  (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    itrunc (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ltrunc (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lltrunc(const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    round  (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    iround (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lround (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    llround(const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    exp    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log10    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cos    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sin    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tan    (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    acos   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    asin   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cosh   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sinh   (const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tanh   (const ``['number-or-expression-template-type]``&);

   ``['unmentionable-expression-template-type]``    ldexp (const ``['number-or-expression-template-type]``&, int);
   ``['unmentionable-expression-template-type]``    frexp (const ``['number-or-expression-template-type]``&, int*);
   ``['unmentionable-expression-template-type]``    pow   (const ``['number-or-expression-template-type]``&, const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fmod  (const ``['number-or-expression-template-type]``&, const ``['number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan2 (const ``['number-or-expression-template-type]``&, const ``['number-or-expression-template-type]``&);

These functions all behave exactly as their standard library C++11 counterparts do: their argument is either an instance of `number` or
an expression template derived from it; If the argument is of type `number<Backend, et_off>` then that is also the return type,
otherwise the return type is an expression template.

These functions are normally implemented by the Backend type.  However, default versions are provided for Backend types that
don't have native support for these functions.  Please note however, that this default support requires the precision of the type
to be a compile time constant - this means for example that the [gmp] MPF Backend will not work with these functions when that type is 
used at variable precision.

Also note that with the exception of `abs` that these functions can only be used with floating-point Backend types (if any other types
such as fixed precision or complex types are added to the library later, then these functions may be extended to support those number types).

The precision of these functions is generally deterimined by the backend implementation.  For example the precision
of these functions when used with __mpfr_float_backend is determined entirely by [mpfr].  When these functions use our own
implementations, the accuracy of the transcendal functions is generally a few epsilon.  Note however, that the trigonmetrical
functions incur the usual accuracy loss when reducing arguments by large multiples of [pi].  Also note that both __mpf_float
and __cpp_dec_float have a number of guard digits beyond their stated precision, so the error rates listed for these
are in some sense artificially low.

The following table shows the error rates we observe for these functions with various backend types, functions not listed
here are exact (tested on Win32 with VC++10, MPFR-3.0.0, MPIR-2.1.1):

[table
[[Function][mpfr_float_50][mpf_float_50][cpp_dec_float_50]]
[[sqrt][1eps][0eps][0eps]]
[[exp][1eps][0eps][0eps]]
[[log][1eps][0eps][0eps]]
[[log10][1eps][0eps][0eps]]
[[cos][700eps][0eps][0eps]]
[[sin][1eps][0eps][0eps]]
[[tan][0eps][0eps][0eps]]
[[acos][0eps][0eps][0eps]]
[[asin][0eps][0eps][0eps]]
[[atan][1eps][0eps][0eps]]
[[cosh][1045eps[footnote It's likely that the inherent error in the input values to our test cases are to blame here.]][0eps][0eps]]
[[sinh][2eps][0eps][0eps]]
[[tanh][1eps][0eps][0eps]]
[[pow][0eps][4eps][3eps]]
[[atan2][1eps][0eps][0eps]]
]
[h4 Traits Class Support]

   template <class T>
   struct component_type;

If this is a type with multiple components (for example rational or complex types), then this trait has a single member
`type` that is the type of those components.

   template <class T>
   struct number_category;

A traits class that inherits from `mpl::int_<N>` where `N` is one of the enumerated values `number_kind_integer`, `number_kind_floating_point`,
`number_kind_rational`, `number_kind_fixed_point`, or `number_kind_unknown`.  This traits class is specialized for any type that has
`std::numeric_limits` support as well as for classes in this library: which means it can be used for generic code that must work
with built in arithmetic types as well as multiprecision ones.

   template <class T>
   struct is_number;

A traits class that inherits from `mpl::true_` if T is an instance of `number<>`, otherwise from `mpl::false_`.

   template <class T>
   struct is_number_expression;

A traits class that inherits from `mpl::true_` if T is an expression template type derived from `number<>`, otherwise from `mpl::false_`.



[h4 Integer functions]

In addition to functioning with types from this library, these functions are also overloaded for built in integer
types if you include `<boost/multiprecision/integer.hpp>`.  Further, when used with fixed precision types (whether
built in integers or multiprecision ones), the functions will promote to a wider type internally when the algorithm
requires it.  Versions overloaded for built in integer types return that integer type rather than an expression 
template.

   ``['unmentionable-expression-template-type]``    pow(const ``['number-or-expression-template-type]``& b, unsigned p);

Returns ['b[super p]] as an expression template.  Note that this function should be used with extreme care as the result can grow so 
large as to take "effectively forever" to compute, or else simply run the host machine out of memory.  This is the one function in
this category that is not overloaded for built in integer types, further, it's probably not a good idea to use it with
fixed precision `cpp_int`'s either.

   ``['unmentionable-expression-template-type]``    powm(const ``['number-or-expression-template-type]``& b, const ``['number-or-expression-template-type]``& p, const ``['number-or-expression-template-type]``& m);

Returns ['b[super p] mod m] as an expression template.  Fixed precision types are promoted internally to ensure accuracy.

   template <class Backend, expression_template_option ExpressionTemplates>
   void divide_qr(const ``['number-or-expression-template-type]``& x, const ``['number-or-expression-template-type]``& y,
                  number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r);

Divides x by y and returns both the quotient and remainder.  After the call `q = x / y` and `r = x % y`.

   template <class Integer>
   Integer integer_modulus(const ``['number-or-expression-template-type]``& x, Integer val);

Returns the absolute value of `x % val`.

   unsigned lsb(const ``['number-or-expression-template-type]``& x);

Returns the index of the least significant bit that is set to 1.

Throws a `std::range_error` if the argument is <= 0.

   template <class Backend, class ExpressionTemplates>
   bool bit_test(const number<Backend, ExpressionTemplates>& val, unsigned index);

Returns `true` if the bit at /index/ in /val/ is set.

   template <class Backend, class ExpressionTemplates>
   number<Backend, ExpressionTemplates>& bit_set(number<Backend, ExpressionTemplates>& val, unsigned index);

Sets the bit at /index/ in /val/, and returns /val/.

   template <class Backend, class ExpressionTemplates>
   number<Backend, ExpressionTemplates>& bit_unset(number<Backend, ExpressionTemplates>& val, unsigned index);

Unsets the bit at /index/ in /val/, and returns /val/.

   template <class Backend, class ExpressionTemplates>
   number<Backend, ExpressionTemplates>& bit_flip(number<Backend, ExpressionTemplates>& val, unsigned index);

Flips the bit at /index/ in /val/, and returns /val/.

   template <class Engine>
   bool miller_rabin_test(const ``['number-or-expression-template-type]``& n, unsigned trials, Engine& gen);
   bool miller_rabin_test(const ``['number-or-expression-template-type]``& n, unsigned trials);

Tests to see if the number /n/ is probably prime - the test excludes the vast majority of composite numbers
by excluding small prime factors and performing a single Fermat test.  Then performs /trials/ Miller-Rabin
tests.  Returns `false` if /n/ is definitely composite, or `true` if /n/ is probably prime with the
probability of it being composite less than 0.25^trials.  Fixed precision types are promoted internally
to ensure accuracy.

[h4 Rational Number Functions]

   typename component_type<``['number-or-expression-template-type]``>::type numerator  (const ``['number-or-expression-template-type]``&);
   typename component_type<``['number-or-expression-template-type]``>::type denominator(const ``['number-or-expression-template-type]``&);

These functions return the numerator and denominator of a rational number respectively.

[h4 Boost.Math Interoperability Support]

   namespace boost{ namespace math{

   int  fpclassify     (const ``['number-or-expression-template-type]``&, int);
   bool isfinite       (const ``['number-or-expression-template-type]``&, int);
   bool isnan          (const ``['number-or-expression-template-type]``&, int);
   bool isinf          (const ``['number-or-expression-template-type]``&, int);
   bool isnormal       (const ``['number-or-expression-template-type]``&, int);

   }} // namespaces

These floating-point classification functions behave exactly as their Boost.Math equivalents.

Other Boost.Math functions and templates may also be
specialized or overloaded to ensure interoperability.

[h4 std::numeric_limits support]

   namespace std{

   template <class Backend, ExpressionTemplates>
   struct numeric_limits<boost::multiprecision<Backend, ExpressionTemplates> >
   {
      /* Usual members here */
   };

   }

Class template `std::numeric_limits` is specialized for all instantiations of `number` whose precision is known at compile time, plus those
types whose precision is unlimited (though it is much less useful in those cases).  It is not specialized for types
whose precision can vary at compile time (such as `mpf_float`).

[endsect]

[section:cpp_int_ref cpp_int]

   namespace boost{ namespace multiprecision{

   typedef unspecified-type limb_type;

   enum cpp_integer_type    { signed_magnitude, unsigned_magnitude };
   enum cpp_int_check_type  { checked, unchecked };

   template <unsigned MinDigits = 0, 
             unsigned MaxDits = 0, 
             cpp_integer_type SignType = signed_magnitude, 
             cpp_int_check_type Checked = unchecked, 
             class Allocator = std::allocator<limb_type> >
   class cpp_int_backend;
   //
   // Expression templates default to et_off if there is no allocator:
   //
   template <unsigned MinDigits, unsigned MaxDigits, cpp_integer_type SignType, cpp_int_check_type Checked>
   struct expression_template_default<cpp_int_backend<MinDigits, MaxDigits, SignType, Checked, void> >
   { static const expression_template_option value = et_off; };

   typedef number<cpp_int_backend<> >              cpp_int;    // arbitrary precision integer
   typedef rational_adapter<cpp_int_backend<> >    cpp_rational_backend;
   typedef number<cpp_rational_backend>            cpp_rational; // arbitrary precision rational number

   // Fixed precision unsigned types:
   typedef number<cpp_int_backend<128, 128, unsigned_magnitude, unchecked, void> >   uint128_t;
   typedef number<cpp_int_backend<256, 256, unsigned_magnitude, unchecked, void> >   uint256_t;
   typedef number<cpp_int_backend<512, 512, unsigned_magnitude, unchecked, void> >   uint512_t;
   typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, unchecked, void> > uint1024_t;

   // Fixed precision signed types:
   typedef number<cpp_int_backend<128, 128, signed_magnitude, unchecked, void> >     int128_t;
   typedef number<cpp_int_backend<256, 256, signed_magnitude, unchecked, void> >     int256_t;
   typedef number<cpp_int_backend<512, 512, signed_magnitude, unchecked, void> >     int512_t;
   typedef number<cpp_int_backend<1024, 1024, signed_magnitude, unchecked, void> >   int1024_t;

   // Over again, but with checking enabled this time:
   typedef number<cpp_int_backend<0, 0, signed_magnitude, checked> >                 checked_cpp_int;
   typedef rational_adapter<cpp_int_backend<0, 0, signed_magnitude, checked> >       checked_cpp_rational_backend;
   typedef number<cpp_rational_backend>                                              checked_cpp_rational;

   // Checked fixed precision unsigned types:
   typedef number<cpp_int_backend<128, 128, unsigned_magnitude, checked, void> >     checked_uint128_t;
   typedef number<cpp_int_backend<256, 256, unsigned_magnitude, checked, void> >     checked_uint256_t;
   typedef number<cpp_int_backend<512, 512, unsigned_magnitude, checked, void> >     checked_uint512_t;
   typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, checked, void> >   checked_uint1024_t;

   // Fixed precision signed types:
   typedef number<cpp_int_backend<128, 128, signed_magnitude, checked, void> >       checked_int128_t;
   typedef number<cpp_int_backend<256, 256, signed_magnitude, checked, void> >       checked_int256_t;
   typedef number<cpp_int_backend<512, 512, signed_magnitude, checked, void> >       checked_int512_t;
   typedef number<cpp_int_backend<1024, 1024, signed_magnitude, checked, void> >     checked_int1024_t;

   }} // namespaces

Class template `cpp_int_backend` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
Its members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The template arguments are:

[variablelist
[[MinBits][Determines the number of Bits to store directly within the object before resorting to dynamic memory
           allocation.  When zero, this field is determined automatically based on how many bits can be stored
           in union with the dynamic storage header: setting a larger value may improve performance as larger integer
           values will be stored internally before memory allocation is required.]]
[[MaxBits][Determines the maximum number of bits to be stored in the type: resulting in a fixed precision type.
           When this value is the same as MinBits, then the Allocator parameter is ignored, as no dynamic
           memory allocation will ever be performed: in this situation the Allocator parameter should be set to
           type `void`.  Note that this parameter should not be used simply to prevent large memory
           allocations, not only is that role better performed by the allocator, but fixed precision
           integers have a tendency to allocate all of MaxBits of storage more often than one would expect.]]
[[SignType][Determines whether the resulting type is signed or not.  Note that for 
[@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision] types
          this parameter must be `signed_magnitude`.  For fixed precision
          types then this type may be either `signed_magnitude` or `unsigned_magnitude`.]]
[[Checked][This parameter has two values: `checked` or `unchecked`.  See the [link boost_multiprecision.tut.ints.cpp_int tutorial] for more information.]]
[[Allocator][The allocator to use for dynamic memory allocation, or type `void` if MaxBits == MinBits.]]
]

The type of `number_category<cpp_int<Args...> >::type` is `mpl::int_<number_kind_integer>`.

More information on this type can be found in the [link boost_multiprecision.tut.ints.cpp_int tutorial].

[endsect]

[section:gmp_int_ref gmp_int]

   namespace boost{ namespace multiprecision{

   class gmp_int;

   typedef number<gmp_int >         mpz_int;

   }} // namespaces

Class template `gmp_int` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
Its members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The type of `number_category<cpp_int<Args...> >::type` is `mpl::int_<number_kind_integer>`.

More information on this type can be found in the [link boost_multiprecision.tut.ints.gmp_int tutorial].

[endsect]

[section:tom_int_ref tom_int]

   namespace boost{ namespace multiprecision{

   class tommath_int;

   typedef number<tommath_int >         tom_int;

   }} // namespaces

Class template `tommath_int` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
Its members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The type of `number_category<cpp_int<Args...> >::type` is `mpl::int_<number_kind_integer>`.

More information on this type can be found in the [link boost_multiprecision.tut.ints.tom_int tutorial].

[endsect]

[section:mpf_ref gmp_float]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class gmp_float;

   typedef number<gmp_float<50> >    mpf_float_50;
   typedef number<gmp_float<100> >   mpf_float_100;
   typedef number<gmp_float<500> >   mpf_float_500;
   typedef number<gmp_float<1000> >  mpf_float_1000;
   typedef number<gmp_float<0> >     mpf_float;

   }} // namespaces

Class template `gmp_float` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
Its members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The class takes a single template parameter - `Digits10` - which is the number of decimal digits precision the type
should support.  When this parameter is zero, then the precision can be set at runtime via `number::default_precision`
and `number::precision`.  Note that this type does not in any way change the GMP library's global state (for example
it does not change the default precision of the mpf_t data type), therefore you can safely mix this type with existing
code that uses GMP, and also mix `gmp_float`s of differing precision.

The type of `number_category<cpp_int<Args...> >::type` is `mpl::int_<number_kind_floating_point>`.

More information on this type can be found in the [link boost_multiprecision.tut.floats.gmp_float tutorial].

[endsect]

[section:mpfr_ref mpfr_float_backend]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class mpfr_float_backend;

   typedef number<mpfr_float_backend<50> >    mpfr_float_50;
   typedef number<mpfr_float_backend<100> >   mpfr_float_100;
   typedef number<mpfr_float_backend<500> >   mpfr_float_500;
   typedef number<mpfr_float_backend<1000> >  mpfr_float_1000;
   typedef number<mpfr_float_backend<0> >     mpfr_float;

   }} // namespaces

Class template `mpfr_float_backend` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
Its members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The class takes a single template parameter - `Digits10` - which is the number of decimal digits precision the type
should support.  When this parameter is zero, then the precision can be set at runtime via `number::default_precision`
and `number::precision`.  Note that this type does not in any way change the GMP or MPFR library's global state (for example
it does not change the default precision of the mpfr_t data type), therefore you can safely mix this type with existing
code that uses GMP or MPFR, and also mix `mpfr_float_backend`s of differing precision.

The type of `number_category<cpp_int<Args...> >::type` is `mpl::int_<number_kind_floating_point>`.

More information on this type can be found in the [link boost_multiprecision.tut.floats.mpfr_float tutorial].

[endsect]

[section:cpp_dec_ref cpp_dec_float]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class cpp_dec_float;

   typedef number<cpp_dec_float<50> > cpp_dec_float_50;
   typedef number<cpp_dec_float<100> > cpp_dec_float_100;

   }} // namespaces

Class template `cpp_dec_float` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
Its members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The class takes a single template parameter - `Digits10` - which is the number of decimal digits precision the type
should support.  Note that this type does not ever perform any dynamic memory allocation, as a result the `Digits10`
template argument should not be set too high or the class's size will grow unreasonably large.

The type of `number_category<cpp_int<Args...> >::type` is `mpl::int_<number_kind_floating_point>`.

More information on this type can be found in the [link boost_multiprecision.tut.floats.cpp_dec_float tutorial].

[endsect]

[section:internals Internal Support Code]

There are some traits classes which authors of new backends should be aware of:

   namespace boost{ namespace multiprecision{ namespace detail{

   template<typename From, typename To>
   struct is_explicitly_convertible;

   }}}

Inherits from `boost::integral_constant<bool,true>` if type `From` has an explicit conversion from `To`.

For compilers that support C++11 SFINAE-expressions this trait should "just work".  Otherwise it inherits
from `boost::is_convertible<From, To>::type`, and will need to be specialised for Backends that have
constructors marked as `explicit`.

   template <class From, class To>
   struct is_lossy_conversion
   {
      static const bool value = see below;
   };

Member `value` is true if the conversion from `From` to `To` would result in a loss of precision, and `false` otherwise.

The default version of this trait simply checks whether the ['kind] of conversion (for example from a floating point to an integer type)
is inherently lossy.  Note that if either of the types `From` or `To` are of an unknown number category (because `number_category` is not
specialised for that type) then this trait will be `true`.

   template<typename From, typename To>
   struct is_restricted_conversion
   {
      static const bool value = see below;
   };

Member `value` is `true` if `From` is only explicitly convertible to `To` and not implicitly convertible, or
if `is_lossy_conversion<From, To>::value` is `true`.  Otherwise `false`.

Note that while this trait is the ultimate arbiter of which constructors are marked as `explicit` in class `number`,
authors of backend types should generally specialise one of the traits above, rather than this one directly.

   template <class T>
   is_signed_number;
   template <class T>
   is_unsigned_number;

These two traits inherit from either `mpl::true_` or `mpl::false_`, by default types are assumed to be signed unless
`is_unsigned_number` is specialized for that type.

[endsect]

[section:backendconc Backend Requirements]

The requirements on the `Backend` template argument to `number` are split up into
sections: compulsory and optional.

Compulsory requirements have no default implementation in the library, therefore if the feature
they implement is to be supported at all, then they must be implemented by the backend.

Optional requirements have default implementations that are called if the backend doesn't provide
it's own.  Typically the backend will implement these to improve performance.

In the following tables, type B is the `Backend` template argument to `number`, `b` and `b2` are
a variables of type B, `cb`, `cb2` and `cb3` are constant variables of type `const B`,
`rb` is a variable of type `B&&`, `a` and `a2` are variables of Arithmetic type, 
`s` is a variable of type `const char*`, `ui` is a variable of type `unsigned`, `bb` is a variable of type `bool`,
`pa` is a variable of type pointer-to-arithmetic-type, `exp` is a variable of type `B::exp_type`,
`pexp` is a variable of type `B::exp_type*`, `i` is a variable of type `int`, `pi` pointer to a variable of type `int`, 
B2 is another type that meets these requirements, b2 is a variable
of type B2.

[table Compulsory Requirements on the Backend type.
[[Expression][Return Type][Comments][Throws]]
[[`B::signed_types`][`mpl::list<type-list>`][A list of signed integral types that can be assigned to type B.  The types shall be
                   listed in order of size, smallest first, and shall terminate in the type that is `std::intmax_t`.][[space]]]
[[`B::unsigned_types`][`mpl::list<type-list>`][A list of unsigned integral types that can be assigned to type B.  The types shall be
                   listed in order of size, smallest first, and shall terminate in the type that is `std::uintmax_t`.][[space]]]
[[`B::float_types`][`mpl::list<type-list>`][A list of floating-point types that can be assigned to type B.The types shall be
                   listed in order of size, smallest first, and shall terminate in type `long double`.][[space]]]
[[`B::exponent_type`][A signed integral type.][The type of the exponent of type B.  This type is required only for floating point types.][[space]]]
[[`B()`][ ][Default constructor.][[space]]]
[[`B(cb)`][ ][Copy Constructor.][[space]]]
[[`b = b`][`B&`][Assignment operator.][[space]]]
[[`b = a`][`B&`][Assignment from an Arithmetic type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.][[space]]]
[[`b = s`][`B&`][Assignment from a string.][Throws a `std::runtime_error` if the string could not be interpretted as a valid number.]]
[[`b.swap(b)`][`void`][Swaps the contents of its arguments.][`noexcept`]]
[[`cb.str(ui, bb)`][`std::string`][Returns the string representation of `b` with `ui` digits and in scientific format if `bb` is `true`.
                  If `ui` is zero, then returns as many digits as are required to reconstruct the original value.][[space]]]
[[`b.negate()`][`void`][Negates `b`.][[space]]]
[[`cb.compare(cb2)`][`int`][Compares `cb` and `cb2`, returns a value less than zero if `cb < cb2`, a value greater than zero if `cb > cb2` and zero
                   if `cb == cb2`.][`noexcept`]]
[[`cb.compare(a)`][`int`][Compares `cb` and `a`, returns a value less than zero if `cb < a`, a value greater than zero if `cb > a` and zero
                   if `cb == a`.  The type of `a` shall be listed in one of the type lists
                   `B::signed_types`, `B::unsigned_types` or `B::float_types`.][[space]]]
[[`eval_add(b, cb)`][`void`][Adds `cb` to `b`.][[space]]]
[[`eval_subtract(b, cb)`][`void`][Subtracts `cb` from `b`.][[space]]]
[[`eval_multiply(b, cb)`][`void`][Multiplies `b` by `cb`.][[space]]]
[[`eval_divide(b, cb)`][`void`][Divides `b` by `cb`.]
            [`std::overflow_error` if cb has the value zero, and `std::numeric_limits<number<B> >::has_infinity == false`]]
[[`eval_modulus(b, cb)`][`void`][Computes `b %= cb`, only required when `B` is an integer type.]
            [`std::overflow_error` if cb has the value zero.]]
[[`eval_bitwise_and(b, cb)`][`void`][Computes `b &= cb`, only required when `B` is an integer type.][[space]]]
[[`eval_bitwise_or(b, cb)`][`void`][Computes `b |= cb`, only required when `B` is an integer type.][[space]]]
[[`eval_bitwise_xor(b, cb)`][`void`][Computes `b ^= cb`, only required when `B` is an integer type.][[space]]]
[[`eval_complement(b, cb)`][`void`][Computes the ones-complement of `cb` and stores the result in `b`, only required when `B` is an integer type.][[space]]]
[[`eval_left_shift(b, ui)`][`void`][Computes `b <<= ui`, only required when `B` is an integer type.][[space]]]
[[`eval_right_shift(b, ui)`][`void`][Computes `b >>= ui`, only required when `B` is an integer type.][[space]]]
[[`eval_convert_to(pa, cb)`][`void`][Converts `cb` to the type of `*pa` and store the result in `*pa`.  Type `B` shall support
                     conversion to at least types `std::intmax_t`, `std::uintmax_t` and `long long`.
                     Conversion to other arithmetic types can then be synthesised using other operations.
                     Conversions to other types are entirely optional.][[space]]]
[[`eval_frexp(b, cb, pexp)`][`void`][Stores values in `b` and `*pexp` such that the value of `cb` is b * 2[super *pexp], only required when `B` is a floating-point type.][[space]]]
[[`eval_ldexp(b, cb, exp)`][`void`][Stores a value in `b` that is cb * 2[super exp], only required when `B` is a floating-point type.][[space]]]
[[`eval_frexp(b, cb, pi)`][`void`][Stores values in `b` and `*pi` such that the value of `cb` is b * 2[super *pi], only required when `B` is a floating-point type.]
            [`std::runtime_error` if the exponent of cb is too large to be stored in an `int`.]]
[[`eval_ldexp(b, cb, i)`][`void`][Stores a value in `b` that is cb * 2[super i], only required when `B` is a floating-point type.][[space]]]
[[`eval_floor(b, cb)`][`void`][Stores the floor of `cb` in `b`, only required when `B` is a floating-point type.][[space]]]
[[`eval_ceil(b, cb)`][`void`][Stores the ceiling of `cb` in `b`, only required when `B` is a floating-point type.][[space]]]
[[`eval_sqrt(b, cb)`][`void`][Stores the square root of `cb` in `b`, only required when `B` is a floating-point type.][[space]]]
[[`boost::multiprecision::number_category<B>::type`][`mpl::int_<N>`][`N` is one of the values `number_kind_integer`, `number_kind_floating_point`, `number_kind_rational` or `number_kind_fixed_point`.
                                                Defaults to `number_kind_floating_point`.][[space]]]
]

[table Optional Requirements on the Backend Type
[[Expression][Returns][Comments][Throws]]

[[['Construct and assign:]]]
[[`B(rb)`][`B`][Move constructor.  Afterwards variable `rb` shall be in sane state, albeit with unspecified value.
      Only destruction and assignment to the moved-from variable `rb` need be supported after the operation.][`noexcept`]]
[[`b = rb`][`B&`][Move-assign.  Afterwards variable `rb` shall be in sane state, albeit with unspecified value.
      Only destruction and assignment to the moved-from variable `rb` need be supported after the operation.][`noexcept`]]
[[`B(a)`][`B`][Direct construction from an arithmetic type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, this operation is simulated using default-construction followed by assignment.][[space]]]
[[`B(b2)`][`B`][Copy constructor from a different back-end type.  When not provided, a generic interconversion routine is used.
          This constructor may be `explicit` if the corresponding frontend constructor should also be `explicit`.][[space]]]
[[`b = b2`][`b&`][Assignment operator from a different back-end type.  When not provided, a generic interconversion routine is used.][[space]]]
[[`assign_components(b, a, a)`][`void`][Assigns to `b` the two components in the following arguments.  
                           Only applies to rational and complex number types.
                           When not provided, arithmetic operations are used to synthesise the result from the two values.][[space]]]
[[`assign_components(b, b2, b2)`][`void`][Assigns to `b` the two components in the following arguments.  
                           Only applies to rational and complex number types.
                           When not provided, arithmetic operations are used to synthesise the result from the two values.][[space]]]

[[['Comparisons:]]]
[[`eval_eq(cb, cb2)`][`bool`][Returns `true` if `cb` and `cb2` are equal in value.
            When not provided, the default implementation returns `cb.compare(cb2) == 0`.][`noexcept`]]
[[`eval_eq(cb, a)`][`bool`][Returns `true` if `cb` and `a` are equal in value.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, return the equivalent of `eval_eq(cb, B(a))`.][[space]]]
[[`eval_eq(a, cb)`][`bool`][Returns `true` if `cb` and `a` are equal in value.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version returns `eval_eq(cb, a)`.][[space]]]
[[`eval_lt(cb, cb2)`][`bool`][Returns `true` if `cb` is less than `cb2` in value.
            When not provided, the default implementation returns `cb.compare(cb2) < 0`.][`noexcept`]]
[[`eval_lt(cb, a)`][`bool`][Returns `true` if `cb` is less than `a` in value.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default implementation returns `eval_lt(cb, B(a))`.][[space]]]
[[`eval_lt(a, cb)`][`bool`][Returns `true` if `a` is less than `cb` in value.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default implementation returns `eval_gt(cb, a)`.][[space]]]
[[`eval_gt(cb, cb2)`][`bool`][Returns `true` if `cb` is greater than `cb2` in value.
            When not provided, the default implementation returns `cb.compare(cb2) > 0`.][`noexcept`]]
[[`eval_gt(cb, a)`][`bool`][Returns `true` if `cb` is greater than `a` in value.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default implementation returns `eval_gt(cb, B(a))`.][[space]]]
[[`eval_gt(a, cb)`][`bool`][Returns `true` if `a` is greater than `cb` in value.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default implementation returns `eval_lt(cb, a)`.][[space]]]
[[`eval_is_zero(cb)`][`bool`][Returns `true` if `cb` is zero, otherwise `false`.  The default version of this function 
            returns `cb.compare(ui_type(0)) == 0`, where `ui_type` is `ui_type` is 
            `typename mpl::front<typename B::unsigned_types>::type`.][[space]]]
[[`eval_get_sign(cb)`][`int`][Returns a value < zero if `cb` is negative, a value > zero if `cb` is positive, and zero if `cb` is zero.
            The default version of this function 
            returns `cb.compare(ui_type(0))`, where `ui_type` is `ui_type` is 
            `typename mpl::front<typename B::unsigned_types>::type`.][[space]]]

[[['Basic arithmetic:]]]
[[`eval_add(b, a)`][`void`][Adds `a` to `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_add(b, B(a))`][[space]]]
[[`eval_add(b, cb, cb2)`][`void`][Add `cb` to `cb2` and stores the result in `b`.
            When not provided, does the equivalent of `b = cb; eval_add(b, cb2)`.][[space]]]
[[`eval_add(b, cb, a)`][`void`][Add `cb` to `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_add(b, cb, B(a))`.][[space]]]
[[`eval_add(b, a, cb)`][`void`][Add `a` to `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_add(b, cb, a)`.][[space]]]
[[`eval_subtract(b, a)`][`void`][Subtracts `a` from `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_subtract(b, B(a))`][[space]]]
[[`eval_subtract(b, cb, cb2)`][`void`][Subtracts `cb2` from `cb` and stores the result in `b`.
            When not provided, does the equivalent of `b = cb; eval_subtract(b, cb2)`.][[space]]]
[[`eval_subtract(b, cb, a)`][`void`][Subtracts `a` from `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_subtract(b, cb, B(a))`.][[space]]]
[[`eval_subtract(b, a, cb)`][`void`][Subtracts `cb` from `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_subtract(b, cb, a); b.negate();`.][[space]]]
[[`eval_multiply(b, a)`][`void`][Multiplies `b` by `a`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_multiply(b, B(a))`][[space]]]
[[`eval_multiply(b, cb, cb2)`][`void`][Multiplies `cb` by `cb2` and stores the result in `b`.
            When not provided, does the equivalent of `b = cb; eval_multiply(b, cb2)`.][[space]]]
[[`eval_multiply(b, cb, a)`][`void`][Multiplies `cb` by `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_multiply(b, cb, B(a))`.][[space]]]
[[`eval_multiply(b, a, cb)`][`void`][Multiplies `a` by `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_multiply(b, cb, a)`.][[space]]]
[[`eval_multiply_add(b, cb, cb2)`][`void`][Multiplies `cb` by `cb2` and adds the result to `b`.
            When not provided does the equivalent of creating a temporary `B t` and `eval_multiply(t, cb, cb2)` followed by
            `eval_add(b, t)`.][[space]]]
[[`eval_multiply_add(b, cb, a)`][`void`][Multiplies `a` by `cb` and adds the result to `b`.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided does the equivalent of creating a temporary `B t` and `eval_multiply(t, cb, a)` followed by
            `eval_add(b, t)`.][[space]]]
[[`eval_multiply_add(b, a, cb)`][`void`][Multiplies `a` by `cb` and adds the result to `b`.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided does the equivalent of  `eval_multiply_add(b, cb, a)`.][[space]]]
[[`eval_multiply_subtract(b, cb, cb2)`][`void`][Multiplies `cb` by `cb2` and subtracts the result from `b`.
            When not provided does the equivalent of creating a temporary `B t` and `eval_multiply(t, cb, cb2)` followed by
            `eval_subtract(b, t)`.][[space]]]
[[`eval_multiply_subtract(b, cb, a)`][`void`][Multiplies `a` by `cb` and subtracts the result from `b`.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided does the equivalent of creating a temporary `B t` and `eval_multiply(t, cb, a)` followed by
            `eval_subtract(b, t)`.][[space]]]
[[`eval_multiply_subtract(b, a, cb)`][`void`][Multiplies `a` by `cb` and subtracts the result from `b`.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided does the equivalent of  `eval_multiply_subtract(b, cb, a)`.][[space]]]
[[`eval_multiply_add(b, cb, cb2, cb3)`][`void`][Multiplies `cb` by `cb2` and adds the result to `cb3` storing the result in `b`.
            When not provided does the equivalent of `eval_multiply(b, cb, cb2)` followed by
            `eval_add(b, cb3)`.
            For brevity, only a version showing all arguments of type `B` is shown here, but you can replace up to any 2 of
            `cb`, `cb2` and `cb3` with any type type listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.][[space]]]
[[`eval_multiply_subtract(b, cb, cb2, cb3)`][`void`][Multiplies `cb` by `cb2` and subtracts from the result `cb3` storing the result in `b`.
            When not provided does the equivalent of `eval_multiply(b, cb, cb2)` followed by
            `eval_subtract(b, cb3)`.
            For brevity, only a version showing all arguments of type `B` is shown here, but you can replace up to any 2 of
            `cb`, `cb2` and `cb3` with any type type listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.][[space]]]
[[`eval_divide(b, a)`][`void`][Divides `b` by `a`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_divide(b, B(a))`]
            [`std::overflow_error` if `a` has the value zero, and `std::numeric_limits<number<B> >::has_infinity == false`]]
[[`eval_divide(b, cb, cb2)`][`void`][Divides `cb` by `cb2` and stores the result in `b`.
            When not provided, does the equivalent of `b = cb; eval_divide(b, cb2)`.]
            [`std::overflow_error` if `cb2` has the value zero, and `std::numeric_limits<number<B> >::has_infinity == false`]]
[[`eval_divide(b, cb, a)`][`void`][Divides `cb` by `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_divide(b, cb, B(a))`.]
            [`std::overflow_error` if `a` has the value zero, and `std::numeric_limits<number<B> >::has_infinity == false`]]
[[`eval_divide(b, a, cb)`][`void`][Divides `a` by `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_divide(b, B(a), cb)`.]
            [`std::overflow_error` if cb has the value zero, and `std::numeric_limits<number<B> >::has_infinity == false`]]
[[`eval_increment(b)`][void][Increments the value of `b` by one.
            When not provided, does the equivalent of `eval_add(b, static_cast<ui_type>(1u))`.
            Where `ui_type` is `typename mpl::front<typename B::unsigned_types>::type`.][[space]]]
[[`eval_decrement(b)`][void][Decrements the value of `b` by one.
            When not provided, does the equivalent of `eval_subtract(b, static_cast<ui_type>(1u))`.
            Where `ui_type` is `typename mpl::front<typename B::unsigned_types>::type`.][[space]]]

[[['Integer specific operations:]]]
[[`eval_modulus(b, a)`][`void`][Computes `b %= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_modulus(b, B(a))`]
            [`std::overflow_error` if `a` has the value zero.]]
[[`eval_modulus(b, cb, cb2)`][`void`][Computes `cb % cb2` and stores the result in `b`, only required when `B` is an integer type.
            When not provided, does the equivalent of `b = cb; eval_modulus(b, cb2)`.]
            [`std::overflow_error` if `a` has the value zero.]]
[[`eval_modulus(b, cb, a)`][`void`][Computes `cb % a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_modulus(b, cb, B(a))`.]
            [`std::overflow_error` if `a` has the value zero.]]
[[`eval_modulus(b, a, cb)`][`void`][Computes `cb % a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_modulus(b, B(a), cb)`.]
            [`std::overflow_error` if `a` has the value zero.]]
[[`eval_bitwise_and(b, a)`][`void`][Computes `b &= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_bitwise_and(b, B(a))`][[space]]]
[[`eval_bitwise_and(b, cb, cb2)`][`void`][Computes `cb & cb2` and stores the result in `b`, only required when `B` is an integer type.
            When not provided, does the equivalent of `b = cb; eval_bitwise_and(b, cb2)`.][[space]]]
[[`eval_bitwise_and(b, cb, a)`][`void`][Computes `cb & a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_bitwise_and(b, cb, B(a))`.][[space]]]
[[`eval_bitwise_and(b, a, cb)`][`void`][Computes `cb & a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_bitwise_and(b, cb, a)`.][[space]]]
[[`eval_bitwise_or(b, a)`][`void`][Computes `b |= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_bitwise_or(b, B(a))`][[space]]]
[[`eval_bitwise_or(b, cb, cb2)`][`void`][Computes `cb | cb2` and stores the result in `b`, only required when `B` is an integer type.
            When not provided, does the equivalent of `b = cb; eval_bitwise_or(b, cb2)`.][[space]]]
[[`eval_bitwise_or(b, cb, a)`][`void`][Computes `cb | a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_bitwise_or(b, cb, B(a))`.][[space]]]
[[`eval_bitwise_or(b, a, cb)`][`void`][Computes `cb | a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_bitwise_or(b, cb, a)`.][[space]]]
[[`eval_bitwise_xor(b, a)`][`void`][Computes `b ^= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, the default version calls `eval_bitwise_xor(b, B(a))`][[space]]]
[[`eval_bitwise_xor(b, cb, cb2)`][`void`][Computes `cb ^ cb2` and stores the result in `b`, only required when `B` is an integer type.
            When not provided, does the equivalent of `b = cb; eval_bitwise_xor(b, cb2)`.][[space]]]
[[`eval_bitwise_xor(b, cb, a)`][`void`][Computes `cb ^ a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_bitwise_xor(b, cb, B(a))`.][[space]]]
[[`eval_bitwise_xor(b, a, cb)`][`void`][Computes `a ^ cb` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            When not provided, does the equivalent of `eval_bitwise_xor(b, cb, a)`.][[space]]]
[[`eval_left_shift(b, cb, ui)`][`void`][Computes `cb << ui` and stores the result in `b`, only required when `B` is an integer type.
            When not provided, does the equivalent of `b = cb; eval_left_shift(b, a);`.][[space]]]
[[`eval_right_shift(b, cb, ui)`][`void`][Computes `cb >> ui` and stores the result in `b`, only required when `B` is an integer type.
            When not provided, does the equivalent of `b = cb; eval_right_shift(b, a);`.][[space]]]
[[`eval_qr(cb, cb2, b, b2)`][`void`][Sets `b` to the result of `cb / cb2` and `b2` to the result of `cb % cb2`.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.]
            [`std::overflow_error` if `a` has the value zero.]]
[[`eval_integer_modulus(cb, ui)`][`unsigned`][Returns the result of `cb % ui`.    Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.]
            [`std::overflow_error` if `a` has the value zero.]]
[[`eval_lsb(cb)`][`unsigned`][Returns the index of the least significant bit that is set.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_bit_test(cb, ui)`][`bool`][Returns true if `cb` has bit `ui` set.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_bit_set(b, ui)`][`void`][Sets the bit at index `ui` in `b`.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_bit_unset(b, ui)`][`void`][Unsets the bit at index `ui` in `b`.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_bit_flip(b, ui)`][`void`][Flips the bit at index `ui` in `b`.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_gcd(b, cb, cb2)`][`void`][Sets `b` to the greatest common divisor of `cb` and `cb2`.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_lcm(b, cb, cb2)`][`void`][Sets `b` to the least common multiple of `cb` and `cb2`.  Only required when `B` is an integer type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_gcd(b, cb, a)`][`void`][Sets `b` to the greatest common divisor of `cb` and `cb2`.  Only required when `B` is an integer type.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            The default version of this function calls `eval_gcd(b, cb, B(a))`.][[space]]]
[[`eval_lcm(b, cb, a)`][`void`][Sets `b` to the least common multiple of `cb` and `cb2`.  Only required when `B` is an integer type.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            The default version of this function calls `eval_lcm(b, cb, B(a))`.][[space]]]
[[`eval_gcd(b, a, cb)`][`void`][Sets `b` to the greatest common divisor of `cb` and `a`.  Only required when `B` is an integer type.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            The default version of this function calls `eval_gcd(b, cb, a)`.][[space]]]
[[`eval_lcm(b, a, cb)`][`void`][Sets `b` to the least common multiple of `cb` and `a`.  Only required when `B` is an integer type.
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.
            The default version of this function calls `eval_lcm(b, cb, a)`.][[space]]]
[[`eval_powm(b, cb, cb2, cb3)`][`void`][Sets `b` to the result of ['(cb^cb2)%cb3].
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_powm(b, cb, cb2, a)`][`void`][Sets `b` to the result of ['(cb^cb2)%a].
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types`.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_powm(b, cb, a, cb2)`][`void`][Sets `b` to the result of ['(cb^a)%cb2].
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types`.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_powm(b, cb, a, a2)`][`void`][Sets `b` to the result of ['(cb^a)%a2].
            The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types`.
            The default version of this function is synthesised from other operations above.][[space]]]

[[['Sign manipulation:]]]
[[`eval_abs(b, cb)`][`void`][Set `b` to the absolute value of `cb`.
            The default version of this functions assigns `cb` to `b`, and then calls `b.negate()` if
            `eval_get_sign(cb) < 0`.][[space]]]
[[`eval_fabs(b, cb)`][`void`][Set `b` to the absolute value of `cb`.
            The default version of this functions assigns `cb` to `b`, and then calls `b.negate()` if
            `eval_get_sign(cb) < 0`.][[space]]]

[[['Floating point functions:]]]
[[`eval_fpclassify(cb)`][`int`][Returns one of the same values returned by `std::fpclassify`.  Only required when `B` is an floating-point type.
            The default version of this function will only test for zero `cb`.][[space]]]
[[`eval_trunc(b, cb)`][`void`][Performs the equivalent operation to `std::trunc` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_round(b, cb)`][`void`][Performs the equivalent operation to `std::round` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_exp(b, cb)`][`void`][Performs the equivalent operation to `std::exp` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_log(b, cb)`][`void`][Performs the equivalent operation to `std::log` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_log10(b, cb)`][`void`][Performs the equivalent operation to `std::log10` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_sin(b, cb)`][`void`][Performs the equivalent operation to `std::sin` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_cos(b, cb)`][`void`][Performs the equivalent operation to `std::cos` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_tan(b, cb)`][`void`][Performs the equivalent operation to `std::exp` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_asin(b, cb)`][`void`][Performs the equivalent operation to `std::asin` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_acos(b, cb)`][`void`][Performs the equivalent operation to `std::acos` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_atan(b, cb)`][`void`][Performs the equivalent operation to `std::atan` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_sinh(b, cb)`][`void`][Performs the equivalent operation to `std::sinh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_cosh(b, cb)`][`void`][Performs the equivalent operation to `std::cosh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_tanh(b, cb)`][`void`][Performs the equivalent operation to `std::tanh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_fmod(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::fmod` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_pow(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::pow` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
[[`eval_atan2(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::atan` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.
            The default version of this function is synthesised from other operations above.][[space]]]
]

When the tables above place no ['throws] requirements on an operation, then it is up to each type modelling this concept to
decide when or whether throwing an exception is desirable.  However, thrown exceptions should always either be the type, or
inherit from the type `std::runtime_error`.  For example, a floating point type might choose to throw `std::overflow_error`
whenever the result of an operation would be infinite, and `std::underflow_error` whenever it would round to zero.

[note
The non-member functions are all named with an "eval_" prefix to avoid conflicts with template classes of the same name - 
in point of fact this naming convention shouldn't be necessary, but rather works around some compiler bugs.]

[endsect]

[section:headers Header File Structure]

[table Top level headers
[[Header][Contains]]
[[cpp_int.hpp][The `cpp_int` backend type.]]
[[gmp.hpp][Defines all [gmp] related backends.]]
[[miller_rabin.hpp][Miller Rabin primality testing code.]]
[[number.hpp][Defines the `number` backend, is included by all the backend headers.]]
[[mpfr.hpp][Defines the mpfr_float_backend backend.]]
[[random.hpp][Defines code to interoperate with Boost.Random.]]
[[rational_adapter.hpp][Defines the `rational_adapter` backend.]]
[[cpp_dec_float.hpp][Defines the `cpp_dec_float` backend.]]
[[tommath.hpp][Defines the `tommath_int` backend.]]
[[concepts/number_archetypes.hpp][Defines a backend concept architypes for testing use.]]
]

[table Implementation Headers]
[[Header][Contains]]
[[cpp_int/add.hpp][Add and subtract operators for `cpp_int_backend`.]]
[[cpp_int/bitwise.hpp][Bitwise operators for `cpp_int_backend`.]]
[[cpp_int/checked.hpp][Helper functions for checked arithmetic for `cpp_int_backend`.]]
[[cpp_int/comparison.hpp][Comparison operators for `cpp_int_backend`.]]
[[cpp_int/cpp_int_config.hpp][Basic setup and configuration for `cpp_int_backend`.]]
[[cpp_int/divide.hpp][Division and modulus operators for `cpp_int_backend`.]]
[[cpp_int/limits.hpp][`numeric_limits` support for `cpp_int_backend`.]]
[[cpp_int/misc.hpp][Miscellaneous operators for `cpp_int_backend`.]]
[[cpp_int/multiply.hpp][Multiply operators for `cpp_int_backend`.]]
[[detail/big_lanczos.hpp][Lanczos support for Boost.Math integration.]]
[[detail/default_ops.hpp][Default versions of the optional backend non-member functions.]]
[[detail/generic_interconvert.hpp][Generic interconversion routines.]]
[[detail/number_base.hpp][All the expression template code, metaprogramming, and operator overloads for `number`.]]
[[detail/no_et_ops.hpp][The non-expression template operators.]]
[[defail/functions/constants.hpp][Defines constants used by the floating point functions.]]
[[detail/functions/pow.hpp][Defines default versions of the power and exponential related floating point functions.]]
[[detail/functions/trig.hpp][Defines default versions of the trigonometric related floating point functions.]]
]

[endsect]

[endsect]

[section:perf Performance Comparison]

[section:realworld Floating Point Real World Tests]

These tests test the total time taken to execute all of Boost.Math's test cases for these functions.
In each case the best performing library gets a relative score of 1, with the total execution time
given in brackets.  The first three libraries listed are the various floating point types provided
by this library, while for comparison, two popular C++ front-ends to [mpfr] ([mpfr_class] and [mpreal])
are also shown.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Bessel Function Performance
[[Library][50 Decimal Digits][100 Decimal Digits]]
[[mpfr_float][[*1.0] (6.472s)][1.193 (10.154s)]]
[[mpf_float][1.801 (11.662s)][[*1.0](8.511s)]]
[[cpp_dec_float][3.13 (20.285s)][2.46 (21.019s)]]
[[[mpfr_class]][1.001 (6.480s)][1.15(9.805s)]]
[[[mpreal]][1.542 (9.981s)][1.61 (13.702s)]]
]

[table Non-Central T Distribution Performance
[[Library][50 Decimal Digits][100 Decimal Digits]]
[[mpfr_float][1.308 (258.09s)][1.30 (516.74s)]]
[[mpf_float][[*1.0] (197.30s)][[*1.0](397.30s)]]
[[cpp_dec_float][1.695 (334.50s)][2.68 (1064.53s)]]
[[[mpfr_class]][1.35 (266.39s)][1.323 (525.74s)]]
[[[mpreal]][1.75 (346.64s)][1.635 (649.94s)]]
]

[endsect]

[section:int_real_world Integer Real World Tests]

These [@../../performance/miller_rabin_performance.cpp tests] measure the time taken to generate 1000 128-bit 
random numbers and test for primality using the Miller Rabin test.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [tommath]-0.42.0.  The tests were run on 32-bit
Windows Vista machine.

[table
[[Integer Type][Relative (and Absolute) Times]]
[[mpz_int][1.08279(0.370326s)]]
[[mpz_int (no Expression templates)][1.1702(0.400222s)]]
[[cpp_int][1.3612(0.465547s)]]
[[cpp_int (no Expression templates)][1.33286(0.455854s)]]
[[cpp_int (64-bit cache)][1.33134(0.455333s)]]
[[cpp_int (256-bit cache)][1.29367(0.442451s)]]
[[cpp_int (512-bit cache)][1.08821(0.37218s)]]
[[cpp_int (1024-bit cache)][1.07902(0.369037s)]]
[[int1024_t][1.02616(0.35096s)]]
[[int1024_t (no Expression templates)][1(0.342011s)]]
[[tom_int][3.74233(1.27992s)]]
[[tom_int (no Expression templates)][3.97646(1.35999s)]]
]

It's interesting to note that expression templates have little effect here - perhaps because the actual expressions involved
are relatively trivial in this case - so the time taken for multiplication and division tends to dominate.  Also note
how increasing the internal cache size used by `cpp_int` is quite effective in this case in cutting out memory allocations
altogether - cutting about a third off the total runtime.

[endsect]

[section:float_performance Float Algorithm Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticism, and real-world performance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Operator +
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.02382s)][[*1] (0.0294619s)][[*1] (0.058466s)]]
[[gmp_float][4.55086 (0.108402s)][3.86443 (0.113853s)][2.6241 (0.15342s)]]
[[mpfr_float][2.52036 (0.060035s)][2.1833 (0.0643242s)][1.37736 (0.0805287s)]]
]
[table Operator +(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.56759 (0.0527023s)][1.74629 (0.0618102s)][1.68077 (0.105927s)]]
[[gmp_float][[*1] (0.0336201s)][[*1] (0.0353951s)][[*1] (0.0630232s)]]
[[mpfr_float][3.14875 (0.105861s)][3.15499 (0.111671s)][1.92831 (0.121528s)]]
]
[table Operator -
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.0265783s)][[*1] (0.031465s)][[*1] (0.0619405s)]]
[[gmp_float][4.66954 (0.124108s)][3.72645 (0.117253s)][2.67536 (0.165713s)]]
[[mpfr_float][2.7909 (0.0741774s)][2.48557 (0.0782083s)][1.50944 (0.0934957s)]]
]
[table Operator -(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.0577674s)][[*1] (0.0633795s)][[*1] (0.11146s)]]
[[gmp_float][2.31811 (0.133911s)][2.07251 (0.131355s)][1.67161 (0.186319s)]]
[[mpfr_float][2.45081 (0.141577s)][2.29174 (0.145249s)][1.395 (0.155487s)]]
]
[table Operator *
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.07276 (0.287898s)][1.47724 (0.584569s)][1.55145 (5.09969s)]]
[[gmp_float][[*1] (0.268372s)][[*1] (0.395718s)][[*1] (3.28705s)]]
[[mpfr_float][1.27302 (0.341642s)][1.17649 (0.465557s)][1.14029 (3.7482s)]]
]
[table Operator *(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][2.89945 (0.11959s)][4.56335 (0.197945s)][9.03602 (0.742044s)]]
[[gmp_float][[*1] (0.0412457s)][[*1] (0.0433772s)][[*1] (0.0821206s)]]
[[mpfr_float][3.6951 (0.152407s)][3.71977 (0.161353s)][3.30958 (0.271785s)]]
]
[table Operator /
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][3.24327 (4.00108s)][5.00532 (8.12985s)][6.79566 (54.2796s)]]
[[gmp_float][[*1] (1.23366s)][[*1] (1.62424s)][[*1] (7.9874s)]]
[[mpfr_float][1.32521 (1.63486s)][1.38967 (2.25716s)][1.72413 (13.7713s)]]
]
[table Operator /(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.45093 (0.253675s)][1.83306 (0.419569s)][2.3644 (1.64187s)]]
[[gmp_float][[*1] (0.174836s)][[*1] (0.22889s)][[*1] (0.694411s)]]
[[mpfr_float][1.16731 (0.204088s)][1.13211 (0.259127s)][1.02031 (0.708513s)]]
]
[table Operator str
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.4585 (0.0188303s)][1.55515 (0.03172s)][[*1] (0.131962s)]]
[[gmp_float][[*1] (0.0129107s)][[*1] (0.0203967s)][1.04632 (0.138075s)]]
[[mpfr_float][2.19015 (0.0282764s)][1.84679 (0.0376683s)][1.20295 (0.158743s)]]
]
]
[endsect]

[section:integer_performance Integer Algorithm Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticism, and real-world performance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

Linux x86_64 results are broadly similar, except that libtommath performs much better there.

[table Operator +
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.24574 (0.0270133s)][1.09665 (0.0352319s)][1.25708 (0.0524047s)][1.31488 (0.08777s)]]
[[cpp_int(fixed)][1.05787 (0.0229394s)][[*1] (0.0321268s)][1.16171 (0.0484289s)][1.24017 (0.0827832s)]]
[[gmp_int][2.08016 (0.0451073s)][1.33792 (0.042983s)][1.19676 (0.0498904s)][[*1] (0.0667514s)]]
[[tommath_int][[*1] (0.0216845s)][1.07779 (0.0346258s)][[*1] (0.0416877s)][1.06344 (0.0709863s)]]
]
[table Operator +(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.46244 (0.0202077s)][1.20665 (0.0238576s)][1.17647 (0.0258293s)][1.12424 (0.0317931s)]]
[[cpp_int(fixed)][[*1] (0.0138178s)][[*1] (0.0197719s)][[*1] (0.0219548s)][[*1] (0.0282796s)]]
[[gmp_int][2.15321 (0.0297527s)][2.09834 (0.041488s)][2.89935 (0.0636546s)][3.70262 (0.104709s)]]
[[tommath_int][17.1419 (0.236864s)][12.9762 (0.256563s)][12.3275 (0.270648s)][10.7373 (0.303648s)]]
]
[table Operator -
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.15385 (0.029665s)][1.08217 (0.0369886s)][1.05882 (0.051534s)][1.12132 (0.0822725s)]]
[[cpp_int(fixed)][[*1] (0.0257095s)][[*1] (0.0341801s)][[*1] (0.0486711s)][1.08659 (0.0797242s)]]
[[gmp_int][1.56685 (0.040283s)][1.32917 (0.0454312s)][1.06917 (0.0520378s)][[*1] (0.0733708s)]]
[[tommath_int][1.059 (0.0272264s)][1.16974 (0.0399818s)][1.01303 (0.0493054s)][1.03375 (0.0758472s)]]
]
[table Operator -(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.51665 (0.0157196s)][1.31513 (0.0200533s)][1.29599 (0.0235066s)][1.21534 (0.0266136s)]]
[[cpp_int(fixed)][[*1] (0.0103647s)][[*1] (0.0152482s)][[*1] (0.018138s)][[*1] (0.021898s)]]
[[gmp_int][2.7938 (0.0289568s)][2.55493 (0.038958s)][3.12248 (0.0566356s)][4.48855 (0.0982904s)]]
[[tommath_int][20.8695 (0.216305s)][15.0705 (0.229797s)][13.4093 (0.243217s)][12.2599 (0.268468s)]]
]
[table Operator *
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.29504 (0.0731032s)][1.55431 (0.196132s)][1.4363 (0.656569s)][1.63701 (2.47859s)]]
[[cpp_int(fixed)][[*1] (0.0564485s)][1.16604 (0.147138s)][[*1] (0.457124s)][[*1] (1.5141s)]]
[[gmp_int][1.19574 (0.0674975s)][[*1] (0.126186s)][1.16627 (0.53313s)][1.02906 (1.5581s)]]
[[tommath_int][1.97229 (0.111333s)][2.67087 (0.337027s)][2.13031 (0.973817s)][2.05869 (3.11706s)]]
]
[table Operator *(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.34609 (0.030315s)][1.57086 (0.0407838s)][1.60154 (0.0542267s)][1.67808 (0.0804984s)]]
[[cpp_int(fixed)][1.29783 (0.0292279s)][1.58263 (0.0410894s)][1.61543 (0.054697s)][1.66841 (0.0800346s)]]
[[gmp_int][[*1] (0.0225207s)][[*1] (0.0259628s)][[*1] (0.033859s)][[*1] (0.0479706s)]]
[[tommath_int][12.4278 (0.279882s)][11.9045 (0.309074s)][10.5973 (0.358813s)][9.47384 (0.454466s)]]
]
[table Operator /
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][2.86387 (0.593314s)][2.18375 (0.69965s)][1.72571 (0.918294s)][1.39251 (1.33801s)]]
[[cpp_int(fixed)][[*1] (0.207172s)][[*1] (0.320389s)][[*1] (0.532127s)][[*1] (0.960856s)]]
[[gmp_int][3.89115 (0.806137s)][2.87573 (0.921352s)][1.96635 (1.04635s)][1.29618 (1.24544s)]]
[[tommath_int][11.9483 (2.47535s)][9.35941 (2.99865s)][8.79014 (4.67747s)][11.8316 (11.3684s)]]
]
[table Operator /(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][5.77003 (0.313196s)][4.38067 (0.431864s)][3.55054 (0.634559s)][2.97898 (1.03205s)]]
[[cpp_int(fixed)][2.48952 (0.135131s)][2.59188 (0.255519s)][2.56716 (0.458808s)][2.52368 (0.874313s)]]
[[gmp_int][[*1] (0.0542797s)][[*1] (0.0985842s)][[*1] (0.178722s)][[*1] (0.346443s)]]
[[tommath_int][31.6477 (1.71783s)][22.8727 (2.25489s)][19.9248 (3.56101s)][24.3266 (8.42779s)]]
]
[table Operator %
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.9813 (0.357541s)][1.55667 (0.460146s)][1.35341 (0.681144s)][1.19906 (1.10138s)]]
[[cpp_int(fixed)][[*1] (0.180457s)][[*1] (0.295597s)][[*1] (0.503278s)][[*1] (0.918538s)]]
[[gmp_int][3.50213 (0.631985s)][2.33312 (0.689662s)][1.57264 (0.791475s)][1.07795 (0.99014s)]]
[[tommath_int][12.2393 (2.20868s)][10.1123 (2.98915s)][9.46676 (4.76442s)][12.1795 (11.1873s)]]
]
[table Operator %(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.88485 (0.105552s)][2.00194 (0.203711s)][2.08202 (0.380096s)][2.12794 (0.752068s)]]
[[cpp_int(fixed)][1.7474 (0.0978544s)][1.88457 (0.191768s)][2.0306 (0.37071s)][2.0851 (0.736929s)]]
[[gmp_int][[*1] (0.0560001s)][[*1] (0.101757s)][[*1] (0.182561s)][[*1] (0.353426s)]]
[[tommath_int][30.4466 (1.70501s)][22.2997 (2.26915s)][19.6199 (3.58184s)][24.0694 (8.50676s)]]
]
[table Operator <<
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.20362 (0.0224696s)][1.08555 (0.0294403s)][[*1] (0.0360516s)][1.07177 (0.0523935s)]]
[[cpp_int(fixed)][[*1] (0.0186683s)][[*1] (0.0271201s)][1.02126 (0.036818s)][[*1] (0.0488848s)]]
[[gmp_int][1.36706 (0.0255207s)][1.12042 (0.0303858s)][1.24359 (0.0448335s)][1.40143 (0.0685085s)]]
[[tommath_int][2.09357 (0.0390833s)][2.4569 (0.0666312s)][2.63592 (0.0950291s)][3.43638 (0.167987s)]]
]
[table Operator >>
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.33649 (0.0210319s)][1.12919 (0.0266135s)][1.10413 (0.0307184s)][1.09267 (0.0399373s)]]
[[cpp_int(fixed)][[*1] (0.0157367s)][[*1] (0.0235686s)][[*1] (0.0278214s)][1.05198 (0.0384501s)]]
[[gmp_int][1.72135 (0.0270884s)][1.2078 (0.0284661s)][1.16066 (0.0322912s)][[*1] (0.0365503s)]]
[[tommath_int][15.4381 (0.242945s)][11.8797 (0.279987s)][10.9043 (0.303374s)][14.0762 (0.514491s)]]
]
[table Operator &
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.65829 (0.0314059s)][1.42198 (0.0390384s)][1.48578 (0.0498903s)][1.51243 (0.0770342s)]]
[[cpp_int(fixed)][[*1] (0.0189387s)][[*1] (0.0274536s)][[*1] (0.0335786s)][[*1] (0.0509341s)]]
[[gmp_int][2.80248 (0.0530755s)][2.39752 (0.0658206s)][2.66009 (0.089322s)][2.73942 (0.13953s)]]
[[tommath_int][6.95432 (0.131706s)][5.4059 (0.148412s)][4.56887 (0.153417s)][6.5696 (0.334616s)]]
]
[table Operator &(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.63285 (0.0472296s)][1.43344 (0.0588492s)][1.33141 (0.0724386s)][1.21353 (0.104144s)]]
[[cpp_int(fixed)][[*1] (0.0289247s)][[*1] (0.0410546s)][[*1] (0.0544075s)][[*1] (0.0858187s)]]
[[gmp_int][5.24478 (0.151704s)][3.81907 (0.15679s)][2.77979 (0.151242s)][1.84209 (0.158086s)]]
[[tommath_int][11.7257 (0.339163s)][8.6379 (0.354625s)][6.90411 (0.375636s)][7.63253 (0.655013s)]]
]
[table Operator ^
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.39325 (0.0297525s)][1.28821 (0.0385005s)][1.18843 (0.0492426s)][1.07724 (0.0758668s)]]
[[cpp_int(fixed)][[*1] (0.0213547s)][[*1] (0.0298868s)][[*1] (0.041435s)][[*1] (0.070427s)]]
[[gmp_int][2.28582 (0.048813s)][2.03478 (0.0608129s)][2.05655 (0.0852131s)][1.92381 (0.135488s)]]
[[tommath_int][6.17078 (0.131775s)][4.8567 (0.145151s)][3.64659 (0.151097s)][4.78192 (0.336776s)]]
]
[table Operator ^(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.89396 (0.0383127s)][1.64269 (0.043417s)][1.5386 (0.0477162s)][1.32247 (0.0568053s)]]
[[cpp_int(fixed)][[*1] (0.0202288s)][[*1] (0.0264305s)][[*1] (0.0310128s)][[*1] (0.0429539s)]]
[[gmp_int][7.01953 (0.141997s)][5.47513 (0.14471s)][4.6627 (0.144603s)][3.59601 (0.154463s)]]
[[tommath_int][16.2706 (0.329134s)][12.9494 (0.342258s)][11.3305 (0.35139s)][14.1712 (0.608709s)]]
]
[table Operator |
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.34742 (0.0296944s)][1.25923 (0.0384846s)][1.20517 (0.0493908s)][1.10536 (0.0761343s)]]
[[cpp_int(fixed)][[*1] (0.0220379s)][[*1] (0.030562s)][[*1] (0.0409823s)][[*1] (0.0688775s)]]
[[gmp_int][2.14429 (0.0472558s)][1.95901 (0.0598712s)][2.07584 (0.0850728s)][1.94265 (0.133805s)]]
[[tommath_int][5.98286 (0.13185s)][4.65705 (0.142329s)][3.85812 (0.158115s)][4.81524 (0.331662s)]]
]
[table Operator |(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.40808 (0.0389721s)][1.65035 (0.0437872s)][1.51667 (0.0466144s)][1.37806 (0.0582842s)]]
[[cpp_int(fixed)][[*1] (0.0276775s)][[*1] (0.026532s)][[*1] (0.0307348s)][[*1] (0.0422945s)]]
[[gmp_int][5.31451 (0.147092s)][5.37333 (0.142565s)][4.86508 (0.149527s)][3.74364 (0.158335s)]]
[[tommath_int][11.9312 (0.330226s)][12.943 (0.343403s)][11.4457 (0.35178s)][14.4462 (0.610997s)]]
]
[table Operator gcd
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.82514 (4.45586s)][1.75955 (10.1748s)][1.87025 (25.23s)][2.11453 (68.8556s)]]
[[cpp_int(fixed)][1.57965 (3.85654s)][1.67404 (9.68027s)][1.8405 (24.8287s)][2.27588 (74.1096s)]]
[[gmp_int][[*1] (2.44138s)][[*1] (5.78259s)][[*1] (13.4902s)][[*1] (32.5631s)]]
[[tommath_int][5.01357 (12.24s)][4.38161 (25.337s)][4.08681 (55.1319s)][4.01045 (130.593s)]]
]
[table Operator str
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.46421 (0.00195137s)][1.21669 (0.00319216s)][1.25041 (0.00765237s)][1.53339 (0.0218096s)]]
[[cpp_int(fixed)][[*1] (0.00133271s)][[*1] (0.00262366s)][1.0109 (0.00618661s)][1.24429 (0.0176978s)]]
[[gmp_int][1.7777 (0.00236916s)][1.27408 (0.00334274s)][[*1] (0.00611991s)][[*1] (0.0142232s)]]
[[tommath_int][11.9797 (0.0159654s)][18.3349 (0.0481046s)][18.3681 (0.112411s)][25.0355 (0.356085s)]]
]
[endsect]

[section:rational_performance Rational Type Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticism, and real-world performance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Operator +
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.91758 (18.1263s)][6.60754 (44.1182s)][6.65334 (103.169s)][6.44717 (244.055s)]]
[[mpq_rational][[*1] (3.06312s)][[*1] (6.67695s)][[*1] (15.5064s)][[*1] (37.8546s)]]
]
[table Operator +(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][3.98512 (2.67249s)][4.24335 (3.04309s)][4.65009 (3.83046s)][5.45832 (5.08346s)]]
[[mpq_rational][[*1] (0.670618s)][[*1] (0.717144s)][[*1] (0.823739s)][[*1] (0.931322s)]]
]
[table Operator -
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.91504 (18.2374s)][6.55676 (43.8659s)][6.66239 (103.481s)][6.47224 (244.887s)]]
[[mpq_rational][[*1] (3.08322s)][[*1] (6.69018s)][[*1] (15.5321s)][[*1] (37.8365s)]]
]
[table Operator -(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][3.96173 (2.66785s)][4.36532 (3.09023s)][4.59363 (3.74494s)][5.43075 (5.09156s)]]
[[mpq_rational][[*1] (0.673405s)][[*1] (0.707904s)][[*1] (0.815246s)][[*1] (0.937541s)]]
]
[table Operator *
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.59286 (32.3559s)][6.54125 (82.4247s)][6.8815 (197.198s)][6.84066 (473.057s)]]
[[mpq_rational][[*1] (5.78521s)][[*1] (12.6008s)][[*1] (28.6562s)][[*1] (69.1537s)]]
]
[table Operator *(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][2.70193 (3.1466s)][3.10134 (3.79056s)][3.659 (4.93935s)][4.61372 (6.89845s)]]
[[mpq_rational][[*1] (1.16457s)][[*1] (1.22223s)][[*1] (1.34992s)][[*1] (1.4952s)]]
]
[table Operator /
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][4.36846 (63.9498s)][5.52565 (145.045s)][6.18331 (328.069s)][6.49822 (784.806s)]]
[[mpq_rational][[*1] (14.639s)][[*1] (26.2494s)][[*1] (53.0571s)][[*1] (120.772s)]]
]
[table Operator /(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][2.26643 (3.13785s)][2.57125 (3.76931s)][3.20872 (5.06758s)][4.02177 (7.17803s)]]
[[mpq_rational][[*1] (1.38449s)][[*1] (1.46594s)][[*1] (1.57931s)][[*1] (1.78479s)]]
]
[table Operator str
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.40493 (0.0199393s)][8.55089 (0.0511907s)][9.91026 (0.118839s)][9.93546 (0.285367s)]]
[[mpq_rational][[*1] (0.00368909s)][[*1] (0.00598659s)][[*1] (0.0119915s)][[*1] (0.028722s)]]
]
[endsect]

[endsect]

[section:map Roadmap]

[section:hist History]

[h4 Post review changes]

* Non-expression template operators further optimised with rvalue reference support.
* Many functions made `constexp`.
* Differentiate between explicit and implicit conversions in the number constructor.
* Removed "mp_" prefix from types.
* Allowed mixed precision arithmetic.
* Changed ExpressionTemplates parameter to class `number` to use enumerated values rather than true/false.
* Changed ExpressionTemplate parameter default value to use a traits class so that the default value depends on the backend used.
* Added support for fused-multiply-add/subtract with GMP support.
* Tweaked expression template unpacking to use fewer temporaries when the LHS also appears in the RHS.
* Refactored `cpp_int_backend` based on review comments with new template parameter structure.
* Added additional template parameter to `mpfr_float_backend` to allow stack-based allocation.
* Added section on mixed precision arithmetic, and added support for operations yielding a higher precision result
than either of the arguments.
* Added overloads of integer-specific functions for built in integer types.

[h4 Pre-review history]

*2011-2012, John Maddock adds an expression template enabled front end to Christopher's code,
and adds support for other backends.
* 2011, Christopher Kormanyos publishes the decimal floating point code under the Boost
Software Licence.  The code is published as: [@http://doi.acm.org/10.1145/1916461.1916469 
"Algorithm 910: A Portable C++ Multiple-Precision 
System for Special-Function Calculations"], in ACM TOMS, {VOL 37, ISSUE 4, (February 2011)} (C) ACM, 
2011.
* 2002-2011, Christopher Kormanyos develops the all C++ decimal arithmetic floating point
code.

[endsect]

[section:todo TODO]



More a list of what ['could] be done, rather than what ['should] be done (which may be a much smaller list!).

* Add back-end support for libdecNumber.
* Add an adapter back-end for complex number types.
* Add a back-end for MPFR interval arithmetic.
* Add better multiplication routines (Karatsuba, FFT etc) to cpp_int_backend.
* Add assembly level routines to cpp_int_backend.
* Add an all C++ binary floating point type.
* Can ring types (exact floating point types) be supported?  The answer should be yes, but someone needs to write it, 
the hard part is IO and binary-decimal convertion.
* Should there be a choice of rounding mode (probably MPFR specific)?
* We can reuse temporaries in multiple subtrees (temporary caching).
* cpp_dec_float should round to nearest.
* A 2's complement fixed precision int that uses exactly N bits and no more.

Things requested in review:

* The performances of mp_number<a_trivial_adaptor<float>, false>respect to 
float and mp_number<a_trivial_adaptor<int>, false> and int should be 
given to show the cost of using the generic interface (Mostly done, just need to update docs to the latest results).
* Should we provide min/max overloads for expression templates?  (Not done - we can't overload functions declared in the std namespace :-( ).
* The rounding applied when converting must be documented (Done).
* Document why we don't abstract out addition/multiplication algorithms etc. (done - FAQ)
* Document why we don't use proto (compile times)  (Done).
* We can reuse temporaries in multiple subtrees (temporary caching)  Moved to TODO list.
* Emphasise in the docs that ET's may reorder operations (done 2012/10/31).
* Document what happens to small fixed precision cpp_int's (done 2012/10/31).
* The use of bool in template parameters could be improved by the use of 
an enum class which will be more explicit. E.g `enum class expression_template {disabled, enabled};
enum class sign {unsigned, signed};`  (Partly done 2012/09/15, done 2012/10/31).
* Each back-end should document the requirements it satisfies (not currently scheduled for inclusion: it's
deliberately an implementation detail, and "optional" requirements are optimisations which can't be detected
by the user).  Not done: this is an implementation detail, the exact list of requirements satisfied is purely
an optimimization, not something the user can detect.
* A backend for an overflow aware integers (done 2012/10/31).
* IIUC convert_to is used to emulate in c++98 compilers C++11 explicit 
conversions. Could the explicit conversion operator be added on 
compilers supporting it?  (Done 2012/09/15).
* The front-end should make the differences between implicit and explicit 
construction (Done 2012/09/15).
* The tutorial should add more examples concerning implicit or explicit 
conversions. (Done 2012/09/15).
* The documentation must explain how move semantics helps in this domain 
and what the backend needs to do to profit from this optimization. (Done 2012/09/15).
* The documentation should contain Throws specification on the mp_number 
and backend requirements operations. (Done 2012/09/15).
* The library interface should use the noexcept (BOOST_NOEXCEPT, ...) 
facilities (Done 2012/09/15).
* It is unfortunate that the generic mp_number front end can not make use 
contexpr as not all the backends can ensure this (done - we can go quite a way).
* literals: The library doesn't provide some kind of literals. I think that the 
mp_number class should provide a way to create literals if the backend 
is able to.  (Done 2012/09/15).
* The ExpresionTemplate parameter could be defaulted to a traits class for more sensible defaults (done 2012/09/20).
* In a = exp1 op exp2 where a occurs inside one of exp1 or exp2 then we can optimise and eliminate one more temporary (done 2012/09/20).



[h4 Pre-Review Comments]

* Make fixed precision orthogonal to Allocator type in cpp_int.  Possible solution - add an additional MaxBits 
template argument that defaults to 0 (meaning keep going till no more space/memory).  Done.
* Can ring types (exact floating point types) be supported?  The answer should be yes, but someone needs to write it (Moved to TODO list).
* Should there be a choice of rounding mode (probably MPFR specific)?  Moved to TODO list.
* Make the exponent type for cpp_dec_float a templare parameter, maybe include support for big-integer exponents.
Open question - what should be the default - int32_t or int64_t?  (done 2012/09/06)
* Document the size requirements of fixed precision ints (done 2012/09/15).
* Document std lib function accuracy (done 2012/09/15).
* Be a bit clearer on the effects of sign-magnitude representation of cpp_int - min == -max etc - done.
* Document cpp_dec_float precision, rounding, and exponent size (done 2012/09/06).
* Can we be clearer in the docs that mixed arithmetic doesn't work (no longer applicable as of 2012/09/06)?
* Document round functions behaviour better (they behave as in C++11) (added note 2012/09/06).
* Document limits on size of cpp_dec_float (done 2012/09/06).
* Add support for fused multiply add (and subtract).  GMP mpz_t could use this (done 2012/09/20).

[endsect]

[section:faq FAQ]

[variablelist
[[Why do I get compiler errors when passing a `number` to a template function?]
   [Most likely you are actually passing an expression template type to the function and
   template-argument-deduction deduces the "wrong" type.  Try casting the arguments
   involving expressions to the actual number type, or as a last resort turning off
   expression template support in the number type you are using.]]
[[When is expression template support a performance gain?]
   [As a general rule, expression template support adds a small runtime overhead
   creating and unpacking the expression templates, but greatly reduces the number of
   temporaries created.  So it's most effective in improving performance when the cost
   of creating a temporary is high: for example when creating a temporary involves a memory
   allocation.  It is least effective (and may even be a dis-optimisation) when temporaries
   are cheap: for example if the number type is basically a thin wrapper around a native
   arithmetic type.  In addition, since the library makes extensive use of thin inline wrapper
   functions, turning on compiler optimization is essential to achieving high performance.]]
[[Do expression templates reorder operations?]
   [Yes they do, sometimes quite radically so, if this is a concern then they should be turned
   off for the number type you are using.]]
[[I can't construct my number type from ['some other type], but the docs indicate that the conversion should be allowed, what's up?]
   [Some conversions are ['explicit], that includes construction from a string, or constructing from any type
   that may result in loss of precision (for example constructing an integer type from a float).]]
[[Why do I get an exception thrown (or the program crash due to an uncaught exception) when using the bitwise operators on a checked `cpp_int`?]
   [Bitwise operations on negative values (or indeed any signed integer type) are unspecified by the standard.  As a result
   any attempt to carry out a bitwise operation on a negative checked-integer will result in a `std::range_error` being thrown.]]
[[Why do I get compiler errors when trying to use the complement operator?]
   [Use of the complement operator on signed types is problematic as the result is unspecified by the standard, and is further 
   complicated by the fact that most extended precision integer types use a sign-magnitude representation rather than the 2's
   complement one favored by most native integer types.  As a result the complement operator is deliberately disabled for
   checked `cpp_int`'s.  Unchecked `cpp_int`'s give the same valued result as a 2's complement type would, but not the same bit-pattern.]]
[[Why can't I negate an unsigned type?]
   [The unary negation operator is deliberately disabled for unsigned integer types as its use would almost always be a programming error.]]
[[Why doesn't the library use proto?]
   [A very early version of the library did use proto, but compile times became too slow
   for the library to be usable.  Since the library only required a tiny fraction of what
   proto has to offer anyway, a lightweight expression template mechanism was used instead.
   Compile times are still too slow...]]
[[Why not abstract out addition/multiplication algorithms?]
   [This was deamed not to be practical: these algorithms are intimately
   tied to the actual data representation used.]]
]

[endsect]

[section:ack Acknowledgements]

This library would not have happened without:

* Christopher Kormanyos' C++ decimal number code.
* Paul Bristow for patiently testing, and commenting on the library.
* All the folks at GMP, MPFR and libtommath, for providing the "guts" that makes this library work.
* [@http://www-cs-faculty.stanford.edu/~uno/taocp.html "The Art Of Computer Programming"], 
Donald E. Knuth, Volume 2: Seminumerical Algorithms, Third Edition 
(Reading, Massachusetts: Addison-Wesley, 1997), xiv+762pp. ISBN 0-201-89684-2

[endsect]

[endsect]

[section:indexes Indexes]

[include ../../../../../trunk/tools/auto_index/include/auto_index_helpers.qbk]
[named_index function_name Function Index]
[named_index class_name Class Index]
[named_index typedef_name Typedef Index]
[index]

[endsect]

