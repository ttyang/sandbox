[/ 
  Copyright 2011 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[library Boost.Multiprecision
    [quickbook 1.5]
    [copyright 2002-2012 John Maddock and Christopher Kormanyos]
    [purpose Multiprecision Number library]
    [license
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [Maddock, John], [Kormanyos, Christopher]]
    [/last-revision $Date: 2011-07-08 18:51:46 +0100 (Fri, 08 Jul 2011) $]
]

[import ../example/gmp_snips.cpp]
[import ../example/mpfr_snips.cpp]
[import ../example/cpp_dec_float_snips.cpp]
[import ../example/tommath_snips.cpp]
[import ../example/cpp_int_snips.cpp]
[import ../example/random_snips.cpp]
[import ../example/safe_prime.cpp]

[template mpfr[] [@http://www.mpfr.org MPFR]]
[template gmp[] [@http://gmplib.org GMP]]
[template mpf_class[] [@http://gmplib.org/manual/C_002b_002b-Interface-Floats.html#C_002b_002b-Interface-Floats mpfr_class]]
[template mpfr_class[] [@http://math.berkeley.edu/~wilken/code/gmpfrxx/ mpfr_class]]
[template mpreal[] [@http://www.holoborodko.com/pavel/mpfr/ mpreal]]
[template mpir[] [@http://mpir.org/ MPIR]]
[template tommath[] [@http://libtom.org/?page=features&newsitems=5&whatfile=ltm libtommath]]


[section:intro Introduction]

The Multiprecision Library provides ['User-defined] integer, rational and floating-point C++ types which
try to emulate as closely as practicable the C++ built-in types, but provide for more range and
precision.  Depending upon the number type, precision may be arbitrarily large (limited only by available memory),
fixed at compile time values, for example 50 decimal
digits, or a variable controlled at run-time by member functions.  The types are
expression-template-enabled for better performance than naive user-defined types.

The Multiprecision library comes in two distinct parts:

* An expression-template-enabled front-end `mp_number`
that handles all the operator overloading, expression evaluation optimization, and code reduction.
* A selection of back-ends that implement the actual arithmetic operations, and need conform only to the
reduced interface requirements of the front-end.

Separation of front-end and back-end allows use of highly refined, but restricted license libraries
where possible, but provides Boost license alternatives for users who must have a portable
unconstrained license.  Which is to say some back-ends rely on 3rd party libraries, but a header-only Boost license version is always
available (if somewhat slower).

The library is often used via one of the predefined typedefs: for example if you wanted an [@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision]
integer type using [gmp] as the underlying implementation then you could use:

   #include <boost/multiprecision/gmp.hpp>  // Defines the wrappers around the GMP library's types

   boost::multiprecision::mpz_int myint;    // Arbitrary precision integer type.

Alternatively, you can compose your own multiprecision type, by combining `mp_number` with one of the
predefined back-end types.  For example, suppose you wanted a 300 decimal digit floating-point type
based on the [mpfr] library. In this case, there's no predefined typedef with that level of precision,
so instead we compose our own:

   #include <boost/multiprecision/mpfr.hpp>  // Defines the Backend type that wraps MPFR

   namespace mp = boost::multiprecision;     // Reduce the typing a bit later...

   typedef mp::mp_number<mp::mpfr_float_backend<300> >  my_float;

   my_float a, b, c; // These variables have 300 decimal digits precision

We can repeat the above example, but with the expression templates disabled (for faster compile times, but slower runtimes)
by passing a second template argument to `mp_number`:

   #include <boost/multiprecision/mpfr.hpp>  // Defines the Backend type that wraps MPFR

   namespace mp = boost::multiprecision;     // Reduce the typing a bit later...

   typedef mp::mp_number<mp::mpfr_float_backend<300>, false>  my_float;

   my_float a, b, c; // These variables have 300 decimal digits precision

[h4 Expression Templates]

Class `mp_number` is expression-template-enabled: that means that rather than having a multiplication
operator that looks like this:

   template <class Backend>
   mp_number<Backend> operator * (const mp_number<Backend>& a, const mp_number<Backend>& b)
   {
      mp_number<Backend> result(a);
      result *= b;
      return result;
   }

Instead the operator looks more like this:

   template <class Backend>
   ``['unmentionable-type]`` operator * (const mp_number<Backend>& a, const mp_number<Backend>& b);

Where the "unmentionable" return type is an implementation detail that, rather than containing the result
of the multiplication, contains instructions on how to compute the result.  In effect it's just a pair
of references to the arguments of the function, plus some compile-time information that stores what the operation
is.

The great advantage of this method is the ['elimination of temporaries]: for example the "naive" implementation
of `operator*` above, requires one temporary for computing the result, and at least another one to return it.  It's true 
that sometimes this overhead can be reduced by using move-semantics, but it can't be eliminated completely.  For example, 
lets suppose we're evaluating a polynomial via Horners method, something like this:

    T a[7] = { /* some values */ };
    //....
    y = (((((a[6] * x + a[5]) * x + a[4]) * x + a[3]) * x + a[2]) * x + a[1]) * x + a[0];

If type `T` is an `mp_number`, then this expression is evaluated ['without creating a single temporary value].  In contrast,
if we were using the C++ wrapper that ships with [gmp] - [mpf_class] - then this expression would result in no less than 11
temporaries (this is true even though [mpf_class] does use expression templates to reduce the number of temporaries somewhat).  Had
we used an even simpler wrapper around [gmp] or [mpfr] like `mpclass` things would have been even worse and no less that 24 temporaries
are created for this simple expression (note - we actually measure the number of memory allocations performed rather than 
the number of temporaries directly).

This library also extends expression template support to standard library functions like `abs` or `sin` with `mp_number`
arguments.  This means that an expression such as:

   y = abs(x);

can be evaluated without a single temporary being calculated.  Even expressions like:

   y = sin(x);

get this treatment, so that variable 'y' is used as "working storage" within the implementation of `sin`,
thus reducing the number of temporaries used by one.  Of course, should you write:

   x = sin(x);

Then we clearly can't use `x` as working storage during the calculation, so then a temporary variable
is created in this case.

Given the comments above, you might be forgiven for thinking that expression-templates are some kind of universal-panacea:
sadly though, all tricks like this have their downsides.  For one thing, expression template libraries
like this one, tend to be slower to compile than their simpler cousins, they're also harder to debug
(should you actually want to step through our code!), and rely on compiler optimizations being turned
on to give really good performance.  Also, since the return type from expressions involving `mp_number`s
is an "unmentionable implementation detail", you have to be careful to cast the result of an expression
to the actual number type when passing an expression to a template function.  For example, given:

   template <class T>
   void my_proc(const T&);

Then calling:

   my_proc(a+b);

Will very likely result in obscure error messages inside the body of `my_proc` - since we've passed it
an expression template type, and not a number type.  Instead we probably need:

   my_proc(my_mp_number_type(a+b));

Having said that, these situations don't occur that often - or indeed not at all for non-template functions.
In addition, all the functions in the Boost.Math library will automatically convert expression-template arguments
to the underlying number type without you having to do anything, so:

   mpfr_float_100 a(20), delta(0.125);
   boost::math::gamma_p(a, a + delta);

Will work just fine, with the `a + delta` expression template argument getting converted to an `mpfr_float_100`
internally by the Boost.Math library.

One other potential pitfall that's only possible in C++11: you should never store an expression template using:

   auto my_expression = a + b - c;

unless you're absolutely sure that the lifetimes of `a`, `b` and `c` will outlive that of `my_expression`.

And finally... the performance improvements from an expression template library like this are often not as
dramatic as the reduction in number of temporaries would suggest.  For example if we compare this library with 
[mpfr_class] and [mpreal], with all three using the underlying [mpfr] library at 50 decimal digits precision then
we see the following typical results for polynomial execution:

[table Evaluation of Order 6 Polynomial.
[[Library][Relative Time][Relative number of memory allocations]]
[[mp_number][1.0 (0.00793s)][1.0 (2996 total)]]
[[[mpfr_class]][1.2 (0.00931s)][4.3 (12976 total)]]
[[[mpreal]][1.9 (0.0148s)][9.3 (27947 total)]]
]

As you can see, the execution time increases a lot more slowly than the number of memory allocations.  There are 
a number of reasons for this:

* The cost of extended-precision multiplication and division is so great, that the times taken for these tend to
swamp everything else.
* The cost of an in-place multiplication (using `operator*=`) tends to be more than an out-of-place
`operator*` (typically `operator *=` has to create a temporary workspace to carry out the multiplication, where
as `operator*` can use the target variable as workspace).  Since the expression templates carry out their
magic by converting out-of-place operators to in-place ones, we necessarily take this hit.  Even so the
transformation is more efficient than creating the extra temporary variable, just not by as much as
one would hope.

Finally, note that `mp_number` takes a second template argument, which, when set to `false` disables all
the expression template machinery.  The result is much faster to compile, but slower at runtime.

We'll conclude this section by providing some more performance comparisons between these three libraries,
again, all are using [mpfr] to carry out the underlying arithmetic, and all are operating at the same precision
(50 decimal digits):

[table Evaluation of Boost.Math's Bessel function test data
[[Library][Relative Time][Relative Number of Memory Allocations]]
[[mp_number][1.0 (6.21s)][1.0 (2685469)]]
[[[mpfr_class]][1.04 (6.45s)][1.47 (3946007)]]
[[[mpreal]][1.53 (9.52s)][4.92 (13222940)]]
]

[table Evaluation of Boost.Math's Non-Central T distribution test data
[[Library][Relative Time][Relative Number of Memory Allocations]]
[[mp_number][1.0 (269s)][1.0 (139082551)]]
[[[mpfr_class]][1.04 (278s)][1.81 (252400791)]]
[[[mpreal]][1.49 (401s)][3.22 (447009280)]]
]

[endsect]

[section:tut Tutorial]

In order to use this library you need to make two choices: what kind of number do I want, and
which back-end do I want to perform the actual arithmetic?

[section:ints Integer Types]

The following back-ends provide integer arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`cpp_int`][boost/multiprecision/cpp_int.hpp][2][None]
            [Very versatile, Boost licensed, all C++ integer type which support both [@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision] and fixed precision integer types.][Slower than [gmp], though typically not as slow as [tommath]]]
[[`gmp_int`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient back-end.][Dependency on GNU licensed [gmp] library.]]
[[`tom_int`][boost/multiprecision/tommath.hpp][2][[tommath]][Public domain back-end with no licence restrictions.][Slower than [gmp].]]
]

[section:cpp_int cpp_int]

`#include <boost/multiprecision/cpp_int.hpp>`

   namespace boost{ namespace multiprecision{

   typedef unspecified-type limb_type;

   template <unsigned MinDigits = 0, bool Signed = true, class Allocator = std::allocator<limb_type> >
   class cpp_int_backend;

   typedef mp_number<cpp_int_backend<> >           cpp_int;    // arbitrary precision integer
   typedef rational_adapter<cpp_int_backend<> >    cpp_rational_backend;
   typedef mp_number<cpp_rational_backend>         cpp_rational; // arbitrary precision rational number

   // Fixed precision unsigned types:
   typedef mp_number<cpp_int_backend<128, false, void>, false>   mp_uint128_t;
   typedef mp_number<cpp_int_backend<256, false, void>, false>   mp_uint256_t;
   typedef mp_number<cpp_int_backend<512, false, void>, false>   mp_uint512_t;
   typedef mp_number<cpp_int_backend<1024, false, void>, false>  mp_uint1024_t;

   // Fixed precision signed types:
   typedef mp_number<cpp_int_backend<128, true, void>, false>    mp_int128_t;
   typedef mp_number<cpp_int_backend<256, true, void>, false>    mp_int256_t;
   typedef mp_number<cpp_int_backend<512, true, void>, false>    mp_int512_t;
   typedef mp_number<cpp_int_backend<1024, true, void>, false>   mp_int1024_t;

   }} // namespaces

The `cpp_int_backend` type is used via one of the typedefs `boost::multiprecision::cpp_int`, 
`boost::multiprecision::mp_uint128_t`, `boost::multiprecision::mp_uint256_t`,
`boost::multiprecision::mp_uint512_t`, `boost::multiprecision::mp_int128_t`, `boost::multiprecision::mp_int256_t`
or `boost::multiprecision::mp_int512_t`.  

This back-end is the "Swiss Army Knife" of integer types as it can represent both fixed and 
[@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision]
integer types, and both signed and unsigned types.  There are three template arguments:

[variablelist
[[MinBits][Determines the number of Bits to store directly within the object before resorting to dynamic memory
           allocation.  When zero, this field is determined automatically based on how many bits can be stored
           in union with the dynamic storage header: setting a larger value may improve performance as larger integer
           values will be stored internally before memory allocation is required.  
           When the Allocator parameter is type `void`, then this field
           determines the total number of bits in the resulting fixed precision type.]]
[[Signed][Determines whether the resulting type is signed or not.  Note that for 
[@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision] types
          (where the Allocator parameter is non-void), then this parameter must be `true`.  For fixed precision
          types then this type may be either `true` (type is signed), or `false` (type is unsigned).]]
[[Allocator][The allocator to use for dynamic memory allocation, or type `void` if this is to be a fixed precision type.]]
]

Things you should know when using this type:

* Default constructed `cpp_int_backend`s have the value zero.
* Division by zero results in a `std::runtime_error` being thrown.
* Construction from a string that contains invalid non-numeric characters results in a `std::runtime_error` being thrown.
* Since the precision of `cpp_int_backend` is necessarily limited when the allocator parameter is void, 
care should be taken to avoid numeric overflow when using this type
unless you actually want modulo-arithmetic behavior.
* The type uses a sign-magnitude representation internally, so type `mp_int128_t` has 128-bits of precision plus an extra sign bit.
In this respect the behaviour of these types differs from built-in 2's complement types.  In might be tempting to use a
127-bit type instead, and indeed this does work, but behaviour is still slightly different from a 2's complement built-in type
as the min and max values are identical (apart from the sign), where as they differ by one for a true 2's complement type.
That said it should be noted that there's no requirement for built-in types to be 2's complement either - it's simply that this
is the most common format by far.
* Attempting to print negative values as either an Octal or Hexadecimal string results in a `std::runtime_error` being thrown,
this is a direct consequence of the sign-magnitude representation.
* The fixed precision types `mp_[u]intXXX_t` have expression template support turned off - it seems to make little 
difference to the performance of these types either way - so we may as well have the faster compile times by turning
the feature off.

[h5 Example:]

[cpp_int_eg]

[endsect]

[section:gmp_int gmp_int]

`#include <boost/multiprecision/gmp.hpp>`

   namespace boost{ namespace multiprecision{

   class gmp_int;

   typedef mp_number<gmp_int >         mpz_int;

   }} // namespaces

The `gmp_int` back-end is used via the typedef `boost::multiprecision::mpz_int`.  It acts as a thin wrapper around the [gmp] `mpz_t`
to provide an integer type that is a drop-in replacement for the native C++ integer types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, type `mpz_int` is copy constructible and assignable from:

* The [gmp] native types: `mpf_t`, `mpz_t`, `mpq_t`.
* Instances of `mp_number<T>` that are wrappers around those types: `mp_number<gmp_float<N> >`, `mp_number<gmp_rational>`.

It's also possible to access the underlying `mpz_t` via the `data()` member function of `gmp_int`.

Things you should know when using this type:

* No changes are made to the GMP library's global settings - so you can safely mix this type with
existing code that uses [gmp].
* Default constructed `gmp_int`s have the value zero (this is GMP's default behavior).
* Formatted IO for this type does not support octal or hexadecimal notation for negative values, 
as a result performing formatted output on this type when the argument is negative and either of the flags
`std::ios_base::oct` or `std::ios_base::hex` are set, will result in a `std::runtime_error` will be thrown.
* Division by zero is handled by the [gmp] library - it will trigger a division by zero signal.
* Although this type is a wrapper around [gmp] it will work equally well with [mpir].  Indeed use of [mpir]
is recommended on Win32.

[h5 Example:]

[mpz_eg]

[endsect]

[section:tom_int tom_int]

`#include <boost/multiprecision/tommath.hpp>`

   namespace boost{ namespace multiprecision{

   class tommath_int;

   typedef mp_number<tommath_int >         tom_int;

   }} // namespaces

The `tommath_int` back-end is used via the typedef `boost::multiprecision::tom_int`.  It acts as a thin wrapper around the [tommath] `tom_int`
to provide an integer type that is a drop-in replacement for the native C++ integer types, but with unlimited precision.

Things you should know when using this type:

* Default constructed objects have the value zero (this is [tommath]'s default behavior).
* Although `tom_int` is mostly a drop in replacement for the builtin integer types, it should be noted that it is a
rather strange beast as it's a signed type that is not a 2's complement type.  As a result the bitwise operations
`| & ^` will throw a `std::runtime_error` exception if either of the arguments is negative.  Similarly the complement
operator`~` is deliberately not implemented for this type.
* Formatted IO for this type does not support octal or hexadecimal notation for negative values, 
as a result performing formatted output on this type when the argument is negative and either of the flags
`std::ios_base::oct` or `std::ios_base::hex` are set, will result in a `std::runtime_error` will be thrown.
* Division by zero will result in a hardware signal being raised by [tommath].

[h5 Example:]

[tommath_eg]

[endsect]

[endsect]

[section:floats Floating Point Numbers]

The following back-ends provide floating point arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`mpf_float<N>`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient back-end.][Dependency on GNU licensed [gmp] library.]]
[[`mpfr_float<N>`][boost/multiprecision/mpfr.hpp][2][[gmp] and [mpfr]][Very fast and efficient back-end, with its own standard library implementation.][Dependency on GNU licensed [gmp] and [mpfr] libraries.]]
[[`cpp_dec_float<N>`][boost/multiprecision/cpp_dec_float.hpp][10][None][Header only, all C++ implementation. Boost licence.][Approximately 2x slower than the [mpfr] or [gmp] libraries.]]
]

[section:gmp_float gmp_float]

`#include <boost/multiprecision/gmp.hpp>`

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class gmp_float;

   typedef mp_number<gmp_float<50> >    mpf_float_50;
   typedef mp_number<gmp_float<100> >   mpf_float_100;
   typedef mp_number<gmp_float<500> >   mpf_float_500;
   typedef mp_number<gmp_float<1000> >  mpf_float_1000;
   typedef mp_number<gmp_float<0> >     mpf_float;

   }} // namespaces

The `gmp_float` back-end is used in conjunction with `mp_number` : it acts as a thin wrapper around the [gmp] `mpf_t`
to provide an real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `gmp_float` can be used at fixed precision by specifying a non-zero `Digits10` template parameter, or
at variable precision by setting the template argument to zero.  The typedefs mpf_float_50, mpf_float_100,
mpf_float_500, mpf_float_1000 provide arithmetic types at 50, 100, 500 and 1000 decimal digits precision
respectively.  The typedef mpf_float provides a variable precision type whose precision can be controlled via the
`mp_number`s member functions.

[note This type only provides standard library and `numeric_limits` support when the precision is fixed at compile time.]

As well as the usual conversions from arithmetic and string types, instances of `mp_number<mpf_float<N> >` are
copy constructible and assignable from:

* The [gmp] native types `mpf_t`, `mpz_t`, `mpq_t`.
* The `mp_number` wrappers around those types: `mp_number<mpf_float<M> >`, `mp_number<gmp_int>`, `mp_number<gmp_rational>`.

It's also possible to access the underlying `mpf_t` via the `data()` member function of `gmp_float`.

Things you should know when using this type:

* Default constructed `gmp_float`s have the value zero (this is the [gmp] library's default behavior).
* No changes are made to the [gmp] library's global settings, so this type can be safely mixed with
existing [gmp] code.
* It is not possible to round-trip objects of this type to and from a string and get back
exactly the same value.  This appears to be a limitation of [gmp].
* Since the underlying [gmp] types have no notion of infinities or NaN's, care should be taken
to avoid numeric overflow or division by zero.  That latter will trigger a hardware exception, 
while generating excessively large exponents may result in instability of the underlying [gmp]
library (in testing, converting a number with an excessively large or small exponent 
to a string caused [gmp] to segfault).
* This type can equally be used with [mpir] as the underlying implementation - indeed that is
the recommended option on Win32.

[h5 [gmp] example:]

[mpf_eg]

[endsect]

[section:mpfr_float mpfr_float]

`#include <boost/multiprecision/mpfr_float.hpp>`

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class mpfr_float_backend;

   typedef mp_number<mpfr_float_backend<50> >    mpfr_float_50;
   typedef mp_number<mpfr_float_backend<100> >   mpfr_float_100;
   typedef mp_number<mpfr_float_backend<500> >   mpfr_float_500;
   typedef mp_number<mpfr_float_backend<1000> >  mpfr_float_1000;
   typedef mp_number<mpfr_float_backend<0> >     mpfr_float;

   }} // namespaces

The `mpfr_float_backend` type is used in conjunction with `mp_number`: It acts as a thin wrapper around the [mpfr] `mpfr_t`
to provide an real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `mpfr_float_backend` can be used at fixed precision by specifying a non-zero `Digits10` template parameter, or
at variable precision by setting the template argument to zero.  The typedefs mpfr_float_50, mpfr_float_100,
mpfr_float_500, mpfr_float_1000 provide arithmetic types at 50, 100, 500 and 1000 decimal digits precision
respectively.  The typedef mpfr_float provides a variable precision type whose precision can be controlled via the
`mp_number`s member functions.

[note This type only provides `numeric_limits` support when the precision is fixed at compile time.]

As well as the usual conversions from arithmetic and string types, instances of `mp_number<mpfr_float_backend<N> >` are
copy constructible and assignable from:

* The [gmp] native types `mpf_t`, `mpz_t`, `mpq_t`.
* The [mpfr] native type `mpfr_t`.
* The `mp_number` wrappers around those types: `mp_number<mpfr_float_backend<M> >`, `mp_number<mpf_float<M> >`, `mp_number<gmp_int>`, `mp_number<gmp_rational>`.

It's also possible to access the underlying `mpf_t` via the data() member function of `gmp_float`.

Things you should know when using this type:

* A default constructed `mpfr_float_backend` is set to a NaN (this is the default [mpfr] behavior).
* All operations use round to nearest.
* No changes are made to [gmp] or [mpfr] global settings, so this type can coexist with existing
[mpfr] or [gmp] code.
* The code can equally use [mpir] in place of [gmp] - indeed that is the preferred option on Win32.

[h5 [mpfr] example:]

[mpfr_eg]

[endsect]

[section:cpp_dec_float cpp_dec_float]

`#include <boost/multiprecision/cpp_dec_float.hpp>`

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class cpp_dec_float;

   typedef mp_number<cpp_dec_float<50> > cpp_dec_float_50;
   typedef mp_number<cpp_dec_float<100> > cpp_dec_float_100;

   }} // namespaces

The `cpp_dec_float` back-end is used in conjunction with `mp_number`: It acts as an entirely C++ (header only and dependency free)
real-number type that is a drop-in replacement for the native C++ floating-point types, but with 
much greater precision.

Type `cpp_dec_float` can be used at fixed precision by specifying a non-zero `Digits10` template parameter.  
The typedefs `cpp_dec_float_50` and `cpp_dec_float_100` provide arithmetic types at 50 and 100 decimal digits precision
respectively.

There is full standard library and `numeric_limits` support available for this type.

Things you should know when using this type:

* Default constructed `cpp_dec_float`s have a value of zero.
* The radix of this type is 10.  As a result it can behave subtly differently from base-2 types.
* It is not possible to round-trip this type to and from a string and get back to exactly the same value
(this is a result of the type having some hidden internal guard digits).
* The type has a number of internal guard digits over and above those specified in the template argument.
Normally these should not be visible to the user.

[h5 cpp_dec_float example:]

[cpp_dec_float_eg]

[endsect]

[section:jel Worked Example: defining a mathematical function.]

[import ../example/floating_point_examples.cpp]

[JEL]

[endsect]

[endsect]

[section:rational Rational Number Types]

The following back-ends provide rational number arithmetic:

[table
[[Backend Type][Header][Radix][Dependencies][Pros][Cons]]
[[`gmp_rational`][boost/multiprecision/gmp.hpp][2][[gmp]][Very fast and efficient back-end.][Dependency on GNU licensed [gmp] library.]]
[[`cpp_rational`][boost/multiprecision/cpp_int.hpp][2][None][An all C++ Boost-licensed implementation.][Slower than [gmp].]]
[[`tommath_rational`][boost/multiprecision/tommath.hpp][2][[tommath]][All C/C++ implementation that's Boost Software Licence compatible.][Slower than [gmp].]]
[[`rational_adapter`][boost/multiprecision/rational_adapter.hpp][N/A][none][All C++ adapter that allows any inetger back-end type to be used as a rational type.][Requires an underlying integer back-end type.]]
[[`boost::rational`][boost/rational.hpp][N/A][None][A C++ rational number type that can used with any `mp_number` integer type.][The expression templates used by `mp_number` end up being "hidden" inside `boost::rational`: performance may well suffer as a result.]]
]

[section:gmp_rational gmp_rational]

`#include <boost/multiprecision/gmp.hpp>`

   namespace boost{ namespace multiprecision{

   class gmp_rational;

   typedef mp_number<gmp_rational >         mpq_rational;

   }} // namespaces

The `gmp_rational` back-end is used via the typedef `boost::multiprecision::mpq_rational`.  It acts as a thin wrapper around the [gmp] `mpq_t`
to provide a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, instances of `mp_number<gmp_rational>` are copy constructible
and assignable from:

* The [gmp] native types: `mpz_t`, `mpq_t`.
* `mp_number<gmp_int>`.

There is also a two-argument constructor that accepts a numerator and denominator (both of type `mp_number<gmp_int>`).

There are also non-member functions:

   mpz_int numerator(const mpq_rational&);
   mpz_int denominator(const mpq_rational&);

which return the numerator and denominator of the number.

It's also possible to access the underlying `mpq_t` via the `data()` member function of `mpq_rational`.

Things you should know when using this type:

* Default constructed `mpq_rational`s have the value zero (this is the [gmp] default behavior).
* Division by zero results in a hardware exception inside the [gmp] library.
* No changes are made to the [gmp] library's global settings, so this type can coexist with existing
[gmp] code.
* The code can equally be used with [mpir] as the underlying library - indeed that is the preferred option on Win32.

[h5 Example:]

[mpq_eg]

[endsect]

[section:cpp_rational cpp_rational]

`#include <boost/multiprecision/cpp_int.hpp>`

   namespace boost{ namespace multiprecision{

   typedef rational_adapter<cpp_int_backend<> >    cpp_rational_backend;

   typedef mp_number<cpp_rational_backend>         cpp_rational;

   }} // namespaces

The `cpp_rational_backend` type is used via the typedef `boost::multiprecision::cpp_rational`.  It provides
a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

As well as the usual conversions from arithmetic and string types, instances of `cpp_rational` are copy constructible
and assignable from type `cpp_int`.

There is also a two argument constructor that accepts a numerator and denominator: both of type `cpp_int`.

There are also non-member functions:

   cpp_int numerator(const cpp_rational&);
   cpp_int denominator(const cpp_rational&);

which return the numerator and denominator of the number.

Things you should know when using this type:

* Default constructed `cpp_rational`s have the value zero.
* Division by zero results in a `std::rumtime_error` being thrown.

[h5 Example:]

[cpp_rational_eg]

[endsect]

[section:tommath_rational tommath_rational]

`#include <boost/multiprecision/tommath.hpp>`

   namespace boost{ namespace multiprecision{

   typedef rational_adpater<tommath_int>        tommath_rational;
   typedef mp_number<tommath_rational >         tom_rational;

   }} // namespaces

The `tommath_rational` back-end is used via the typedef `boost::multiprecision::tom_rational`.  It acts as a thin wrapper around 
`boost::rational<tom_int>`
to provide a rational number type that is a drop-in replacement for the native C++ number types, but with unlimited precision.

The advantage of using this type rather than `boost::rational<tom_int>` directly, is that it is expression-template enabled,
greatly reducing the number of temporaries created in complex expressions.

There are also non-member functions:

   tom_int numerator(const tom_rational&);
   tom_int denominator(const tom_rational&);

which return the numerator and denominator of the number.

Things you should know when using this type:

* Default constructed `tom_rational`s have the value zero (this the inherited Boost.Rational behavior).
* Division by zero results in a `boost::bad_rational` exception being thrown (see the rational number library's docs for more information).
* No changes are made to [tommath]'s global state, so this type can safely coexist with other [tommath] code.
* Performance of this type has been found to be pretty poor - this need further investigation - but it appears that Boost.Rational
needs some improvement in this area.

[h5 Example:]

[mp_rat_eg]

[endsect]

[section:br Use With Boost.Rational]

All of the integer types in this library can be used as template arguments to `boost::rational<IntType>`.

Note that using the library in this way largely negates the effect of the expression templates in `mp_number`.

[endsect]

[section:rational_adapter rational_adapter]

   namespace boost{ namespace multiprecision{

   template <class IntBackend> 
   class rational_adpater;

   }}

The class template `rational_adapter` is a back-end for `mp_number` which converts any existing integer back-end
into a rational-number back-end.

So for example, given an integer back-end type `MyIntegerBackend`, the use would be something like:

   typedef mp_number<MyIntegerBackend>                    MyInt;
   typedef mp_number<rational_adapter<MyIntegerBackend> > MyRational;

   MyRational r = 2;
   r /= 3;
   MyInt i = numerator(r);
   assert(i == 2);

[endsect]

[endsect]

[section:conversions Constructing and Interconverting Between Number Types]

All of the number types that are based on `mp_number` have certain conversion rules in common.
In particular:

* Any number type can be constructed (or assigned) from any builtin arithmetic type:

   cpp_dec_float_50 df(0.5); // OK construction from double
   cpp_int          i(450);  // OK constructs from signed int

* Any number type can be constructed (or assigned) from a `const char*` or a `std::string`:

   // pi to 50 places from a string:
   cpp_dec_float_50 df = "3.14159265358979323846264338327950288419716939937510";
   // Integer type will automatically detect "0x" and "0" prefixes and parse the string accordingly:
   cpp_int          i  = "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000";
   // Invalid input always results in a std::runtime_error being thrown:
   i = std::string("3.14");

* Any number type will interoperate with the builtin type in arithmetic expressions:

   // pi to 50 places from a string:
   cpp_dec_float_50 df = "3.14159265358979323846264338327950288419716939937510";
   // Multiply by 2 - using an integer literal here is usually more efficient
   // than constructing a temporary:
   df *= 2;

   // There is a need to be careful with integer types though:
   cpp_int i = 2;
   // Ooops, this really just multiplies by 3:
   i *= 3.14;

* Any number type can be streamed to and from the C++ iostreams:
   

   cpp_dec_float_50 df = "3.14159265358979323846264338327950288419716939937510";
   // Now print at full precision:
   std::cout << std::setprecision(std::numeric_limits<cpp_dec_float_50>::max_digits10)
      << df << std::endl
   cpp_int i = 1;
   i <<= 256;
   // Now print in hex format with prefix:
   std::cout << std::hex << std::showbase << i << std::endl;

* Some intercomnversions between number types are completely generic, and are always available:

   cpp_int cppi(2);
   // We can always convert between numbers of the same category - 
   // int to int, rational to rational, or float to float, so this is OK:
   mpz_int z = cppi;
   // We can always promote from int to rational, int to float, or rational to float:
   cpp_rational     cppr = cppi;  // OK, int to rational
   cpp_dec_float_50 df =   cppi;  // OK, int to float
   df                  =   cppr;  // OK, rational to float
   // However narrowing conversions always fail:
   cppi                =   df;    // Compiler error, conversion not allowed

* Other interconversions may be allowed as special cases, whenever the backend allows it:

   mpf_t     m;           // Native GMP type.
   mpf_init_set_ui(m, 0); // set to a value;
   mpf_float i(m);        // copies the value of the native type.

[endsect]

[section:random Generating Random Numbers]

Random numbers are generated in conjunction with Boost.Random.  However, since Boost.Random is unaware
of [@http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic arbitrary precision] numbers, it's necessary to include the header:

   #include <boost/multiprecision/random.hpp>

In order to act as a bridge between the two libraries.

Integers with /N/ random bits are generated using `independent_bits_engine`:

[random_eg1]

Alternatively we can generate integers in a given range using `uniform_int_distribution`, this will
invoke the underlying engine multiple times to build up the required number of bits in the result:

[random_eg2]

Floating point values in \[0,1) are generated using `uniform_01`, the trick here is to ensure
that the underlying generator produces as many random bits as there are digits in the floating
point type.  As above `independent_bits_engine` can be used for this purpose, note that we also have to
convert decimal digits (in the floating point type) to bits (in the random number generator):

[random_eg3]

Finally, we can modify the above example to produce numbers distributed according to some distribution:

[random_eg4]

[endsect]

[section:primetest Primality Testing]

The library implements a fairly basic (meaning unoptimized, and possibly slow) Miller-Rabin test for primality:

   #include <boost/multiprecision/miller_rabin.hpp>

   template <class Backend, bool ExpressionTemplates, class Engine>
   bool miller_rabin_test(const mp_number<Backend, ExpressionTemplates>& n, unsigned trials, Engine& gen);

   template <class Backend, bool ExpressionTemplates, class Engine>
   bool miller_rabin_test(const mp_number<Backend, ExpressionTemplates>& n, unsigned trials);

These functions perform a Miller-Rabin test for primality, if the result is `false` then /n/ is definitely composite,
while if the result is `true` then /n/ is prime with probability ['0.25^trials].  The algorithm used is straight out of
Knuth Vol 2, which recomends 25 trials for a pretty strong likelyhood that /n/ is prime.

The third optional argument is for a Uniform Random Number Generator from Boost.Random.  When not provided the `mt19937`
generator is used.   Note that when producing random primes then you should probably use a different random number generator 
to produce candidate prime numbers for testing, than is used internally by `miller_rabin_test` for determining 
whether the value is prime.  It also helps of course to seed the generators with some source of randomness.

The following example searches for a prime `p` for which `(p-1)/2` is also probably prime:

[safe_prime]

[endsect]

[endsect]

[section:ref Reference]

[section:mp_number mp_number]

[h4 Synopsis]

   namespace boost{ namespace multiprecision{

   template <class Backend, bool ExpressionTemplates = true>
   class mp_number
   {
      mp_number();
      mp_number(see-below);
      mp_number& operator=(see-below);

      // Member operators
      mp_number& operator+=(const ``['see-below]``&);
      mp_number& operator-=(const ``['see-below]``&);
      mp_number& operator*=(const ``['see-below]``&);
      mp_number& operator/=(const ``['see-below]``&);
      mp_number& operator++();
      mp_number& operator--();
      mp_number  operator++(int);
      mp_number  operator--(int);

      mp_number& operator%=(const ``['see-below]``&);
      mp_number& operator&=(const ``['see-below]``&);
      mp_number& operator|=(const ``['see-below]``&);
      mp_number& operator^=(const ``['see-below]``&);
      mp_number& operator<<=(const ``['integer-type]``&);
      mp_number& operator>>=(const ``['integer-type]``&);

      // Use in Boolean context:
      operator ``['convertible-to-bool-type]``()const;
      // swap:
      void swap(mp_number& other);
      // Sign:
      bool is_zero()const;
      int sign()const;
      // string conversion:
      std::string str()const;
      // Generic conversion mechanism
      template <class T>
      T convert_to()const;
      // precision control:
      static unsigned default_precision();
      static void default_precision(unsigned digits10);
      unsigned precision()const;
      void precision(unsigned digits10);
      // Comparison:
      int compare(const mp_number<Backend>& o)const;
      template <class V>
      typename enable_if<is_arithmetic<V>, int>::type compare(const V& o)const;
      // Access to the underlying implementation:
      Backend& backend();
      const Backend& backend()const;
   };

   // Non member operators:
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator*(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator/(const ``['see-below]``&, const ``['see-below]``&);
   // Integer only operations:
   ``['unmentionable-expression-template-type]`` operator%(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator&(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator|(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator^(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator<<(const ``['see-below]``&, const ``['integer-type]``&);
   ``['unmentionable-expression-template-type]`` operator>>(const ``['see-below]``&, const ``['integer-type]``&);
   // Comparison operators:
   bool operator==(const ``['see-below]``&, const ``['see-below]``&);
   bool operator!=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator< (const ``['see-below]``&, const ``['see-below]``&);
   bool operator> (const ``['see-below]``&, const ``['see-below]``&);
   bool operator<=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator>=(const ``['see-below]``&, const ``['see-below]``&);

   // Swap:
   template <class Backend, bool ExpressionTemplates>
   void swap(mp_number<Backend, ExpressionTemplates>& a, mp_number<Backend, ExpressionTemplates>& b);

   // iostream support:
   template <class Backend, bool ExpressionTemplates>
   std::ostream& operator << (std::ostream& os, const mp_number<Backend, ExpressionTemplates>& r);
   std::ostream& operator << (std::ostream& os, const ``['unmentionable-expression-template-type]``& r);
   template <class Backend, bool ExpressionTemplates>
   std::istream& operator >> (std::istream& is, mp_number<Backend, ExpressionTemplates>& r);

   // Non-member function standard library support:
   ``['unmentionable-expression-template-type]``    abs    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fabs   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sqrt   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    floor  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ceil   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    trunc  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    itrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ltrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lltrunc(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    round  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    iround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    llround(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    exp    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log10    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cos    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sin    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tan    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    acos   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    asin   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cosh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sinh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tanh   (const ``['mp_number-or-expression-template-type]``&);

   ``['unmentionable-expression-template-type]``    ldexp (const ``['mp_number-or-expression-template-type]``&, int);
   ``['unmentionable-expression-template-type]``    frexp (const ``['mp_number-or-expression-template-type]``&, int*);
   ``['unmentionable-expression-template-type]``    pow   (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fmod  (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan2 (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);

   // Traits support:
   template <class T>
   struct component_type;
   template <class T>
   struct number_category;

   // Integer specific functions:
   template <class Backend, bool ExpressionTemplates>
   bool divide_qr(const ``['mp_number-or-expression-template-type]``& x, const ``['mp_number-or-expression-template-type]``& y,
                  mp_number<Backend, ExpressionTemplates>& q, mp_number<Backend, ExpressionTemplates>& r);
   template <class Integer>
   Integer integer_modulus(const ``['mp_number-or-expression-template-type]``& x, Integer val);
   unsigned lsb(const ``['mp_number-or-expression-template-type]``& x);
   template <class Backend, class ExpressionTemplates>
   bool bit_test(const mp_number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Backend, class ExpressionTemplates>
   mp_number<Backend, ExpressionTemplates>& bit_set(mp_number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Backend, class ExpressionTemplates>
   mp_number<Backend, ExpressionTemplates>& bit_unset(mp_number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Backend, class ExpressionTemplates>
   mp_number<Backend, ExpressionTemplates>& bit_flip(mp_number<Backend, ExpressionTemplates>& val, unsigned index);
   template <class Engine>
   bool miller_rabin_test(const ``['mp_number-or-expression-template-type]``& n, unsigned trials, Engine& gen);
   bool miller_rabin_test(const ``['mp_number-or-expression-template-type]``& n, unsigned trials);

   // Rational number support:
   typename component_type<``['mp_number-or-expression-template-type]``>::type numerator  (const ``['mp_number-or-expression-template-type]``&);
   typename component_type<``['mp_number-or-expression-template-type]``>::type denominator(const ``['mp_number-or-expression-template-type]``&);

   }} // namespaces

   namespace boost{ namespace math{

   // Boost.Math interoperability functions:
   int                                              fpclassify     (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isfinite       (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isnan          (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isinf          (const ``['mp_number-or-expression-template-type]``&, int);
   bool                                             isnormal       (const ``['mp_number-or-expression-template-type]``&, int);

   }} // namespaces

   // numeric_limits support:
   namespace std{

   template <class Backend, bool ExpressionTemplates>
   struct numeric_limits<boost::multiprecision<Backend, ExpressionTemplates> >
   {
      /* Usual members here */
   };

   }

[h4 Description]

   template <class Backend, bool ExpressionTemplates = true>
   class mp_number;

Class `mp_number` has two template arguments:

[variablelist
[[Backend][The actual arithmetic back-end that does all the work.]]
[[ExpressionTemplates][A Boolean value: when true, then expression templates are enabled, otherwise they are disabled.]]
]

   mp_number();
   mp_number(see-below);
   mp_number& operator=(see-below);

Type `mp_number` is default constructible, and both copy constructible and assignable from:

* Itself.
* An expression template which is the result of one of the arithmetic operators.
* Any builtin arithmetic type.
* A `std::string` or any type which is convertible to `const char*`.
* Any type that the Backend is constructible or assignable from.

In addition, if the type has multiple components (for example rational or complex number types), then there is a
two argument constructor:

   mp_number(arg1, arg2);

Where the two args must either be arithmetic types, or types that are convertible to the two components of `this`.

      mp_number& operator+=(const ``['see-below]``&);
      mp_number& operator-=(const ``['see-below]``&);
      mp_number& operator*=(const ``['see-below]``&);
      mp_number& operator/=(const ``['see-below]``&);
      mp_number& operator++();
      mp_number& operator--();
      mp_number  operator++(int);
      mp_number  operator--(int);
      // Integer only operations:
      mp_number& operator%=(const ``['see-below]``&);
      mp_number& operator&=(const ``['see-below]``&);
      mp_number& operator|=(const ``['see-below]``&);
      mp_number& operator^=(const ``['see-below]``&);
      mp_number& operator<<=(const ``['integer-type]``&);
      mp_number& operator>>=(const ``['integer-type]``&);

These operators all take their usual arithmetic meanings.

The arguments to these operators is either:

* Another `mp_number<Backend, ExpressionTemplates>`.
* A builtin arithmetic type.
* An expression template derived from `mp_number<Backend>`.

For the left and right shift operations, the argument must be a builtin
integer type with a positive value (negative values result in a `std::runtime_error` being thrown).

      operator ``['convertible-to-bool-type]``()const;

Returns an ['unmentionable-type] that is usable in Boolean contexts (this allows `mp_number` to be used in any
Boolean context - if statements, conditional statements, or as an argument to a logical operator - without
type `mp_number` being convertible to type `bool`.

This operator also enables the use of `mp_number` with any of the following operators:
`!`, `||`, `&&` and `?:`.

      void swap(mp_number& other);

Swaps `*this` with `other`.

      bool is_zero()const;

Returns `true` is `*this` is zero, otherwise `false`.

      int sign()const;

Returns a value less than zero if `*this` is negative, a value greater than zero if `*this` is positive, and zero
if `*this` is zero.

      std::string str(unsigned precision, bool scientific = true)const;

Returns the number formatted as a string, with at least /precision/ digits, and in scientific format
if /scientific/ is true.

      template <class T>
      T convert_to()const;

Provides a generic conversion mechanism to convert `*this` to type `T`.  Type `T` may be any arithmetic type.
Optionally other types may also be supported by specific `Backend` types.


      static unsigned default_precision();
      static void default_precision(unsigned digits10);
      unsigned precision()const;
      void precision(unsigned digits10);

These functions are only available if the Backend template parameter supports runtime changes to precision.  They get and set
the default precision and the precision of `*this` respectively.

      int compare(const mp_number<Backend, ExpressionTemplates>& o)const;
      template <class V>
      typename enable_if<is_arithmetic<V>, int>::type compare(const V& other)const;

Returns:

* A value less that 0 for `*this < other`
* A value greater that 0 for `*this > other`
* Zero for `*this == other`

      Backend& backend();
      const Backend& backend()const;

Returns the underlying back-end instance used by `*this`.

[h4 Non-member operators]

   // Non member operators:
   ``['unmentionable-expression-template-type]`` operator+(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator-(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator*(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator/(const ``['see-below]``&, const ``['see-below]``&);
   // Integer only operations:
   ``['unmentionable-expression-template-type]`` operator%(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator&(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator|(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator^(const ``['see-below]``&, const ``['see-below]``&);
   ``['unmentionable-expression-template-type]`` operator<<(const ``['see-below]``&, const ``['integer-type]``&);
   ``['unmentionable-expression-template-type]`` operator>>(const ``['see-below]``&, const ``['integer-type]``&);
   // Comparison operators:
   bool operator==(const ``['see-below]``&, const ``['see-below]``&);
   bool operator!=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator< (const ``['see-below]``&, const ``['see-below]``&);
   bool operator> (const ``['see-below]``&, const ``['see-below]``&);
   bool operator<=(const ``['see-below]``&, const ``['see-below]``&);
   bool operator>=(const ``['see-below]``&, const ``['see-below]``&);

These operators all take their usual arithmetic meanings.

The arguments to these functions must contain at least one of the following:

* An `mp_number`.
* An expression template type derived from `mp_number`.

In addition, one of the two arguments may be a builtin arithmetic type.

The return type of these operators is either:

* An ['unmentionable-type] expression template type when `ExpressionTemplates` is `true`.
* Type `mp_number<Backend, false>` when `ExpressionTemplates` is `false`.
* Type `bool` if the operator is a comparison operator.

Finally note that the second argument to the left and right shift operations must be a builtin integer type, 
and that the argument must be positive (negative arguments result in a `std::runtime_error` being thrown).

[h4 swap]

   template <class Backend, ExpressionTemplates>
   void swap(mp_number<Backend, ExpressionTemplates>& a, mp_number<Backend, ExpressionTemplates>& b);

Swaps `a` and `b`.

[h4 Iostream Support]

   template <class Backend, bool ExpressionTemplates>
   std::ostream& operator << (std::ostream& os, const mp_number<Backend, ExpressionTemplates>& r);
   template <class Unspecified...>
   std::ostream& operator << (std::ostream& os, const unmentionable-expression-template& r);
   template <class Backend, bool ExpressionTemplates>
   inline std::istream& operator >> (std::istream& is, mp_number<Backend, ExpressionTemplates>& r)

These operators provided formatted input-output operations on `mp_number` types, and expression templates derived from them.

It's down to the back-end type to actually implement string conversion.  However, the back-ends provided with
this library support all of the iostream formatting flags, field width and precision settings.

[h4 Non-member standard library function support]

   ``['unmentionable-expression-template-type]``    abs    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fabs   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sqrt   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    floor  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ceil   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    trunc  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    itrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    ltrunc (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lltrunc(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    round  (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    iround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    lround (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    llround(const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    exp    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    log10    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cos    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sin    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tan    (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    acos   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    asin   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    cosh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    sinh   (const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    tanh   (const ``['mp_number-or-expression-template-type]``&);

   ``['unmentionable-expression-template-type]``    ldexp (const ``['mp_number-or-expression-template-type]``&, int);
   ``['unmentionable-expression-template-type]``    frexp (const ``['mp_number-or-expression-template-type]``&, int*);
   ``['unmentionable-expression-template-type]``    pow   (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    fmod  (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);
   ``['unmentionable-expression-template-type]``    atan2 (const ``['mp_number-or-expression-template-type]``&, const ``['mp_number-or-expression-template-type]``&);

These functions all behave exactly as their standard library counterparts do: their argument is either an instance of `mp_number` or
an expression template derived from it; If the argument is of type `mp_number<Backend, false>` then that is also the return type,
otherwise the return type is an expression template.

These functions are normally implemented by the Backend type.  However, default versions are provided for Backend types that
don't have native support for these functions.  Please note however, that this default support requires the precision of the type
to be a compile time constant - this means for example that the [gmp] MPF Backend will not work with these functions when that type is 
used at variable precision.

Also note that with the exception of `abs` that these functions can only be used with floating-point Backend types.

[h4 Traits Class Support]

   template <class T>
   struct component_type;

If this is a type with mutiple components (for example rational or complex types), then this trait has a single member
`type` that is the type of those components.

   template <class T>
   struct number_category;

A traits class that inherits from `mpl::int_<N>` where `N` is one of the enumerated values `number_kind_integer`, `number_kind_floating_point`,
`number_kind_rational` or `number_kind_fixed_point`.


[h4 Integer functions]

   template <class Backend, bool ExpressionTemplates>
   bool divide_qr(const ``['mp_number-or-expression-template-type]``& x, const ``['mp_number-or-expression-template-type]``& y,
                  mp_number<Backend, ExpressionTemplates>& q, mp_number<Backend, ExpressionTemplates>& r);

Divides x by y and returns both the quotient and remainder.  After the call `q = x / y` and `r = x % y`.

   template <class Integer>
   Integer integer_modulus(const ``['mp_number-or-expression-template-type]``& x, Integer val);

Returns the absolute value of `x % val`.

   unsigned lsb(const ``['mp_number-or-expression-template-type]``& x);

Returns the index of the least significant bit that is set to 1.

   template <class Backend, class ExpressionTemplates>
   bool bit_test(const mp_number<Backend, ExpressionTemplates>& val, unsigned index);

Returns `true` if the bit at /index/ in /val/ is set.

   template <class Backend, class ExpressionTemplates>
   mp_number<Backend, ExpressionTemplates>& bit_set(mp_number<Backend, ExpressionTemplates>& val, unsigned index);

Sets the bit at /index/ in /val/, and returns /val/.

   template <class Backend, class ExpressionTemplates>
   mp_number<Backend, ExpressionTemplates>& bit_unset(mp_number<Backend, ExpressionTemplates>& val, unsigned index);

Unsets the bit at /index/ in /val/, and returns /val/.

   template <class Backend, class ExpressionTemplates>
   mp_number<Backend, ExpressionTemplates>& bit_flip(mp_number<Backend, ExpressionTemplates>& val, unsigned index);

Flips the bit at /index/ in /val/, and returns /val/.

   template <class Engine>
   bool miller_rabin_test(const ``['mp_number-or-expression-template-type]``& n, unsigned trials, Engine& gen);
   bool miller_rabin_test(const ``['mp_number-or-expression-template-type]``& n, unsigned trials);

Tests to see if the number /n/ is probably prime - the test excludes the vast majority of composite numbers
by excluding small prime factors and performing a single Fermat test.  Then performs /trials/ Miller-Rabin
tests.  Returns `false` if /n/ is definitely composite, or `true` if /n/ is probably prime with the
probability of it being composite less than 0.25^trials.

[h4 Rational Number Functions]

   typename component_type<``['mp_number-or-expression-template-type]``>::type numerator  (const ``['mp_number-or-expression-template-type]``&);
   typename component_type<``['mp_number-or-expression-template-type]``>::type denominator(const ``['mp_number-or-expression-template-type]``&);

These functions return the numerator and denominator of a rational number respectively.

[h4 Boost.Math Interoperability Support]

   namespace boost{ namespace math{

   int  fpclassify     (const ``['mp_number-or-expression-template-type]``&, int);
   bool isfinite       (const ``['mp_number-or-expression-template-type]``&, int);
   bool isnan          (const ``['mp_number-or-expression-template-type]``&, int);
   bool isinf          (const ``['mp_number-or-expression-template-type]``&, int);
   bool isnormal       (const ``['mp_number-or-expression-template-type]``&, int);

   }} // namespaces

These floating-point classification functions behave exactly as their Boost.Math equivalents.

Other Boost.Math functions and templates may also be
specialized or overloaded to ensure interoperability.

[h4 std::numeric_limits support]

   namespace std{

   template <class Backend, ExpressionTemplates>
   struct numeric_limits<boost::multiprecision<Backend, ExpressionTemplates> >
   {
      /* Usual members here */
   };

   }

Class template `std::numeric_limits` is specialized for all instantiations of `mp_number` whose precision is known at compile time, plus those
types whose precision is unlimited (though it is much less useful in those cases).  It is not specialized for types
whose precision can vary at compile time (such as `mpf_float`).

[endsect]

[section:cpp_int_ref cpp_int]

   namespace boost{ namespace multiprecision{

   template <unsigned MinBits = 0, bool Signed = true, class Allocator = std::allocator<limb_type> >
   struct cpp_int_backend;

   typedef mp_number<cpp_int_backend<> >           cpp_int;    // arbitrary precision integer
   typedef rational_adapter<cpp_int_backend<> >    cpp_rational_backend;
   typedef mp_number<cpp_rational_backend>         cpp_rational; // arbitrary precision rational number

   // Fixed precision unsigned types:
   typedef mp_number<cpp_int_backend<128, false, void>, false>   mp_uint128_t;
   typedef mp_number<cpp_int_backend<256, false, void>, false>   mp_uint256_t;
   typedef mp_number<cpp_int_backend<512, false, void>, false>   mp_uint512_t;
   typedef mp_number<cpp_int_backend<1024, false, void>, false>  mp_uint1024_t;

   // Fixed precision signed types:
   typedef mp_number<cpp_int_backend<128, true, void>, false>    mp_int128_t;
   typedef mp_number<cpp_int_backend<256, true, void>, false>    mp_int256_t;
   typedef mp_number<cpp_int_backend<512, true, void>, false>    mp_int512_t;
   typedef mp_number<cpp_int_backend<1024, true, void>, false>   mp_int1024_t;

   }} // namespaces

Class template `cpp_int_backend` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
It's members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The template arguments are:

[variablelist
[[Argument][Meaning]]
[[MinBits]
   [The number of Bits to reserve inside the class's internal cache.  When constructing a value,
    the object will use this internal cache if possible before resorting to dynamic memory allocation.
    When this value is zero, then the size of the internal cache is `2*sizeof(void*)*CHAR_BIT`.
    When the Allocator argument is `void`, then this parameter determines the precision of the type.]]
[[Signed][When `true` the type is signed, otherwise unsigned.  Note that unsigned types are currently only 
      supported when the Allocator parameter is `void`.]]
[[Allocator][The allocator used for dynamic memory allocation.  This parameter can be `void`, in which case
      no dymanic memory will ever be allocated.]]
]

More information on this type can be found in the [link boost_multiprecision.tut.ints.cpp_int tutorial].

[endsect]

[section:gmp_int_ref gmp_int]

   namespace boost{ namespace multiprecision{

   class gmp_int;

   typedef mp_number<gmp_int >         mpz_int;

   }} // namespaces

Class template `gmp_int` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
It's members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

More information on this type can be found in the [link boost_multiprecision.tut.ints.gmp_int tutorial].

[endsect]

[section:tom_int_ref tom_int]

   namespace boost{ namespace multiprecision{

   class tommath_int;

   typedef mp_number<tommath_int >         tom_int;

   }} // namespaces

Class template `tommath_int` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
It's members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

More information on this type can be found in the [link boost_multiprecision.tut.ints.tom_int tutorial].

[endsect]

[section:mpf_ref gmp_float]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class gmp_float;

   typedef mp_number<gmp_float<50> >    mpf_float_50;
   typedef mp_number<gmp_float<100> >   mpf_float_100;
   typedef mp_number<gmp_float<500> >   mpf_float_500;
   typedef mp_number<gmp_float<1000> >  mpf_float_1000;
   typedef mp_number<gmp_float<0> >     mpf_float;

   }} // namespaces

Class template `gmp_float` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
It's members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The class takes a single template parameter - `Digits10` - which is the number of decimal digits precision the type
should support.  When this parameter is zero, then the precision can be set at runtime via `mp_number::default_precision`
and `mp_number::precision`.  Note that this type does not in any way change the GMP library's global state (for example
it does not change the default precision of the mpf_t data type), therefore you can safely mix this type with existing
code that uses GMP, and also mix `gmp_float`s of differing precision.

More information on this type can be found in the [link boost_multiprecision.tut.floats.gmp_float tutorial].

[endsect]

[section:mpfr_ref mpfr_float_backend]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class mpfr_float_backend;

   typedef mp_number<mpfr_float_backend<50> >    mpfr_float_50;
   typedef mp_number<mpfr_float_backend<100> >   mpfr_float_100;
   typedef mp_number<mpfr_float_backend<500> >   mpfr_float_500;
   typedef mp_number<mpfr_float_backend<1000> >  mpfr_float_1000;
   typedef mp_number<mpfr_float_backend<0> >     mpfr_float;

   }} // namespaces

Class template `mpfr_float_backend` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
It's members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The class takes a single template parameter - `Digits10` - which is the number of decimal digits precision the type
should support.  When this parameter is zero, then the precision can be set at runtime via `mp_number::default_precision`
and `mp_number::precision`.  Note that this type does not in any way change the GMP or MPFR library's global state (for example
it does not change the default precision of the mpfr_t data type), therefore you can safely mix this type with existing
code that uses GMP or MPFR, and also mix `mpfr_float_backend`s of differing precision.

More information on this type can be found in the [link boost_multiprecision.tut.floats.mpfr_float tutorial].

[endsect]

[section:cpp_dec_ref cpp_dec_float]

   namespace boost{ namespace multiprecision{

   template <unsigned Digits10>
   class cpp_dec_float;

   typedef mp_number<cpp_dec_float<50> > cpp_dec_float_50;
   typedef mp_number<cpp_dec_float<100> > cpp_dec_float_100;

   }} // namespaces

Class template `cpp_dec_float` fulfills all of the requirements for a [link boost_multiprecision.ref.backendconc Backend] type.  
It's members and non-member functions are deliberately not documented: these are considered implementation details that are subject 
to change.

The class takes a single template parameter - `Digits10` - which is the number of decimal digits precision the type
should support.  Note that this type does not ever perform any dynamic memory allocation, as a result the `Digits10`
template argument should not be set too high or the classes size will grow unreasonably large.

More information on this type can be found in the [link boost_multiprecision.tut.floats.cpp_dec_float tutorial].

[endsect]

[section:backendconc Backend Requirements]

[template super[x]'''<superscript>'''[x]'''</superscript>''']

The requirements on the `Backend` template argument to `mp_number` are split up into
compulsory requirements, and optional requirements that are either to improve performance
or provide optional features.

In the following tables, type B is the `Backend` template arument to `mp_number`, `b` and `b2` are
a variables of type B, `cb` and `cb2` are constant variables of type B, `a` is a variable of Arithmetic type, 
`s` is a variable of type `const char*`, `ui` is a variable of type `unsigned`, `bb` is a variable of type `bool`,
`pa` is a variable of type pointer-to-arithmetic-type, `exp` is a variable of type `B::exp_type`,
`pexp` is a variable of type `B::exp_type*`, B2 is another type that meets these requirements, b2 is a variable
of type B2.

[table Compulsory Requirements on the Backend type.
[[Expression][Return Type][Comments]]
[[`B::signed_types`][`mpl::list<type-list>`][A list of signed integral types that can be assigned to type B.  The types shall be
                   listed in order of size, smallest first, and shall terminate in the type that is `std::intmax_t`.]]
[[`B::unsigned_types`][`mpl::list<type-list>`][A list of unsigned integral types that can be assigned to type B.  The types shall be
                   listed in order of size, smallest first, and shall terminate in the type that is `std::uintmax_t`.]]
[[`B::float_types`][`mpl::list<type-list>`][A list of floating-point types that can be assigned to type B.The types shall be
                   listed in order of size, smallest first, and shall terminate in type `long double`.]]
[[`B::exponent_type`][A signed integral type.][The type of the exponent of type B.]]
[[`B()`][ ][Default constructor.]]
[[`B(cb)`][ ][Copy Constructor.]]
[[`b = b`][`B&`][Assignment operator.]]
[[`b = a`][`B&`][Assignment from an Arithmetic type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`b = s`][`B&`][Assignment from a string.]]
[[`b.swap(b)`][`void`][Swaps the contents of its arguments.]]
[[`cb.str(ui, bb)`][`std::string`][Returns the string representation of `b` with `ui` digits and in scientific format if `bb` is `true`.
                  If `ui` is zero, then returns as many digits as are required to reconstruct the original value.]]
[[`b.negate()`][`void`][Negates `b`.]]
[[`cb.compare(cb2)`][`int`][Compares `cb` and `cb2`, returns a value less than zero if `cb < cb2`, a value greater than zero if `cb > cb2` and zero
                   if `cb == cb2`.]]
[[`cb.compare(a)`][`int`][Compares `cb` and `a`, returns a value less than zero if `cb < a`, a value greater than zero if `cb > a` and zero
                   if `cb == a`.  The type of `a` shall be listed in one of the type lists
                   `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_add(b, cb)`][`void`][Adds `cb` to `b`.]]
[[`eval_subtract(b, cb)`][`void`][Subtracts `cb` from `b`.]]
[[`eval_multiply(b, cb)`][`void`][Multiplies `b` by `cb`.]]
[[`eval_divide(b, cb)`][`void`][Divides `b` by `cb`.]]
[[`eval_modulus(b, cb)`][`void`][Computes `b %= cb`, only required when `B` is an integer type.]]
[[`eval_bitwise_and(b, cb)`][`void`][Computes `b &= cb`, only required when `B` is an integer type.]]
[[`eval_bitwise_or(b, cb)`][`void`][Computes `b |= cb`, only required when `B` is an integer type.]]
[[`eval_bitwise_xor(b, cb)`][`void`][Computes `b ^= cb`, only required when `B` is an integer type.]]
[[`eval_complement(b, cb)`][`void`][Computes the ones-complement of `cb` and stores the result in `b`, only required when `B` is an integer type.]]
[[`eval_left_shift(b, ui)`][`void`][Computes `b <<= ui`, only required when `B` is an integer type.]]
[[`eval_right_shift(b, ui)`][`void`][Computes `b >>= ui`, only required when `B` is an integer type.]]
[[`eval_convert_to(pa, cb)`][`void`][Converts `cb` to the type of `*pa` and store the result in `*pa`.  Type `B` shall support
                     conversion to at least types `std::intmax_t`, `std::uintmax_t` and `long long`.
                     Conversion to other arithmetic types can then be synthesised using other operations.
                     Conversions to other types are entirely optional.]]
[[`eval_frexp(b, cb, pexp)`][`void`][Stores values in `b` and `*pexp` such that the value of `cb` is b * 2[super *pexp], only required when `B` is a floating-point type.]]
[[`eval_ldexp(b, cb, exp)`][`void`][Stores a value in `b` that is cb * 2[super exp], only required when `B` is a floating-point type.]]
[[`eval_floor(b, cb)`][`void`][Stores the floor of `cb` in `b`, only required when `B` is a floating-point type.]]
[[`eval_ceil(b, cb)`][`void`][Stores the ceiling of `cb` in `b`, only required when `B` is a floating-point type.]]
[[`eval_sqrt(b, cb)`][`void`][Stores the square root of `cb` in `b`, only required when `B` is a floating-point type.]]
[[`boost::multiprecision::number_category<B>::type`][`mpl::int_<N>`][`N` is one of the values `number_kind_integer`, `number_kind_floating_point`, `number_kind_rational` or `number_kind_fixed_point`.
                                                Defaults to `number_kind_floating_point`.]]
]

[table Optional Requirements on the Backend Type
[[Expression][Returns][Comments]]
[[`B(b2)`][`B`][Copy constructor from a different back-end type.]]
[[`b = b2`][`b&`][Assignment operator from a different back-end type.]]
[[`assign_components(b, a, a)`][`void`][Assigns to `b` the two components in the following arguments.  
                           Only applies to rational and complex number types.]]
[[`assign_components(b, b2, b2)`][`void`][Assigns to `b` the two components in the following arguments.  
                           Only applies to rational and complex number types.]]
[[`eval_add(b, a)`][`void`][Adds `a` to `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_subtract(b, a)`][`void`][Subtracts `a` from `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_multiply(b, a)`][`void`][Multiplies `b` by `a`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_divide(b, a)`][`void`][Divides `b` by `a`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_modulus(b, a)`][`void`][Computes `b %= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_and(b, a)`][`void`][Computes `b &= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_or(b, a)`][`void`][Computes `b |= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_xor(b, a)`][`void`][Computes `b ^= cb`, only required when `B` is an integer type.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_add(b, cb, cb2)`][`void`][Add `cb` to `cb2` and stores the result in `b`.]]
[[`eval_subtract(b, cb, cb2)`][`void`][Subtracts `cb2` from `cb` and stores the result in `b`.]]
[[`eval_multiply(b, cb, cb2)`][`void`][Multiplies `cb` by `cb2` and stores the result in `b`.]]
[[`eval_divide(b, cb, cb2)`][`void`][Divides `cb` by `cb2` and stores the result in `b`.]]
[[`eval_add(b, cb, a)`][`void`][Add `cb` to `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_subtract(b, cb, a)`][`void`][Subtracts `a` from `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_multiply(b, cb, a)`][`void`][Multiplies `cb` by `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_divide(b, cb, a)`][`void`][Divides `cb` by `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_modulus(b, cb, cb2)`][`void`][Computes `cb % cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`eval_bitwise_and(b, cb, cb2)`][`void`][Computes `cb & cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`eval_bitwise_or(b, cb, cb2)`][`void`][Computes `cb | cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`eval_bitwise_xor(b, cb, cb2)`][`void`][Computes `cb ^ cb2` and stores the result in `b`, only required when `B` is an integer type.]]
[[`eval_add(b, a, cb)`][`void`][Add `a` to `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_subtract(b, a, cb)`][`void`][Subtracts `cb` from `a` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_multiply(b, a, cb)`][`void`][Multiplies `a` by `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_divide(b, a, cb)`][`void`][Divides `a` by `cb` and stores the result in `b`.  The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_modulus(b, cb, a)`][`void`][Computes `cb % a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_and(b, cb, a)`][`void`][Computes `cb & a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_or(b, cb, a)`][`void`][Computes `cb | a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_xor(b, cb, a)`][`void`][Computes `cb ^ a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_modulus(b, a, cb)`][`void`][Computes `cb % a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_and(b, a, cb)`][`void`][Computes `cb & a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_or(b, a, cb)`][`void`][Computes `cb | a` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_bitwise_xor(b, a, cb)`][`void`][Computes `a ^ cb` and stores the result in `b`, only required when `B` is an integer type. The type of `a` shall be listed in one of the type lists
            `B::signed_types`, `B::unsigned_types` or `B::float_types`.]]
[[`eval_left_shift(b, cb, ui)`][`void`][Computes `cb << ui` and stores the result in `b`, only required when `B` is an integer type.]]
[[`eval_right_shift(b, cb, ui)`][`void`][Computes `cb >> ui` and stores the result in `b`, only required when `B` is an integer type.]]
[[`eval_increment(b)`][void][Increments the value of `b` by one.]]
[[`eval_decrement(b)`][void][Decrements the value of `b` by one.]]
[[`eval_is_zero(cb)`][`bool`][Returns `true` if `cb` is zero, otherwise `false`]]
[[`eval_get_sign(cb)`][`int`][Returns a value < zero if `cb` is negative, a value > zero if `cb` is positive, and zero if `cb` is zero.]]
[[`eval_abs(b, cb)`][`void`][Set `b` to the absolute value of `cb`.]]
[[`eval_fabs(b, cb)`][`void`][Set `b` to the absolute value of `cb`.]]
[[`eval_fpclassify(cb)`][`int`][Returns one of the same values returned by `std::fpclassify`.  Only required when `B` is an floating-point type.]]
[[`eval_trunc(b, cb)`][`void`][Performs the equivalent operation to `std::trunc` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_round(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::round` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_exp(b, cb)`][`void`][Performs the equivalent operation to `std::exp` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_log(b, cb)`][`void`][Performs the equivalent operation to `std::log` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_log10(b, cb)`][`void`][Performs the equivalent operation to `std::log10` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_sin(b, cb)`][`void`][Performs the equivalent operation to `std::sin` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_cos(b, cb)`][`void`][Performs the equivalent operation to `std::cos` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_tan(b, cb)`][`void`][Performs the equivalent operation to `std::exp` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_asin(b, cb)`][`void`][Performs the equivalent operation to `std::asin` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_acos(b, cb)`][`void`][Performs the equivalent operation to `std::acos` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_atan(b, cb)`][`void`][Performs the equivalent operation to `std::atan` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_sinh(b, cb)`][`void`][Performs the equivalent operation to `std::sinh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_cosh(b, cb)`][`void`][Performs the equivalent operation to `std::cosh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_tanh(b, cb)`][`void`][Performs the equivalent operation to `std::tanh` on argument `cb` and stores the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_fmod(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::fmod` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_pow(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::pow` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_atan2(b, cb, cb2)`][`void`][Performs the equivalent operation to `std::atan` on arguments `cb` and `cb2`, and store the result in `b`.  Only required when `B` is an floating-point type.]]
[[`eval_qr(cb, cb2, b, b2)`][`void`][Sets `b` to the result of `cb / cb2` and `b2` to the result of `cb % cb2`.  Only required when `B` is an integer type.]]
[[`eval_integer_modulus(cb, ui)`][`unsigned`][Returns the result of `cb % ui`.    Only required when `B` is an integer type.]]
[[`eval_lsb(cb)`][`unsigned`][Returns the index of the least significant bit that is set.  Only required when `B` is an integer type.]]
[[`eval_bit_test(cb, ui)`][`bool`][Returns true if `cb` has bit `ui` set.  Only required when `B` is an integer type.]]
[[`eval_bit_set(b, ui)`][`void`][Sets the bit at index `ui` in `b`.  Only required when `B` is an integer type.]]
[[`eval_bit_unset(b, ui)`][`void`][Unsets the bit at index `ui` in `b`.  Only required when `B` is an integer type.]]
[[`eval_bit_flip(b, ui)`][`void`][Flips the bit at index `ui` in `b`.  Only required when `B` is an integer type.]]
[[`eval_gcd(b, cb, cb2)`][`void`][Sets `b` to the greatest common divisor of `cb` and `cb2`.  Only required when `B` is an integer type.]]
[[`eval_lcm(b, cb, cb2)`][`void`][Sets `b` to the least common multiple of `cb` and `cb2`.  Only required when `B` is an integer type.]]
]

[note
The non-member functions are all named with an "eval_" prefix to avoid conflicts with template classes of the same name - 
in point of fact this naming convention shouldn't be necessary, but rather works around some compiler bugs.]

[endsect]

[endsect]

[section:perf Performance Comparison]

[section:realworld Floating Point Real World Tests]

These tests test the total time taken to execute all of Boost.Math's test cases for these functions.
In each case the best performing library gets a relative score of 1, with the total execution time
given in brackets.  The first three libraries listed are the various floating point types provided
by this library, while for comparison, two popular C++ front-ends to [mpfr] ([mpfr_class] and [mpreal])
are also shown.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Bessel Function Performance
[[Library][50 Decimal Digits][100 Decimal Digits]]
[[mpfr_float][[*1.0] (6.472s)][1.193 (10.154s)]]
[[mpf_float][1.801 (11.662s)][[*1.0](8.511s)]]
[[cpp_dec_float][3.13 (20.285s)][2.46 (21.019s)]]
[[[mpfr_class]][1.001 (6.480s)][1.15(9.805s)]]
[[[mpreal]][1.542 (9.981s)][1.61 (13.702s)]]
]

[table Non-Central T Distribution Performance
[[Library][50 Decimal Digits][100 Decimal Digits]]
[[mpfr_float][1.308 (258.09s)][1.30 (516.74s)]]
[[mpf_float][[*1.0] (197.30s)][[*1.0](397.30s)]]
[[cpp_dec_float][1.695 (334.50s)][2.68 (1064.53s)]]
[[[mpfr_class]][1.35 (266.39s)][1.323 (525.74s)]]
[[[mpreal]][1.75 (346.64s)][1.635 (649.94s)]]
]

[endsect]

[section:int_real_world Integer Real World Tests]

These [@../../performance/miller_rabin_performance.cpp tests] measure the time taken to generate 1000 128-bit 
random numbers and test for primality using the Miller Rabin test.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [tommath]-0.42.0.  The tests were run on 32-bit
Windows Vista machine.

[table
[[Integer Type][Relative (and Absolute) Times]]
[[mpz_int][1.08279(0.370326s)]]
[[mpz_int (no Expression templates)][1.1702(0.400222s)]]
[[cpp_int][1.3612(0.465547s)]]
[[cpp_int (no Expression templates)][1.33286(0.455854s)]]
[[cpp_int (64-bit cache)][1.33134(0.455333s)]]
[[cpp_int (256-bit cache)][1.29367(0.442451s)]]
[[cpp_int (512-bit cache)][1.08821(0.37218s)]]
[[cpp_int (1024-bit cache)][1.07902(0.369037s)]]
[[mp_int1024_t][1.02616(0.35096s)]]
[[mp_int1024_t (no Expression templates)][1(0.342011s)]]
[[tom_int][3.74233(1.27992s)]]
[[tom_int (no Expression templates)][3.97646(1.35999s)]]
]

It's interesting to note that expression templates have little effect here - perhaps because the actual expressions involved
are relatively trivial in this case - so the time taken for multiplication and division tends to dominate.  Also note
how increasing the internal cache size used by `cpp_int` is quite effective in this case in cutting out memory allocations
altogether - cutting about a third off the total runtime.

[endsect]

[section:float_performance Float Algorithm Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticism, and real-world performance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Operator +
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.02382s)][[*1] (0.0294619s)][[*1] (0.058466s)]]
[[gmp_float][4.55086 (0.108402s)][3.86443 (0.113853s)][2.6241 (0.15342s)]]
[[mpfr_float][2.52036 (0.060035s)][2.1833 (0.0643242s)][1.37736 (0.0805287s)]]
]
[table Operator +(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.56759 (0.0527023s)][1.74629 (0.0618102s)][1.68077 (0.105927s)]]
[[gmp_float][[*1] (0.0336201s)][[*1] (0.0353951s)][[*1] (0.0630232s)]]
[[mpfr_float][3.14875 (0.105861s)][3.15499 (0.111671s)][1.92831 (0.121528s)]]
]
[table Operator -
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.0265783s)][[*1] (0.031465s)][[*1] (0.0619405s)]]
[[gmp_float][4.66954 (0.124108s)][3.72645 (0.117253s)][2.67536 (0.165713s)]]
[[mpfr_float][2.7909 (0.0741774s)][2.48557 (0.0782083s)][1.50944 (0.0934957s)]]
]
[table Operator -(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][[*1] (0.0577674s)][[*1] (0.0633795s)][[*1] (0.11146s)]]
[[gmp_float][2.31811 (0.133911s)][2.07251 (0.131355s)][1.67161 (0.186319s)]]
[[mpfr_float][2.45081 (0.141577s)][2.29174 (0.145249s)][1.395 (0.155487s)]]
]
[table Operator *
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.07276 (0.287898s)][1.47724 (0.584569s)][1.55145 (5.09969s)]]
[[gmp_float][[*1] (0.268372s)][[*1] (0.395718s)][[*1] (3.28705s)]]
[[mpfr_float][1.27302 (0.341642s)][1.17649 (0.465557s)][1.14029 (3.7482s)]]
]
[table Operator *(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][2.89945 (0.11959s)][4.56335 (0.197945s)][9.03602 (0.742044s)]]
[[gmp_float][[*1] (0.0412457s)][[*1] (0.0433772s)][[*1] (0.0821206s)]]
[[mpfr_float][3.6951 (0.152407s)][3.71977 (0.161353s)][3.30958 (0.271785s)]]
]
[table Operator /
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][3.24327 (4.00108s)][5.00532 (8.12985s)][6.79566 (54.2796s)]]
[[gmp_float][[*1] (1.23366s)][[*1] (1.62424s)][[*1] (7.9874s)]]
[[mpfr_float][1.32521 (1.63486s)][1.38967 (2.25716s)][1.72413 (13.7713s)]]
]
[table Operator /(int)
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.45093 (0.253675s)][1.83306 (0.419569s)][2.3644 (1.64187s)]]
[[gmp_float][[*1] (0.174836s)][[*1] (0.22889s)][[*1] (0.694411s)]]
[[mpfr_float][1.16731 (0.204088s)][1.13211 (0.259127s)][1.02031 (0.708513s)]]
]
[table Operator str
[[Backend][50 Decimal Digits][100 Decimal Digits][500 Decimal Digits]]
[[cpp_dec_float][1.4585 (0.0188303s)][1.55515 (0.03172s)][[*1] (0.131962s)]]
[[gmp_float][[*1] (0.0129107s)][[*1] (0.0203967s)][1.04632 (0.138075s)]]
[[mpfr_float][2.19015 (0.0282764s)][1.84679 (0.0376683s)][1.20295 (0.158743s)]]
]
]
[endsect]

[section:integer_performance Integer Algorithm Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticism, and real-world performance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

Linux x86_64 results are broadly similar, except that libtommath performs much better there.

[table Operator +
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.24574 (0.0270133s)][1.09665 (0.0352319s)][1.25708 (0.0524047s)][1.31488 (0.08777s)]]
[[cpp_int(fixed)][1.05787 (0.0229394s)][[*1] (0.0321268s)][1.16171 (0.0484289s)][1.24017 (0.0827832s)]]
[[gmp_int][2.08016 (0.0451073s)][1.33792 (0.042983s)][1.19676 (0.0498904s)][[*1] (0.0667514s)]]
[[tommath_int][[*1] (0.0216845s)][1.07779 (0.0346258s)][[*1] (0.0416877s)][1.06344 (0.0709863s)]]
]
[table Operator +(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.46244 (0.0202077s)][1.20665 (0.0238576s)][1.17647 (0.0258293s)][1.12424 (0.0317931s)]]
[[cpp_int(fixed)][[*1] (0.0138178s)][[*1] (0.0197719s)][[*1] (0.0219548s)][[*1] (0.0282796s)]]
[[gmp_int][2.15321 (0.0297527s)][2.09834 (0.041488s)][2.89935 (0.0636546s)][3.70262 (0.104709s)]]
[[tommath_int][17.1419 (0.236864s)][12.9762 (0.256563s)][12.3275 (0.270648s)][10.7373 (0.303648s)]]
]
[table Operator -
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.15385 (0.029665s)][1.08217 (0.0369886s)][1.05882 (0.051534s)][1.12132 (0.0822725s)]]
[[cpp_int(fixed)][[*1] (0.0257095s)][[*1] (0.0341801s)][[*1] (0.0486711s)][1.08659 (0.0797242s)]]
[[gmp_int][1.56685 (0.040283s)][1.32917 (0.0454312s)][1.06917 (0.0520378s)][[*1] (0.0733708s)]]
[[tommath_int][1.059 (0.0272264s)][1.16974 (0.0399818s)][1.01303 (0.0493054s)][1.03375 (0.0758472s)]]
]
[table Operator -(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.51665 (0.0157196s)][1.31513 (0.0200533s)][1.29599 (0.0235066s)][1.21534 (0.0266136s)]]
[[cpp_int(fixed)][[*1] (0.0103647s)][[*1] (0.0152482s)][[*1] (0.018138s)][[*1] (0.021898s)]]
[[gmp_int][2.7938 (0.0289568s)][2.55493 (0.038958s)][3.12248 (0.0566356s)][4.48855 (0.0982904s)]]
[[tommath_int][20.8695 (0.216305s)][15.0705 (0.229797s)][13.4093 (0.243217s)][12.2599 (0.268468s)]]
]
[table Operator *
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.29504 (0.0731032s)][1.55431 (0.196132s)][1.4363 (0.656569s)][1.63701 (2.47859s)]]
[[cpp_int(fixed)][[*1] (0.0564485s)][1.16604 (0.147138s)][[*1] (0.457124s)][[*1] (1.5141s)]]
[[gmp_int][1.19574 (0.0674975s)][[*1] (0.126186s)][1.16627 (0.53313s)][1.02906 (1.5581s)]]
[[tommath_int][1.97229 (0.111333s)][2.67087 (0.337027s)][2.13031 (0.973817s)][2.05869 (3.11706s)]]
]
[table Operator *(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.34609 (0.030315s)][1.57086 (0.0407838s)][1.60154 (0.0542267s)][1.67808 (0.0804984s)]]
[[cpp_int(fixed)][1.29783 (0.0292279s)][1.58263 (0.0410894s)][1.61543 (0.054697s)][1.66841 (0.0800346s)]]
[[gmp_int][[*1] (0.0225207s)][[*1] (0.0259628s)][[*1] (0.033859s)][[*1] (0.0479706s)]]
[[tommath_int][12.4278 (0.279882s)][11.9045 (0.309074s)][10.5973 (0.358813s)][9.47384 (0.454466s)]]
]
[table Operator /
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][2.86387 (0.593314s)][2.18375 (0.69965s)][1.72571 (0.918294s)][1.39251 (1.33801s)]]
[[cpp_int(fixed)][[*1] (0.207172s)][[*1] (0.320389s)][[*1] (0.532127s)][[*1] (0.960856s)]]
[[gmp_int][3.89115 (0.806137s)][2.87573 (0.921352s)][1.96635 (1.04635s)][1.29618 (1.24544s)]]
[[tommath_int][11.9483 (2.47535s)][9.35941 (2.99865s)][8.79014 (4.67747s)][11.8316 (11.3684s)]]
]
[table Operator /(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][5.77003 (0.313196s)][4.38067 (0.431864s)][3.55054 (0.634559s)][2.97898 (1.03205s)]]
[[cpp_int(fixed)][2.48952 (0.135131s)][2.59188 (0.255519s)][2.56716 (0.458808s)][2.52368 (0.874313s)]]
[[gmp_int][[*1] (0.0542797s)][[*1] (0.0985842s)][[*1] (0.178722s)][[*1] (0.346443s)]]
[[tommath_int][31.6477 (1.71783s)][22.8727 (2.25489s)][19.9248 (3.56101s)][24.3266 (8.42779s)]]
]
[table Operator %
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.9813 (0.357541s)][1.55667 (0.460146s)][1.35341 (0.681144s)][1.19906 (1.10138s)]]
[[cpp_int(fixed)][[*1] (0.180457s)][[*1] (0.295597s)][[*1] (0.503278s)][[*1] (0.918538s)]]
[[gmp_int][3.50213 (0.631985s)][2.33312 (0.689662s)][1.57264 (0.791475s)][1.07795 (0.99014s)]]
[[tommath_int][12.2393 (2.20868s)][10.1123 (2.98915s)][9.46676 (4.76442s)][12.1795 (11.1873s)]]
]
[table Operator %(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.88485 (0.105552s)][2.00194 (0.203711s)][2.08202 (0.380096s)][2.12794 (0.752068s)]]
[[cpp_int(fixed)][1.7474 (0.0978544s)][1.88457 (0.191768s)][2.0306 (0.37071s)][2.0851 (0.736929s)]]
[[gmp_int][[*1] (0.0560001s)][[*1] (0.101757s)][[*1] (0.182561s)][[*1] (0.353426s)]]
[[tommath_int][30.4466 (1.70501s)][22.2997 (2.26915s)][19.6199 (3.58184s)][24.0694 (8.50676s)]]
]
[table Operator <<
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.20362 (0.0224696s)][1.08555 (0.0294403s)][[*1] (0.0360516s)][1.07177 (0.0523935s)]]
[[cpp_int(fixed)][[*1] (0.0186683s)][[*1] (0.0271201s)][1.02126 (0.036818s)][[*1] (0.0488848s)]]
[[gmp_int][1.36706 (0.0255207s)][1.12042 (0.0303858s)][1.24359 (0.0448335s)][1.40143 (0.0685085s)]]
[[tommath_int][2.09357 (0.0390833s)][2.4569 (0.0666312s)][2.63592 (0.0950291s)][3.43638 (0.167987s)]]
]
[table Operator >>
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.33649 (0.0210319s)][1.12919 (0.0266135s)][1.10413 (0.0307184s)][1.09267 (0.0399373s)]]
[[cpp_int(fixed)][[*1] (0.0157367s)][[*1] (0.0235686s)][[*1] (0.0278214s)][1.05198 (0.0384501s)]]
[[gmp_int][1.72135 (0.0270884s)][1.2078 (0.0284661s)][1.16066 (0.0322912s)][[*1] (0.0365503s)]]
[[tommath_int][15.4381 (0.242945s)][11.8797 (0.279987s)][10.9043 (0.303374s)][14.0762 (0.514491s)]]
]
[table Operator &
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.65829 (0.0314059s)][1.42198 (0.0390384s)][1.48578 (0.0498903s)][1.51243 (0.0770342s)]]
[[cpp_int(fixed)][[*1] (0.0189387s)][[*1] (0.0274536s)][[*1] (0.0335786s)][[*1] (0.0509341s)]]
[[gmp_int][2.80248 (0.0530755s)][2.39752 (0.0658206s)][2.66009 (0.089322s)][2.73942 (0.13953s)]]
[[tommath_int][6.95432 (0.131706s)][5.4059 (0.148412s)][4.56887 (0.153417s)][6.5696 (0.334616s)]]
]
[table Operator &(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.63285 (0.0472296s)][1.43344 (0.0588492s)][1.33141 (0.0724386s)][1.21353 (0.104144s)]]
[[cpp_int(fixed)][[*1] (0.0289247s)][[*1] (0.0410546s)][[*1] (0.0544075s)][[*1] (0.0858187s)]]
[[gmp_int][5.24478 (0.151704s)][3.81907 (0.15679s)][2.77979 (0.151242s)][1.84209 (0.158086s)]]
[[tommath_int][11.7257 (0.339163s)][8.6379 (0.354625s)][6.90411 (0.375636s)][7.63253 (0.655013s)]]
]
[table Operator ^
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.39325 (0.0297525s)][1.28821 (0.0385005s)][1.18843 (0.0492426s)][1.07724 (0.0758668s)]]
[[cpp_int(fixed)][[*1] (0.0213547s)][[*1] (0.0298868s)][[*1] (0.041435s)][[*1] (0.070427s)]]
[[gmp_int][2.28582 (0.048813s)][2.03478 (0.0608129s)][2.05655 (0.0852131s)][1.92381 (0.135488s)]]
[[tommath_int][6.17078 (0.131775s)][4.8567 (0.145151s)][3.64659 (0.151097s)][4.78192 (0.336776s)]]
]
[table Operator ^(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.89396 (0.0383127s)][1.64269 (0.043417s)][1.5386 (0.0477162s)][1.32247 (0.0568053s)]]
[[cpp_int(fixed)][[*1] (0.0202288s)][[*1] (0.0264305s)][[*1] (0.0310128s)][[*1] (0.0429539s)]]
[[gmp_int][7.01953 (0.141997s)][5.47513 (0.14471s)][4.6627 (0.144603s)][3.59601 (0.154463s)]]
[[tommath_int][16.2706 (0.329134s)][12.9494 (0.342258s)][11.3305 (0.35139s)][14.1712 (0.608709s)]]
]
[table Operator |
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.34742 (0.0296944s)][1.25923 (0.0384846s)][1.20517 (0.0493908s)][1.10536 (0.0761343s)]]
[[cpp_int(fixed)][[*1] (0.0220379s)][[*1] (0.030562s)][[*1] (0.0409823s)][[*1] (0.0688775s)]]
[[gmp_int][2.14429 (0.0472558s)][1.95901 (0.0598712s)][2.07584 (0.0850728s)][1.94265 (0.133805s)]]
[[tommath_int][5.98286 (0.13185s)][4.65705 (0.142329s)][3.85812 (0.158115s)][4.81524 (0.331662s)]]
]
[table Operator |(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.40808 (0.0389721s)][1.65035 (0.0437872s)][1.51667 (0.0466144s)][1.37806 (0.0582842s)]]
[[cpp_int(fixed)][[*1] (0.0276775s)][[*1] (0.026532s)][[*1] (0.0307348s)][[*1] (0.0422945s)]]
[[gmp_int][5.31451 (0.147092s)][5.37333 (0.142565s)][4.86508 (0.149527s)][3.74364 (0.158335s)]]
[[tommath_int][11.9312 (0.330226s)][12.943 (0.343403s)][11.4457 (0.35178s)][14.4462 (0.610997s)]]
]
[table Operator gcd
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.82514 (4.45586s)][1.75955 (10.1748s)][1.87025 (25.23s)][2.11453 (68.8556s)]]
[[cpp_int(fixed)][1.57965 (3.85654s)][1.67404 (9.68027s)][1.8405 (24.8287s)][2.27588 (74.1096s)]]
[[gmp_int][[*1] (2.44138s)][[*1] (5.78259s)][[*1] (13.4902s)][[*1] (32.5631s)]]
[[tommath_int][5.01357 (12.24s)][4.38161 (25.337s)][4.08681 (55.1319s)][4.01045 (130.593s)]]
]
[table Operator str
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_int][1.46421 (0.00195137s)][1.21669 (0.00319216s)][1.25041 (0.00765237s)][1.53339 (0.0218096s)]]
[[cpp_int(fixed)][[*1] (0.00133271s)][[*1] (0.00262366s)][1.0109 (0.00618661s)][1.24429 (0.0176978s)]]
[[gmp_int][1.7777 (0.00236916s)][1.27408 (0.00334274s)][[*1] (0.00611991s)][[*1] (0.0142232s)]]
[[tommath_int][11.9797 (0.0159654s)][18.3349 (0.0481046s)][18.3681 (0.112411s)][25.0355 (0.356085s)]]
]
[endsect]

[section:rational_performance Rational Type Perfomance]

Note that these tests are carefully designed to test performance of the underlying algorithms
and not memory allocation or variable copying.  As usual, performance results should be taken
with a healthy dose of scepticism, and real-world performance may vary widely depending upon the
specifics of the program.  In each table relative times are given first, with the best performer
given a score of 1.  Total actual times are given in brackets, measured in seconds for 500000
operations.

Test code was compiled with Microsoft Visual Studio 2010 with all optimisations
turned on (/Ox), and used MPIR-2.3.0 and [mpfr]-3.0.0.  The tests were run on 32-bit
Windows Vista machine.

[table Operator +
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.91758 (18.1263s)][6.60754 (44.1182s)][6.65334 (103.169s)][6.44717 (244.055s)]]
[[mpq_rational][[*1] (3.06312s)][[*1] (6.67695s)][[*1] (15.5064s)][[*1] (37.8546s)]]
]
[table Operator +(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][3.98512 (2.67249s)][4.24335 (3.04309s)][4.65009 (3.83046s)][5.45832 (5.08346s)]]
[[mpq_rational][[*1] (0.670618s)][[*1] (0.717144s)][[*1] (0.823739s)][[*1] (0.931322s)]]
]
[table Operator -
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.91504 (18.2374s)][6.55676 (43.8659s)][6.66239 (103.481s)][6.47224 (244.887s)]]
[[mpq_rational][[*1] (3.08322s)][[*1] (6.69018s)][[*1] (15.5321s)][[*1] (37.8365s)]]
]
[table Operator -(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][3.96173 (2.66785s)][4.36532 (3.09023s)][4.59363 (3.74494s)][5.43075 (5.09156s)]]
[[mpq_rational][[*1] (0.673405s)][[*1] (0.707904s)][[*1] (0.815246s)][[*1] (0.937541s)]]
]
[table Operator *
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.59286 (32.3559s)][6.54125 (82.4247s)][6.8815 (197.198s)][6.84066 (473.057s)]]
[[mpq_rational][[*1] (5.78521s)][[*1] (12.6008s)][[*1] (28.6562s)][[*1] (69.1537s)]]
]
[table Operator *(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][2.70193 (3.1466s)][3.10134 (3.79056s)][3.659 (4.93935s)][4.61372 (6.89845s)]]
[[mpq_rational][[*1] (1.16457s)][[*1] (1.22223s)][[*1] (1.34992s)][[*1] (1.4952s)]]
]
[table Operator /
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][4.36846 (63.9498s)][5.52565 (145.045s)][6.18331 (328.069s)][6.49822 (784.806s)]]
[[mpq_rational][[*1] (14.639s)][[*1] (26.2494s)][[*1] (53.0571s)][[*1] (120.772s)]]
]
[table Operator /(int)
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][2.26643 (3.13785s)][2.57125 (3.76931s)][3.20872 (5.06758s)][4.02177 (7.17803s)]]
[[mpq_rational][[*1] (1.38449s)][[*1] (1.46594s)][[*1] (1.57931s)][[*1] (1.78479s)]]
]
[table Operator str
[[Backend][128 Bits][256 Bits][512 Bits][1024 Bits]]
[[cpp_rational][5.40493 (0.0199393s)][8.55089 (0.0511907s)][9.91026 (0.118839s)][9.93546 (0.285367s)]]
[[mpq_rational][[*1] (0.00368909s)][[*1] (0.00598659s)][[*1] (0.0119915s)][[*1] (0.028722s)]]
]
[endsect]

[endsect]

[section:map Roadmap]

[section:hist History]

*2011-2012, John Maddock adds an expression template enabled front end to Christopher's code,
and adds support for other backends.
* 2011, Christopher Kormanyos publishes the decimal floating point code under the Boost
Software Licence.  The code is published as: [@http://doi.acm.org/10.1145/1916461.1916469 
"Algorithm 910: A Portable C++ Multiple-Precision 
System for Special-Function Calculations"], in ACM TOMS, {VOL 37, ISSUE 4, (February 2011)} (C) ACM, 
2011.
* 2002-2011, Christopher Kormanyos develops the all C++ decimal arithmetic floating point
code.

[endsect]

[section:todo TODO]

More a list of what ['could] be done, rather than what ['should] be done (which may be a much smaller list!).

* Add back-end support for libdecNumber.
* Add an adapter back-end for complex number types.
* Add a back-end for MPFR interval arithmetic.
* Add better multiplication routines (Karatsuba, FFT etc) to cpp_int_backend.
* Add assembly level routines to cpp_int_backend.
* Add an all C++ binary floating point type.

[h4 Pre-Review Comments]

* Make the exponent type for cpp_dec_float a templare parameter, maybe include support for big-integer exponents.
Open question - what should be the default - int32_t or int64_t?
* Document the size requirements of fixed precision ints.
* Document std lib function accuracy.
* Make fixed precision orthogonal to Allocator type in cpp_int.  Possible solution - add an additional MaxBits 
template argument that defaults to 0 (meaning keep going till no more space/memory).
* Add support for fused multiply add (and subtract).  GMP mpz_t could use this.
* Be a bit clearer on the effects of sign-magnitude representation of cpp_int - min == -max etc.
* Document cpp_dec_float precision, rounding, and exponent size.
* Can we be clearer in the docs that mixed arithmetic doesn't work?
* Document round functions behaviour better (they behave as in C99).
* Should there be a choice of rounding mode (probably MPFR specific)?

[endsect]

[section:ack Acknowledgements]

This library would not have happened without:

* Christopher Kormanyos' C++ decimal number code.
* Paul Bristow for patiently testing, and commenting on the library.
* All the folks at GMP, MPFR and libtommath, for providing the "guts" that makes this library work.
* [@http://www-cs-faculty.stanford.edu/~uno/taocp.html "The Art Of Computer Programming"], 
Donald E. Knuth, Volume 2: Seminumerical Algorithms, Third Edition 
(Reading, Massachusetts: Addison-Wesley, 1997), xiv+762pp. ISBN 0-201-89684-2

[endsect]

[endsect]

[section:indexes Indexes]

[include ../../../../../trunk/tools/auto_index/include/auto_index_helpers.qbk]
[named_index function_name Function Index]
[named_index class_name Class Index]
[named_index typedef_name Typedef Index]
[index]

[endsect]

