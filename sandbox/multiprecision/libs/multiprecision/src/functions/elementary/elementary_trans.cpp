
//          Copyright Christopher Kormanyos 2002 - 2011.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

// This work is based on an earlier work:
// "Algorithm 910: A Portable C++ Multiple-Precision System for Special-Function Calculations",
// in ACM TOMS, {VOL 37, ISSUE 4, (February 2011)} (C) ACM, 2011. http://doi.acm.org/10.1145/1916461.1916469

#include <vector>
#include <numeric>
#include <map>

#include <boost/array.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/multiprecision/mp_float_functions.hpp>
#include <boost/multiprecision/utility/util_power_x_pow_n.hpp>

using boost::multiprecision::mp_float;

mp_float boost::multiprecision::pown(const mp_float& x, const boost::int64_t p)
{
  return boost::multiprecision::utility::x_pow_n_template<mp_float>(x, p);
}

mp_float boost::multiprecision::pow2(const boost::int64_t p)
{
  // Create a static const table of p^2 for -128 < p < +128.
  // Note: The size of this table must be odd-numbered and
  // symmetric about 0.
  static const boost::array<mp_float, 255u> p2_data =
  {{
    mp_float("5.877471754111437539843682686111228389093327783860437607543758531392086297273635864257812500000000000e-39"),
    mp_float("1.175494350822287507968736537222245677818665556772087521508751706278417259454727172851562500000000000e-38"),
    mp_float("2.350988701644575015937473074444491355637331113544175043017503412556834518909454345703125000000000000e-38"),
    mp_float("4.701977403289150031874946148888982711274662227088350086035006825113669037818908691406250000000000000e-38"),
    mp_float("9.403954806578300063749892297777965422549324454176700172070013650227338075637817382812500000000000000e-38"),
    mp_float("1.880790961315660012749978459555593084509864890835340034414002730045467615127563476562500000000000000e-37"),
    mp_float("3.761581922631320025499956919111186169019729781670680068828005460090935230255126953125000000000000000e-37"),
    mp_float("7.523163845262640050999913838222372338039459563341360137656010920181870460510253906250000000000000000e-37"),
    mp_float("1.504632769052528010199982767644474467607891912668272027531202184036374092102050781250000000000000000e-36"),
    mp_float("3.009265538105056020399965535288948935215783825336544055062404368072748184204101562500000000000000000e-36"),
    mp_float("6.018531076210112040799931070577897870431567650673088110124808736145496368408203125000000000000000000e-36"),
    mp_float("1.203706215242022408159986214115579574086313530134617622024961747229099273681640625000000000000000000e-35"),
    mp_float("2.407412430484044816319972428231159148172627060269235244049923494458198547363281250000000000000000000e-35"),
    mp_float("4.814824860968089632639944856462318296345254120538470488099846988916397094726562500000000000000000000e-35"),
    mp_float("9.629649721936179265279889712924636592690508241076940976199693977832794189453125000000000000000000000e-35"),
    mp_float("1.925929944387235853055977942584927318538101648215388195239938795566558837890625000000000000000000000e-34"),
    mp_float("3.851859888774471706111955885169854637076203296430776390479877591133117675781250000000000000000000000e-34"),
    mp_float("7.703719777548943412223911770339709274152406592861552780959755182266235351562500000000000000000000000e-34"),
    mp_float("1.540743955509788682444782354067941854830481318572310556191951036453247070312500000000000000000000000e-33"),
    mp_float("3.081487911019577364889564708135883709660962637144621112383902072906494140625000000000000000000000000e-33"),
    mp_float("6.162975822039154729779129416271767419321925274289242224767804145812988281250000000000000000000000000e-33"),
    mp_float("1.232595164407830945955825883254353483864385054857848444953560829162597656250000000000000000000000000e-32"),
    mp_float("2.465190328815661891911651766508706967728770109715696889907121658325195312500000000000000000000000000e-32"),
    mp_float("4.930380657631323783823303533017413935457540219431393779814243316650390625000000000000000000000000000e-32"),
    mp_float("9.860761315262647567646607066034827870915080438862787559628486633300781250000000000000000000000000000e-32"),
    mp_float("1.972152263052529513529321413206965574183016087772557511925697326660156250000000000000000000000000000e-31"),
    mp_float("3.944304526105059027058642826413931148366032175545115023851394653320312500000000000000000000000000000e-31"),
    mp_float("7.888609052210118054117285652827862296732064351090230047702789306640625000000000000000000000000000000e-31"),
    mp_float("1.577721810442023610823457130565572459346412870218046009540557861328125000000000000000000000000000000e-30"),
    mp_float("3.155443620884047221646914261131144918692825740436092019081115722656250000000000000000000000000000000e-30"),
    mp_float("6.310887241768094443293828522262289837385651480872184038162231445312500000000000000000000000000000000e-30"),
    mp_float("1.262177448353618888658765704452457967477130296174436807632446289062500000000000000000000000000000000e-29"),
    mp_float("2.524354896707237777317531408904915934954260592348873615264892578125000000000000000000000000000000000e-29"),
    mp_float("5.048709793414475554635062817809831869908521184697747230529785156250000000000000000000000000000000000e-29"),
    mp_float("1.009741958682895110927012563561966373981704236939549446105957031250000000000000000000000000000000000e-28"),
    mp_float("2.019483917365790221854025127123932747963408473879098892211914062500000000000000000000000000000000000e-28"),
    mp_float("4.038967834731580443708050254247865495926816947758197784423828125000000000000000000000000000000000000e-28"),
    mp_float("8.077935669463160887416100508495730991853633895516395568847656250000000000000000000000000000000000000e-28"),
    mp_float("1.615587133892632177483220101699146198370726779103279113769531250000000000000000000000000000000000000e-27"),
    mp_float("3.231174267785264354966440203398292396741453558206558227539062500000000000000000000000000000000000000e-27"),
    mp_float("6.462348535570528709932880406796584793482907116413116455078125000000000000000000000000000000000000000e-27"),
    mp_float("1.292469707114105741986576081359316958696581423282623291015625000000000000000000000000000000000000000e-26"),
    mp_float("2.584939414228211483973152162718633917393162846565246582031250000000000000000000000000000000000000000e-26"),
    mp_float("5.169878828456422967946304325437267834786325693130493164062500000000000000000000000000000000000000000e-26"),
    mp_float("1.033975765691284593589260865087453566957265138626098632812500000000000000000000000000000000000000000e-25"),
    mp_float("2.067951531382569187178521730174907133914530277252197265625000000000000000000000000000000000000000000e-25"),
    mp_float("4.135903062765138374357043460349814267829060554504394531250000000000000000000000000000000000000000000e-25"),
    mp_float("8.271806125530276748714086920699628535658121109008789062500000000000000000000000000000000000000000000e-25"),
    mp_float("1.654361225106055349742817384139925707131624221801757812500000000000000000000000000000000000000000000e-24"),
    mp_float("3.308722450212110699485634768279851414263248443603515625000000000000000000000000000000000000000000000e-24"),
    mp_float("6.617444900424221398971269536559702828526496887207031250000000000000000000000000000000000000000000000e-24"),
    mp_float("1.323488980084844279794253907311940565705299377441406250000000000000000000000000000000000000000000000e-23"),
    mp_float("2.646977960169688559588507814623881131410598754882812500000000000000000000000000000000000000000000000e-23"),
    mp_float("5.293955920339377119177015629247762262821197509765625000000000000000000000000000000000000000000000000e-23"),
    mp_float("1.058791184067875423835403125849552452564239501953125000000000000000000000000000000000000000000000000e-22"),
    mp_float("2.117582368135750847670806251699104905128479003906250000000000000000000000000000000000000000000000000e-22"),
    mp_float("4.235164736271501695341612503398209810256958007812500000000000000000000000000000000000000000000000000e-22"),
    mp_float("8.470329472543003390683225006796419620513916015625000000000000000000000000000000000000000000000000000e-22"),
    mp_float("1.694065894508600678136645001359283924102783203125000000000000000000000000000000000000000000000000000e-21"),
    mp_float("3.388131789017201356273290002718567848205566406250000000000000000000000000000000000000000000000000000e-21"),
    mp_float("6.776263578034402712546580005437135696411132812500000000000000000000000000000000000000000000000000000e-21"),
    mp_float("1.355252715606880542509316001087427139282226562500000000000000000000000000000000000000000000000000000e-20"),
    mp_float("2.710505431213761085018632002174854278564453125000000000000000000000000000000000000000000000000000000e-20"),
    mp_float("5.421010862427522170037264004349708557128906250000000000000000000000000000000000000000000000000000000e-20"),
    mp_float("1.084202172485504434007452800869941711425781250000000000000000000000000000000000000000000000000000000e-19"),
    mp_float("2.168404344971008868014905601739883422851562500000000000000000000000000000000000000000000000000000000e-19"),
    mp_float("4.336808689942017736029811203479766845703125000000000000000000000000000000000000000000000000000000000e-19"),
    mp_float("8.673617379884035472059622406959533691406250000000000000000000000000000000000000000000000000000000000e-19"),
    mp_float("1.734723475976807094411924481391906738281250000000000000000000000000000000000000000000000000000000000e-18"),
    mp_float("3.469446951953614188823848962783813476562500000000000000000000000000000000000000000000000000000000000e-18"),
    mp_float("6.938893903907228377647697925567626953125000000000000000000000000000000000000000000000000000000000000e-18"),
    mp_float("1.387778780781445675529539585113525390625000000000000000000000000000000000000000000000000000000000000e-17"),
    mp_float("2.775557561562891351059079170227050781250000000000000000000000000000000000000000000000000000000000000e-17"),
    mp_float("5.551115123125782702118158340454101562500000000000000000000000000000000000000000000000000000000000000e-17"),
    mp_float("1.110223024625156540423631668090820312500000000000000000000000000000000000000000000000000000000000000e-16"),
    mp_float("2.220446049250313080847263336181640625000000000000000000000000000000000000000000000000000000000000000e-16"),
    mp_float("4.440892098500626161694526672363281250000000000000000000000000000000000000000000000000000000000000000e-16"),
    mp_float("8.881784197001252323389053344726562500000000000000000000000000000000000000000000000000000000000000000e-16"),
    mp_float("1.776356839400250464677810668945312500000000000000000000000000000000000000000000000000000000000000000e-15"),
    mp_float("3.552713678800500929355621337890625000000000000000000000000000000000000000000000000000000000000000000e-15"),
    mp_float("7.105427357601001858711242675781250000000000000000000000000000000000000000000000000000000000000000000e-15"),
    mp_float("1.421085471520200371742248535156250000000000000000000000000000000000000000000000000000000000000000000e-14"),
    mp_float("2.842170943040400743484497070312500000000000000000000000000000000000000000000000000000000000000000000e-14"),
    mp_float("5.684341886080801486968994140625000000000000000000000000000000000000000000000000000000000000000000000e-14"),
    mp_float("1.136868377216160297393798828125000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    mp_float("2.273736754432320594787597656250000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    mp_float("4.547473508864641189575195312500000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    mp_float("9.094947017729282379150390625000000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    mp_float("1.818989403545856475830078125000000000000000000000000000000000000000000000000000000000000000000000000e-12"),
    mp_float("3.637978807091712951660156250000000000000000000000000000000000000000000000000000000000000000000000000e-12"),
    mp_float("7.275957614183425903320312500000000000000000000000000000000000000000000000000000000000000000000000000e-12"),
    mp_float("1.455191522836685180664062500000000000000000000000000000000000000000000000000000000000000000000000000e-11"),
    mp_float("2.910383045673370361328125000000000000000000000000000000000000000000000000000000000000000000000000000e-11"),
    mp_float("5.820766091346740722656250000000000000000000000000000000000000000000000000000000000000000000000000000e-11"),
    mp_float("1.164153218269348144531250000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    mp_float("2.328306436538696289062500000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    mp_float("4.656612873077392578125000000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    mp_float("9.313225746154785156250000000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    mp_float("1.862645149230957031250000000000000000000000000000000000000000000000000000000000000000000000000000000e-9"),
    mp_float("3.725290298461914062500000000000000000000000000000000000000000000000000000000000000000000000000000000e-9"),
    mp_float("7.450580596923828125000000000000000000000000000000000000000000000000000000000000000000000000000000000e-9"),
    mp_float("1.490116119384765625000000000000000000000000000000000000000000000000000000000000000000000000000000000e-8"),
    mp_float("2.980232238769531250000000000000000000000000000000000000000000000000000000000000000000000000000000000e-8"),
    mp_float("5.960464477539062500000000000000000000000000000000000000000000000000000000000000000000000000000000000e-8"),
    mp_float("1.192092895507812500000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    mp_float("2.384185791015625000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    mp_float("4.768371582031250000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    mp_float("9.536743164062500000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    mp_float("1.907348632812500000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-6"),
    mp_float("3.814697265625000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-6"),
    mp_float("7.629394531250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-6"),
    mp_float("0.000015258789062500000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.000030517578125000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.000061035156250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.000122070312500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.000244140625000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.000488281250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.000976562500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.001953125000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.003906250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.007812500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.01562500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.03125000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    mp_float("0.06250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    boost::multiprecision::eighth(),
    boost::multiprecision::quarter(),
    boost::multiprecision::half(),
    boost::multiprecision::one(),
    boost::multiprecision::two(),
    boost::multiprecision::four(),
    boost::multiprecision::eight(),
    mp_float(16),
    mp_float(32),
    mp_float(64),
    mp_float(128),
    mp_float(256),
    mp_float(512),
    mp_float(1024),
    mp_float(2048),
    mp_float(4096),
    mp_float(8192),
    mp_float(16384),
    mp_float(32768),
    mp_float(65536),
    mp_float(131072),
    mp_float(262144),
    mp_float(524288),
    mp_float(static_cast<boost::uint32_t>(1uL << 20u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 21u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 22u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 23u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 24u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 25u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 26u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 27u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 28u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 29u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 30u)),
    mp_float(static_cast<boost::uint32_t>(1uL << 31u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 32u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 33u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 34u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 35u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 36u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 37u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 38u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 39u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 40u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 41u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 42u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 43u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 44u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 45u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 46u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 47u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 48u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 49u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 50u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 51u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 52u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 53u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 54u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 55u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 56u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 57u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 58u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 59u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 60u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 61u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 62u)),
    mp_float(static_cast<boost::uint64_t>(1uLL << 63u)),
    mp_float("1.844674407370955161600000000000000000000000000000000000000000000000000000000000000000000000000000000e19"),
    mp_float("3.689348814741910323200000000000000000000000000000000000000000000000000000000000000000000000000000000e19"),
    mp_float("7.378697629483820646400000000000000000000000000000000000000000000000000000000000000000000000000000000e19"),
    mp_float("1.475739525896764129280000000000000000000000000000000000000000000000000000000000000000000000000000000e20"),
    mp_float("2.951479051793528258560000000000000000000000000000000000000000000000000000000000000000000000000000000e20"),
    mp_float("5.902958103587056517120000000000000000000000000000000000000000000000000000000000000000000000000000000e20"),
    mp_float("1.180591620717411303424000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    mp_float("2.361183241434822606848000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    mp_float("4.722366482869645213696000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    mp_float("9.444732965739290427392000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    mp_float("1.888946593147858085478400000000000000000000000000000000000000000000000000000000000000000000000000000e22"),
    mp_float("3.777893186295716170956800000000000000000000000000000000000000000000000000000000000000000000000000000e22"),
    mp_float("7.555786372591432341913600000000000000000000000000000000000000000000000000000000000000000000000000000e22"),
    mp_float("1.511157274518286468382720000000000000000000000000000000000000000000000000000000000000000000000000000e23"),
    mp_float("3.022314549036572936765440000000000000000000000000000000000000000000000000000000000000000000000000000e23"),
    mp_float("6.044629098073145873530880000000000000000000000000000000000000000000000000000000000000000000000000000e23"),
    mp_float("1.208925819614629174706176000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    mp_float("2.417851639229258349412352000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    mp_float("4.835703278458516698824704000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    mp_float("9.671406556917033397649408000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    mp_float("1.934281311383406679529881600000000000000000000000000000000000000000000000000000000000000000000000000e25"),
    mp_float("3.868562622766813359059763200000000000000000000000000000000000000000000000000000000000000000000000000e25"),
    mp_float("7.737125245533626718119526400000000000000000000000000000000000000000000000000000000000000000000000000e25"),
    mp_float("1.547425049106725343623905280000000000000000000000000000000000000000000000000000000000000000000000000e26"),
    mp_float("3.094850098213450687247810560000000000000000000000000000000000000000000000000000000000000000000000000e26"),
    mp_float("6.189700196426901374495621120000000000000000000000000000000000000000000000000000000000000000000000000e26"),
    mp_float("1.237940039285380274899124224000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    mp_float("2.475880078570760549798248448000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    mp_float("4.951760157141521099596496896000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    mp_float("9.903520314283042199192993792000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    mp_float("1.980704062856608439838598758400000000000000000000000000000000000000000000000000000000000000000000000e28"),
    mp_float("3.961408125713216879677197516800000000000000000000000000000000000000000000000000000000000000000000000e28"),
    mp_float("7.922816251426433759354395033600000000000000000000000000000000000000000000000000000000000000000000000e28"),
    mp_float("1.584563250285286751870879006720000000000000000000000000000000000000000000000000000000000000000000000e29"),
    mp_float("3.169126500570573503741758013440000000000000000000000000000000000000000000000000000000000000000000000e29"),
    mp_float("6.338253001141147007483516026880000000000000000000000000000000000000000000000000000000000000000000000e29"),
    mp_float("1.267650600228229401496703205376000000000000000000000000000000000000000000000000000000000000000000000e30"),
    mp_float("2.535301200456458802993406410752000000000000000000000000000000000000000000000000000000000000000000000e30"),
    mp_float("5.070602400912917605986812821504000000000000000000000000000000000000000000000000000000000000000000000e30"),
    mp_float("1.014120480182583521197362564300800000000000000000000000000000000000000000000000000000000000000000000e31"),
    mp_float("2.028240960365167042394725128601600000000000000000000000000000000000000000000000000000000000000000000e31"),
    mp_float("4.056481920730334084789450257203200000000000000000000000000000000000000000000000000000000000000000000e31"),
    mp_float("8.112963841460668169578900514406400000000000000000000000000000000000000000000000000000000000000000000e31"),
    mp_float("1.622592768292133633915780102881280000000000000000000000000000000000000000000000000000000000000000000e32"),
    mp_float("3.245185536584267267831560205762560000000000000000000000000000000000000000000000000000000000000000000e32"),
    mp_float("6.490371073168534535663120411525120000000000000000000000000000000000000000000000000000000000000000000e32"),
    mp_float("1.298074214633706907132624082305024000000000000000000000000000000000000000000000000000000000000000000e33"),
    mp_float("2.596148429267413814265248164610048000000000000000000000000000000000000000000000000000000000000000000e33"),
    mp_float("5.192296858534827628530496329220096000000000000000000000000000000000000000000000000000000000000000000e33"),
    mp_float("1.038459371706965525706099265844019200000000000000000000000000000000000000000000000000000000000000000e34"),
    mp_float("2.076918743413931051412198531688038400000000000000000000000000000000000000000000000000000000000000000e34"),
    mp_float("4.153837486827862102824397063376076800000000000000000000000000000000000000000000000000000000000000000e34"),
    mp_float("8.307674973655724205648794126752153600000000000000000000000000000000000000000000000000000000000000000e34"),
    mp_float("1.661534994731144841129758825350430720000000000000000000000000000000000000000000000000000000000000000e35"),
    mp_float("3.323069989462289682259517650700861440000000000000000000000000000000000000000000000000000000000000000e35"),
    mp_float("6.646139978924579364519035301401722880000000000000000000000000000000000000000000000000000000000000000e35"),
    mp_float("1.329227995784915872903807060280344576000000000000000000000000000000000000000000000000000000000000000e36"),
    mp_float("2.658455991569831745807614120560689152000000000000000000000000000000000000000000000000000000000000000e36"),
    mp_float("5.316911983139663491615228241121378304000000000000000000000000000000000000000000000000000000000000000e36"),
    mp_float("1.063382396627932698323045648224275660800000000000000000000000000000000000000000000000000000000000000e37"),
    mp_float("2.126764793255865396646091296448551321600000000000000000000000000000000000000000000000000000000000000e37"),
    mp_float("4.253529586511730793292182592897102643200000000000000000000000000000000000000000000000000000000000000e37"),
    mp_float("8.507059173023461586584365185794205286400000000000000000000000000000000000000000000000000000000000000e37"),
    mp_float("1.701411834604692317316873037158841057280000000000000000000000000000000000000000000000000000000000000e38")
  }};

  if((p > static_cast<boost::int64_t>(-128)) && (p < static_cast<boost::int64_t>(+128)))
  {
    return p2_data[static_cast<std::size_t>(p + ((p2_data.size() - 1u) / 2u))];
  }

  // Compute and return 2^p.
  if(p < static_cast<boost::int64_t>(0))
  {
    return boost::multiprecision::pow2(static_cast<boost::int64_t>(-p)).calculate_inv();
  }
  else if(p < static_cast<boost::int64_t>(std::numeric_limits<boost::uint64_t>::digits))
  {
    const boost::uint64_t p2 = static_cast<boost::uint64_t>(static_cast<boost::uint64_t>(1uLL) << p);
    return mp_float(p2);
  }
  else
  {
    return boost::multiprecision::utility::x_pow_n_template(boost::multiprecision::two(), p);
  }
}

mp_float boost::multiprecision::inv (const mp_float& x) { return mp_float(x).calculate_inv(); }
mp_float boost::multiprecision::sqrt(const mp_float& x) { return mp_float(x).calculate_sqrt(); }

mp_float boost::multiprecision::cbrt(const mp_float& x)
{
  return boost::multiprecision::rootn(x, static_cast<boost::int32_t>(3));
}

namespace
{
  mp_float my_rootn_inv(const mp_float& x, const boost::int32_t p)
  {
    // Compute the value of [1 / (rootn of x)] with n = p.

    // Generate the initial estimate using 1 / rootn.
    // Extract the mantissa and exponent for a "manual"
    // computation of the estimate.
    double dd;
    boost::int64_t  ne;
    boost::multiprecision::to_parts(x, dd, ne);

    // Adjust exponent and mantissa such that ne is an even power of p.
    while(ne % static_cast<boost::int64_t>(p))
    {
      ++ne;
      dd /= 10.0;
    }
  
    // Estimate the one over the root using simple manipulations.
    const double one_over_rtn_d = ::pow(dd, -1.0 / static_cast<double>(p));

    // Set the result equal to the initial guess.
    mp_float result(one_over_rtn_d, static_cast<boost::int64_t>(-ne / p));

    static const boost::int32_t double_digits10_minus_one = static_cast<boost::int32_t>(static_cast<boost::int32_t>(std::numeric_limits<double>::digits10) - static_cast<boost::int32_t>(1));

    for(boost::int32_t digits = double_digits10_minus_one; digits <= static_cast<boost::int32_t>(boost::multiprecision::tol()); digits *= static_cast<boost::int32_t>(2))
    {
      // Adjust precision of the terms.
      result.precision(static_cast<boost::int32_t>(digits * static_cast<boost::int32_t>(2)));

      // Next iteration
      mp_float term = (((-boost::multiprecision::pown(result, p) * x) + boost::multiprecision::one()) / p) + boost::multiprecision::one();

      term.precision(static_cast<boost::int32_t>(digits * static_cast<boost::int32_t>(2)));

      result *= term;
  
    }

    result.precision(static_cast<boost::int32_t>(boost::multiprecision::tol()));

    return result;
  }
}

mp_float boost::multiprecision::rootn(const mp_float& x, const boost::int32_t p)
{
  if(!boost::multiprecision::isfinite(x))
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  if(p < static_cast<boost::int32_t>(0))
  {
    return boost::multiprecision::rootn(boost::multiprecision::one() / x, static_cast<boost::int32_t>(-p));
  }

  if((p == static_cast<boost::int32_t>(0)) || boost::multiprecision::isneg(x))
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }
  else if(p == static_cast<boost::int32_t>(1))
  {
    return x;
  }
  else if(p == static_cast<boost::int32_t>(2))
  {
    return boost::multiprecision::sqrt(x);
  }
  else if((p == static_cast<boost::int32_t>(3)) && x.has_its_own_cbrt())
  {
    return mp_float::my_cbrt(x);
  }

  const mp_float rtn =  (x.has_its_own_rootn() ? mp_float::my_rootn(x, p)
                                               : ::my_rootn_inv(x, p).calculate_inv());

  return rtn;
}

mp_float boost::multiprecision::exp(const mp_float& x)
{
  if(x.has_its_own_exp())
  {
    return mp_float::my_exp(x);
  }

  // Handle special arguments.
  if(boost::multiprecision::isnan(x))
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  if(boost::multiprecision::isinf(x))
  {
    return ((!boost::multiprecision::isneg(x)) ? std::numeric_limits<mp_float>::infinity() : boost::multiprecision::zero());
  }

  if(boost::multiprecision::iszero(x) || (x.order() < -boost::multiprecision::tol()))
  {
    return boost::multiprecision::one();
  }

  // Get local copy of argument and force it to be positive.
  const bool bo_x_is_neg = boost::multiprecision::isneg(x);

  const mp_float xx = ((!bo_x_is_neg) ? x : -x);

  // Check the range of the argument.
  static const mp_float maximum_arg_for_exp = std::numeric_limits<mp_float>::max_exponent;

  if(xx > maximum_arg_for_exp)
  {
    // Overflow / underflow
    return ((!bo_x_is_neg) ? std::numeric_limits<mp_float>::infinity() : boost::multiprecision::zero());
  }

  // Check for pure-integer arguments which can be either signed or unsigned.
  if(boost::multiprecision::isint(x))
  {
    return boost::multiprecision::pown(boost::multiprecision::exp1(), boost::multiprecision::to_int64(x));
  }

  // The algorithm for exp has been taken from MPFUN.
  // exp(t) = [ (1 + r + r^2/2! + r^3/3! + r^4/4! ...)^p2 ] * 2^n
  // where p2 is a power of 2 such as 2048, r = t_prime / p2, and
  // t_prime = t - n*ln2, with n chosen to minimize the absolute
  // value of t_prime. In the resulting Taylor series, which is
  // implemented as a hypergeometric function, |r| is bounded by
  // ln2 / p2. For small arguments, no scaling is done.

  const bool b_scale = (xx.order() > static_cast<boost::int64_t>(-4));

  // Compute the exponential series of the (possibly) scaled argument.
  mp_float exp_series;

  if(b_scale)
  {
    // Compute 1 / ln2 as a warm-cached constant value.
    static const mp_float one_over_ln2 = boost::multiprecision::one() / boost::multiprecision::ln2();

    const mp_float nf = boost::multiprecision::integer_part(xx * one_over_ln2);

    // The scaling is 2^11 = 2048.
    const boost::int32_t p2 = static_cast<boost::int32_t>(boost::uint32_t(1u) << 11);

    exp_series = boost::multiprecision::pown(boost::multiprecision::hyp0F0((xx - (nf * boost::multiprecision::ln2())) / p2), static_cast<boost::int64_t>(p2)) * boost::multiprecision::pow2(boost::multiprecision::to_int64(nf));
  }
  else
  {
    exp_series = boost::multiprecision::hyp0F0(xx);
  }

  return ((!bo_x_is_neg) ? exp_series : (boost::multiprecision::one() / exp_series));
}

namespace
{
  mp_float my_log_series_at_one(const mp_float& x)
  {
    // This subroutine computes the series representation of Log[1 + x]
    // for small x without losing precision.

    // http://functions.wolfram.com/ElementaryFunctions/Log/26/01/01/

    return x * boost::multiprecision::hyp2F1( boost::multiprecision::one(), boost::multiprecision::one(), boost::multiprecision::two(), -x);
  }
}

mp_float boost::multiprecision::log(const mp_float& x)
{
  // Handle special arguments.
  if(boost::multiprecision::isnan(x) || boost::multiprecision::isneg(x) || boost::multiprecision::isinf(x))
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  if(x.has_its_own_log())
  {
    return mp_float::my_log(x);
  }

  if(boost::multiprecision::iszero(x))
  {
    return -std::numeric_limits<mp_float>::infinity();
  }

  if(boost::multiprecision::isone(x))
  {
    return boost::multiprecision::zero();
  }

  // Make a local copy
  mp_float xx = x;

  // Compute the delta of the argument compared to one.
  const mp_float x_minus_one  = xx - boost::multiprecision::one();

  if(boost::multiprecision::near_one(xx))
  {
    return ::my_log_series_at_one(x_minus_one);
  }

  // For large arguments, the value will be broken into two parts
  // in order to facilitate the convergence of the Newton iteration.
  const bool b_correction = (   (xx.order() > static_cast<boost::int64_t>(+1000))
                             || (xx.order() < static_cast<boost::int64_t>(-1000)));

  mp_float correction;

  if(b_correction)
  {
    // The argument xx is of the form a * 10^b.
    // It will be broken into two parts: log(a) + b * log(10).
    const bool b_neg_exp = (xx.order() < static_cast<boost::int64_t>(0));

    // Remove a large power of ten from the argument. But be sure to leave the argument
    // large enough (or small enough) to avoid entering the near-one range.
    const boost::int64_t n_order   = xx.order();
    const boost::int64_t n_exp     = ((!b_neg_exp) ? n_order : -n_order);
    const boost::int64_t delta_exp = static_cast<boost::int64_t>(n_exp - static_cast<boost::int64_t>(8));

    // Convert the scaling power of ten to a string and subsequently to an mp_float.
    const mp_float mp_delta_exp("1E" + boost::lexical_cast<std::string>(delta_exp));

    !b_neg_exp ? xx /= mp_delta_exp : xx *= mp_delta_exp;

    correction  = boost::multiprecision::ln10() * mp_float(delta_exp);

    if(b_neg_exp)
    {
      correction = -correction;
    }
  }

  // Generate the initial estimate using double precision log combined with
  // the exponent for a "manual" computation of the initial iteration estimate.

  static const double lg10_d = ::log(10.0);

  static const boost::int64_t n32_min = static_cast<boost::int64_t>((std::numeric_limits<boost::int32_t>::min)());
  static const boost::int64_t n32_max = static_cast<boost::int64_t>((std::numeric_limits<boost::int32_t>::max)());

  // computation of the estimate.
  double dd;
  boost::int64_t  ne;
  boost::multiprecision::to_parts(xx, dd, ne);

  const double nd = ((ne < static_cast<boost::int64_t>(0)) ? static_cast<double>(static_cast<boost::int32_t>((std::max)(ne, n32_min)))
                                                  : static_cast<double>(static_cast<boost::int32_t>((std::min)(ne, n32_max))));

  const double dlog = ::log(dd) + (nd * lg10_d);

  const double d10  = ((!boost::multiprecision::iszero(dlog)) ? ::log10(::fabs(dlog)) + 0.5 : 0.0);

  const boost::int64_t  p10  =  (boost::multiprecision::ispos(dlog)  ? static_cast<boost::int64_t>(d10) : static_cast<boost::int64_t>(-d10));

  mp_float log_val   = ((!boost::multiprecision::iszero(dlog)) ? mp_float(dlog / ::pow(10.0, static_cast<double>(static_cast<boost::int32_t>(p10))), p10)
                      : x_minus_one);

  // Newton-Raphson iteration
  static const boost::int32_t double_digits10_minus_one = static_cast<boost::int32_t>(static_cast<boost::int32_t>(std::numeric_limits<double>::digits10) - static_cast<boost::int32_t>(1));

  for(boost::int32_t digits = double_digits10_minus_one; digits <= static_cast<boost::int32_t>(boost::multiprecision::tol()); digits *= static_cast<boost::int32_t>(2))
  {
    // Adjust precision of the terms.
    log_val.precision(static_cast<boost::int32_t>(digits * static_cast<boost::int32_t>(2)));
         xx.precision(static_cast<boost::int32_t>(digits * static_cast<boost::int32_t>(2)));

    const mp_float exp_minus_log = boost::multiprecision::exp(-log_val);

    log_val += (xx * exp_minus_log) - boost::multiprecision::one();
  }

  return ((!b_correction) ? log_val : log_val + correction);
}

mp_float boost::multiprecision::log10(const mp_float& x)                    { return boost::multiprecision::log(x) / boost::multiprecision::ln10(); }
mp_float boost::multiprecision::loga (const mp_float& a, const mp_float& x) { return boost::multiprecision::log(x) / boost::multiprecision::log(a); }
mp_float boost::multiprecision::log1p(const mp_float& x)                    { return ::my_log_series_at_one(x); }

mp_float boost::multiprecision::log1p1m2(const mp_float& x)
{
  // This subroutine calculates the series representation of (1/2) Log[(1 + x) / (1 - x)]
  // for small x without losing precision.

  if(!boost::multiprecision::isfinite(x))
  {
    return x;
  }

  if((x <= boost::multiprecision::one_minus()) || (x >= boost::multiprecision::one()))
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  // for values of x near one.
  const mp_float x2 = x * x;
        mp_float xn = x;

  mp_float sum = xn;

  // Series representation of (1/2) Log[(1 + x) / (1 - x)] as given in
  // Schaum's Outlines: Mathematical Handbook of Formulas and Tables,
  // Second Edition, equation 22.8, page 136.
  for(boost::int32_t n = static_cast<boost::int32_t>(3); n < boost::multiprecision::max_iteration(); n += static_cast<boost::int32_t>(2))
  {
    xn *= x2;

    const mp_float term = xn / n;

    if(n > static_cast<boost::int32_t>(20))
    {
      const boost::int64_t order_check = static_cast<boost::int64_t>(term.order() - sum.order());

      if(order_check < -boost::multiprecision::tol())
      {
        break;
      }
    }

    sum += term;
  }

  return sum;
}

mp_float boost::multiprecision::pow(const mp_float& x, const mp_float& a)
{
  if(!boost::multiprecision::isfinite(x) || boost::multiprecision::isone(a))
  {
    return x;
  }

  if(boost::multiprecision::iszero(x))
  {
    return boost::multiprecision::one();
  }
  
  if(boost::multiprecision::iszero(a))
  {
    return boost::multiprecision::one();
  }

  const bool bo_a_isint = boost::multiprecision::isint(a);

  if(boost::multiprecision::isneg(x) && !bo_a_isint)
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  if(a <= boost::multiprecision::one_minus())
  {
    return boost::multiprecision::one() / boost::multiprecision::pow(x, -a);
  }

  const mp_float a_int    = boost::multiprecision::integer_part(a);
  const boost::int64_t an = boost::multiprecision::to_int64(a_int);
  const mp_float da       = a - a_int;

  if(bo_a_isint)
  {
    return boost::multiprecision::pown(x, an);
  }

  if(boost::multiprecision::ispos(x) && (x > boost::multiprecision::tenth()) && (x < boost::multiprecision::half()))
  {
    if(boost::multiprecision::small_arg(a))
    {
      // Series expansion for small a.
      return boost::multiprecision::hyp0F0(a * boost::multiprecision::log(x));
    }
    else
    {
      // Series expansion for moderately sized x. Note that for large power of a,
      // the power of the integer part of a is calculated using the pown function.
      return ((an != static_cast<boost::int64_t>(0)) ? boost::multiprecision::hyp1F0(-da, boost::multiprecision::one() - x) * boost::multiprecision::pown(x, an)
                                                     : boost::multiprecision::hyp1F0( -a, boost::multiprecision::one() - x));
    }
  }
  else
  {
    // Series expansion for pow(x, a). Note that for large power of a, the power
    // of the integer part of a is calculated using the pown function.
    return ((an != static_cast<boost::int64_t>(0)) ? boost::multiprecision::exp(da * boost::multiprecision::log(x)) * boost::multiprecision::pown(x, an)
                                          : boost::multiprecision::exp( a * boost::multiprecision::log(x)));
  }
}

mp_float boost::multiprecision::sinh(const mp_float& x)
{
  if(x.has_its_own_sinh())
  {
    return mp_float::my_sinh(x);
  }

  if(!boost::multiprecision::isfinite(x))
  {
    return x;
  }

  mp_float s;
  boost::multiprecision::sinhcosh(x, &s, static_cast<mp_float*>(0u));
  return s;
}

mp_float boost::multiprecision::cosh(const mp_float& x)
{
  if(x.has_its_own_cosh())
  {
    return mp_float::my_cosh(x);
  }

  if(!boost::multiprecision::isfinite(x))
  {
    return x;
  }

  mp_float c;
  boost::multiprecision::sinhcosh(x, static_cast<mp_float*>(0u), &c);
  return c;
}

void boost::multiprecision::sinhcosh(const mp_float& x, mp_float* const p_sinh, mp_float* const p_cosh)
{
  if(!boost::multiprecision::isfinite(x) || (!p_sinh && !p_cosh))
  {
    return;
  }
  
  if(boost::multiprecision::iszero(x))
  {
    if(p_sinh)
    {
      *p_sinh = boost::multiprecision::zero();
    }

    if(p_cosh)
    {
      *p_cosh = boost::multiprecision::one();
    }
    
    return;
  }

  const mp_float e_px = boost::multiprecision::exp(x);
  const mp_float e_mx = boost::multiprecision::one() / e_px;

  if(p_sinh != static_cast<mp_float* const>(0u)) { *p_sinh  = (e_px - e_mx) / static_cast<boost::int32_t>(2); }
  if(p_cosh != static_cast<mp_float* const>(0u)) { *p_cosh  = (e_px + e_mx) / static_cast<boost::int32_t>(2); }
}

mp_float boost::multiprecision::tanh(const mp_float& x)
{
  if(x.has_its_own_tanh())
  {
    return mp_float::my_tanh(x);
  }

  mp_float c, s;
  boost::multiprecision::sinhcosh(x, &s, &c);
  return s * c.calculate_inv();
}

mp_float boost::multiprecision::asinh(const mp_float& x)
{
  if(x.has_its_own_asinh())
  {
    return mp_float::my_asinh(x);
  }

  if(!boost::multiprecision::isfinite(x))
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  if(boost::multiprecision::iszero(x))
  {
    return boost::multiprecision::zero();
  }
  else
  {
    const mp_float value = boost::multiprecision::log(boost::multiprecision::fabs(x) + boost::multiprecision::sqrt((x * x) + boost::multiprecision::one()));

    return !boost::multiprecision::isneg(x) ? value : -value;
  }
}

mp_float boost::multiprecision::acosh(const mp_float& x)
{
  if(x.has_its_own_acosh())
  {
    return mp_float::my_acosh(x);
  }

  if(!boost::multiprecision::isfinite(x))
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  if(boost::multiprecision::isneg(x) || x < boost::multiprecision::one())
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  if(boost::multiprecision::isone(x))
  {
    return boost::multiprecision::one();
  }

  const mp_float x_minus_one = x - boost::multiprecision::one();

  if(boost::multiprecision::small_arg(x_minus_one))
  {
    return   (boost::multiprecision::sqrt2() * boost::multiprecision::sqrt(x_minus_one))
           *  boost::multiprecision::hyp2F1( boost::multiprecision::half(),
                          boost::multiprecision::half(),
                          boost::multiprecision::three_half(),
                         -x_minus_one / static_cast<boost::int32_t>(2));
  }
  else
  {
    return boost::multiprecision::log(x + boost::multiprecision::sqrt((x * x) - boost::multiprecision::one()));
  }
}

mp_float boost::multiprecision::atanh(const mp_float& x)
{
  if(x.has_its_own_atanh())
  {
    return mp_float::my_atanh(x);
  }

  if(!boost::multiprecision::isfinite(x))
  {
    return x;
  }

  const mp_float xx = boost::multiprecision::fabs(x);
  
  if(xx >= boost::multiprecision::one())
  {
    return std::numeric_limits<mp_float>::quiet_NaN();
  }

  const mp_float value = (boost::multiprecision::small_arg(x) ?  boost::multiprecision::log1p1m2(x)
                                          : (boost::multiprecision::log((boost::multiprecision::one() + x) / (boost::multiprecision::one() - x)) / static_cast<boost::int32_t>(2)));

  return ((!boost::multiprecision::isneg(xx)) ? value : -value);
}
