[book Boost.Maps
    [quickbook 1.5]
    [authors [Smith, Brian]]
    [copyright 2010-2011 Brian Smith]
    [id maps]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section:introduction Introduction]

The Boost maps library provides sequence containers for statically and dynamically 
allocated multi-dimensional arrays. The implementations allow standard data element types, 
data element initialization, subject to conditions imposed by the data element type, and the 
choice of allocator used for memory allocation, element construction, etc., where appropriate.
The library also includes scalar and fixed-size vector and matrix class templates with a DSEL 
implementation of operators via expression templates.

The [link maps.concepts Concepts] section provides an overview of the library as well as a 
discussion of the supplementary structures that interoperate with the main classes in the 
library.

*[link maps.concepts Concepts]
*[link maps.tutorial Tutorial]
*[link maps.reference Reference]

[endsect]

[section:concepts Concepts]

[section:introduction Introduction]

The array of array specification for statically allocated intrinsic multi-dimensional arrays is 
conceptually well defined in C++. The fixed-size array class templates discussed here include 
versions whose data member is an intrinsic multi-dimensional array. The arrays' shape is 
determined from a compile time supplied set of bounds. An alternative approach to constructing 
multi-dimensional arrays results from using pointers. The structural components in this case 
are allocated dynamically at runtime allowing for both fixed-size and resizeable varieties. The 
approach taken here is to allocate all the elements at each dimension in a continuous block of 
memory from a given set of bounds. For fixed-size arrays this again means the bounds are set at 
compile time. A resizeable array must be passed a set of bounds in order to construct it in 
addition to the purpose of resizing.

[endsect] [/ Introduction]

[section:fixed_size_arrays Fixed-Size Arrays]

The array types `array` and `array_` define objects that satisfy the notion of a
multi-dimensional array. The data member type generated for the array depends on the 
template arguments to the class. The header `<array.hpp>` defines the class template,

    template< class T, class B, bool I, class A > class array;

Here, 

* `T` is the data type the array holds.
* `B` is a `boundsN` sequence of `N` non-zero positive integers.
* `I` is the zero/default initialization parameter.
* `A` is an allocator type.

The sequence argument, `B`, determines the dimensionality, `N`, of the array, 
as well as the size of each dimension. The library defines a `null::allocator` type which 
is the default allocator type for the class. If a `null::allocator` is used for the 
template argument `A` then the resulting data member is a statically allocated array of 
`N` dimensions with the size of each dimension given by successive values in the argument 
sequence `B`, and with data elements of type `T`, where the usual restrictions on type `T`
apply. Otherwise the array data member is the type `T` or its non-reference 
equivalent, which from here on its assumed to be, with `N` pointer symbols appended and is 
constructed at runtime in accordance with template argument's `B`, `I` and `A`. In either 
case if the argument `T` has a non-trivial constructor the data elements will be 
constructed during the construction of the array, standard case for intrinsic 
arrays, otherwise data element construction will depend on the argument `I`, whose default 
value is `true`. Therefore, arguments are always required for both `T` and `B`, while 
`I` and `A` are optional.  
        
As an illustration the following declaration produces an `array` object with data member
type `int[3][4][5][4][3]` and zero initialized data elements.

    array< int, bounds5< 3,4,5,4,3 > > a;

If we now consider the declaration,

    array< int, bounds5< 3,4,5,4,3 >, false, std::allocator< int > > a;

The `array` object's data member in this case is an `int*****` whose runtime construction 
requires five memory allocations with the data elements left uninitialized. A point of note 
concerns the allocator type used in the previous declaration. Strictly, it should have been 
`std::allocator< int**** >`, however the nested `rebind` struct in the original 
declaration's allocator is used to bind the template parameter to the correct type. Since 
a non-static N-dimensional array requires N allocations for N different types, N different 
allocators are necessary to fully construct the resulting array.
       
The header `<array_.hpp>` defines the class template,

    template< class T, std::size_t N, std::size_t D, bool I, class A > class array_;
 
Here, 

* `T` is the data type the array holds.
* `N` is the dimensionality of the array.
* `D` is the size of each of the `N` dimensions of the array.
* `I` is the zero/default initialization parameter.
* `A` is an allocator type.

The template parameters `T`, `I` and `A` have the same meaning, requirements and default 
behaviour as the `array` class template discussed previously. An `array_` object has 
dimensionality `N` with each dimension taking the fixed value `D`, both of which are 
required parameters. Thus, in the following declaration the data member type is 
`int[5][5][5][5][5]` with zero initialized data elements.

    array_< int, 5,5 > a;

The dynamically allocated version with uninitialized data elements results from,

    array_< int, 5,5, false, std::allocator< int > > a;

[endsect] [/ Fixed-Size Arrays]

[section:resizeable_arrays Resizeable Arrays]

The arrays discussed in this section satisfy the notion of a dynamically allocated 
multi-dimensional array. The header `<pointer.hpp>` defines the class template,

    template< class T, std::size_t N, bool I, class A > class pointer;

Here, 

* `T` is the data type the array holds.
* `N` is the dimensionality of the array.
* `I` is the zero/default initialization parameter.
* `A` is an allocator type.

Parameters `T` and `N` are both required, while `I` and `A` are optional, with respective 
default's `false` and `std::allocator< T >`. In order to construct a `pointer` type with 
specific dimensions the auxiliary type `bounds`, defined in the header `<bounds.hpp>`, is 
required. A `bounds` type is a template array type with a single `std::size_t` parameter 
that determines the number of `std::size_t` type elements the array should hold. 
Notwithstanding Scott Meyers item[footnote Scott Meyers, More Effective C++, Addison Wesley 
Longman, Inc., 1996, item 7.] and similar to Blitz++[footnote Todd Veldhuizen, Blitz++, 
[@http://www.oonumerics.org/blitz/].] arrays the comma operator has been overloaded for 
convenience. The following declaration and assignment results in the `bounds` array `b` 
having values 3, 4, 5, 4 and 3 respectively.

    bounds<5> b;
    b = 3,4,5,4,3;

Creating a `pointer` object with uninitialized data elements then follows as,

    pointer< double, 5 > a( b );

To continue, we can further write,
 
    b = 5,4,3,4,5;
    a.resize< false >( b );

This results in the array being resized to the updated values in `b` without preserving the 
values already present in `a`. For a `pointer` type with dimensionality `N`, `N` memory 
allocations are again required. However, for an already constructed array such as `a` above 
it is only necessary to make a request for memory during resizing if the total number of 
elements required for each dimension is different from that already present. At least this 
is the case for all but the final request where a memory allocation is required if the 
template argument to `resize` is `false` or if the template argument to `resize` is `true` 
and the total number of elements differs from the requested new total, thus maintaining the 
exception guarantee specified for the class. For example, in the resize operation above the 
third request for memory is to accommodate 5 x 4 x 3 = 60 elements, while 3 x 4 x 5 = 60 
elements of the required type are already present, hence, no request for memory is needed. 
Pedantically, the types `dimensions` and `indexes` may be used in place of a `bounds` type 
for construction and element access of a resizeable array. 

[endsect] [/ Resizeable Arrays]

[section:array_views Array Views]

Accessing the elements of an array can be considered from a number of perspectives that 
inevitably depends on the particular application and patterns in the data represented 
by the elements. The indexing operator for example is used to access individual elements of 
an array. However access to specific non-/continuous sequences of elements in the form of 
slices or subarrays may be required. For an N-dimensional array a slice can be represented 
in 1 to N-1 dimensions whereas subarrays of N-dimensional arrays are themselves N-dimensional 
arrays. A `view` is a resizeable N-dimensional array of the same dimensionality as the array used 
to define it. The data elements can be either pointers to or copies of some sequence of data 
elements from an array whose type parameterizes the `view`. 

The header `<view.hpp>` defines the class template,

    template< class A, bool B > class view;

Here,

* `A` is the array type the `view` will be constructed from.
* `B` signifies our intention to store pointers on an argument of type `A` or otherwise. 

`A` is a required parameter while `B` is optional with default value `true`, i.e. stores 
pointers to some sequence of data elements from an array of type `A`. The `view` type 
contains the nested class template `range`, used to set three values, first, last and 
step, over one dimension of an array of type `A`. The relationship between first, last and 
step can be considered analogous to the following `for` statement. 

    for( std::size_t i = first; i != last; i += step )  { ... }

The single template parameter of a `range` is the type `std::size_t` that determines which 
dimension the `range` is associated with. For an N-dimensional array, N `range`'s should be 
set which together form the sequence of data elements from an argument of type `A` that the 
`view` will store. The `range` constructor expects an argument of type `view`. Implicitly a 
`view` must be declared before setting the `range`'s and subsequently an argument of type 
`A` is passed to the `view`'s  `reset` method in order to construct it. To clarify, consider 
the following,

    typedef array_< double, 3,7, true > A;
    typedef view< A > V;

    A a;
    V v;
        
    V::range<0> r0( v ); r0 = 1,7,2;
    V::range<1> r1( v ); r1 = 1,7,2; 
    V::range<2> r2( v ); r2 = 1,7,2;
    
    v.reset( a ); 

The call to `reset` in this example constructs a three-dimensional `view` with shape 
3 x 3 x 3 whose data elements store the addresses of every second data element in the third 
dimension of every second array in the second dimension of every second array of array in 
the first dimension of the 7 x 7 x 7 `array_ a`. 

The header `<view_.hpp>` defines the class template,

    template< class A, class R, bool B > class view_;

Here,

* `A` is the array type the `view_` will be constructed from.
* `R` is a sequence of ranges.
* `B` signifies our intention to store pointers on an argument of type `A` or otherwise.

A `view_` is used to construct a view of a fixed-size array. The data member of a `view_` 
will be statically or dynamically allocated dependant on the type of the data member of 
the array type `A`. `A` and `R` are both required parameters with `B` optional defaulting 
to `true`. A `view_` type is more restricted than a `view` in the sense that the parameter 
`R` defines at compile time the ranges over an array of type `A` associated with the 
`view_`. Template types `rangesN`, `N` the dimensionality of an array of type `A`, and 
`range` are defined specifically for the template argument `R`. Since the range's are 
predetermined the `view_` type defines a constructor accepting an argument of type `A`. 
Thus, we can write,

    typedef array_< double, 3,7, true > A;
    typedef ranges3< range< 1,7,2 >, range< 1,7,2 >, range< 1,7,2 > > R;
    typedef view_< A, R > V;

    A a;
    V v( a );

  
[endsect] [/ Array Views]

[section:scalars_vectors_matrices Scalars, Vectors and Matrices]

In certain problem domains we can specify a set of integral dimensions which fully 
characterize the problem space. Fixed-size matrices for example are common in many 
algebraic problems. Knowing the initial dimensions in advance allows us to exploit this 
knowledge in all future computations. For example, given a matrix, M1, with M rows and P 
columns and a matrix, M2, with P rows and N columns, the product M1 x M2 is a matrix, M3 say, 
with M rows and N columns. Computational requirements such as the operand and result type 
dimensions in this example can be encoded in the template parameters of the types involved 
and also in the operators that act on them. The Boost maps library provides implementations 
for `scalar` and fixed-size `vector` and `matrix` operators that conform to such 
requirements, enabling compile time determination of consistent operations on the operands 
involved. The expression template paradigm has been invoked to enhance performance for 
mathematically intensive applications. Note that `scalar` operands are a convenient way to 
specify operations involving scalar types and are not intended to be used as the data 
elements of the `vector` or `matrix` types. The headers `<scalar.hpp>`, `<vector.hpp>` and 
`<matrix.hpp>` define the following respective types.

    template< class T > class scalar;

Here,

* `T` is the data type of the stored member.

    template< class T, std::size_t N, bool I, class A > class vector;

Here,

* `T` is the element type.
* `N` is the number of components.
* `I` is the zero/default initialization parameter.
* `A` is an allocator type.

    template< class T, std::size_t M, std::size_t N, bool I, class A > class matrix;
    
Here,

* `T` is the element type.
* `M` is the number of rows.
* `N` is the number of columns.
* `I` is the zero/default initialization parameter.
* `A` is an allocator type.

For all three class templates `T` is a required parameter. The parameters `N` for a `vector` 
and, `M` and `N` for a `matrix` are also required. The remaining parameters `I` and `A` for 
the `vector` and `matrix` class templates are optional with respective default's `true` and 
`null::allocator` for both classes.   

[endsect] [/ Scalars, Vectors and Matrices]

[endsect] [/ Concepts]

[section:tutorial Tutorial]

[section:array_tutorial Arrays]

The intention in this section is to simply reveal the functionality of the multi-dimensional 
array classes. The dominant feature is element access so we'll consider the various methods 
available. The following example declares a statically allocated, uninitialized `array`, `a`, 
then loops over each dimension setting the value of each data element to the sum of its indexes.

    typedef array< int, bounds5< 5,4,3,4,5 > > array_t;

    array_t a;

    for( std::size_t i = 0; i != a.bound<0>(); ++i )
    for( std::size_t j = 0; j != a.bound<1>(); ++j )
    for( std::size_t k = 0; k != a.bound<2>(); ++k )
    for( std::size_t l = 0; l != a.bound<3>(); ++l )
    for( std::size_t m = 0; m != a.bound<4>(); ++m )
        a[i][j][k][l][m] = i + j + k + l + m;

Alternatively, in place of `a[i][j][k][l][m]` we can use indirection as follows, 
`*(*(*(*(*(a+i)+j)+k)+l)+m)`. No check with either of these methods is made to ensure the 
indexes are within the bounds of the array. The `bound` method however returns the bound at each 
dimension and includes a compile time assertion on its argument. Note that this method employs 
the same zero-based indexing semantics the language provides for indexing array or pointer types.
If a debug assertion on the indexes is required we can write the following,

    bounds<5> b;

    for( std::size_t i = 0; i != a.bound<0>(); ++i )
    for( std::size_t j = 0; j != a.bound<1>(); ++j )
    for( std::size_t k = 0; k != a.bound<2>(); ++k )
    for( std::size_t l = 0; l != a.bound<3>(); ++l )
    for( std::size_t m = 0; m != a.bound<4>(); ++m )
        a[b = i,j,k,l,m] += 1;

If the indexes should always be checked then replacing `a[b = i,j,k,l,m]` with 
`a.at((b = i,j,k,l,m))` will throw a `std::out_of_range` exception on an invalid index.

When a function or operator is to be applied on all data elements in the array we can do 
something along the following lines,

    std::for_each( a.begin(), a.end(), boost::lambda::_1 -= 1 );

The `view` class template can used to access non-continuous sequences of data elements as 
follows,

    typedef view< array_t > view_t;

    view_t v;
        
    view_t::range<0> r0( v ); r0 = 1,4,1;
    view_t::range<1> r1( v ); r1 = 0,2,1;
    view_t::range<2> r2( v ); r2 = 0,3,1;
    view_t::range<3> r3( v ); r3 = 2,4,1;
    view_t::range<4> r4( v ); r4 = 1,4,1;

    v.reset( a );

    for( std::size_t i = 0; i != v.bound<0>(); ++i )
    for( std::size_t j = 0; j != v.bound<1>(); ++j )
    for( std::size_t k = 0; k != v.bound<2>(); ++k )
    for( std::size_t l = 0; l != v.bound<3>(); ++l )
    for( std::size_t m = 0; m != v.bound<4>(); ++m )
        *v[i][j][k][l][m] *= 1;
    
    r1 = 2,4,1; r3 = 0,2,1;
    v.reset( a );

    std::for_each( v.begin(), v.end(), *boost::lambda::_1 *= 1 );

Given that `v` represents a 3 x 2 x 3 x 2 x 3 array and that its values are the addresses of 
elements in the array `a`, we can set the values of any array whose dimensions are the same as 
those of `v` to the corresponding values in `a`.

    b = 3,2,3,2,3;
    pointer< int, 5 > p( b );
    v.to( p );

Similarly, again provided we store the addresses of a sequence of values from the representative 
array, we can set those values to the values in an array with the same dimensions as the `view`, 
so that given an array `q` with shape 3 x 2 x 3 x 2 x 3 we can write, `v.from( q )`.

[endsect] [/ Arrays]

[section:scalar_vector_matrix_tutorial Scalars, Vectors and Matrices]

At present, only dense vectors and matrices with associated operations are available. The 
following gives some examples.
  
	matrix< int, 2,2 > m1, m2;
	vector< int, 2 > r, v, v1, v2;
	scalar< int > s;

	s = 3;

	for( int i = 0; i != 2; ++i )
	{
	    v[i]  = i + 3;
	    v1[i] = i + 1;
	    v2[i] = i + 2;

	    for( int j = 0; j != 2; ++j )
	    {
	        m1[i][j] = i + j + 1;
	        m2[i][j] = i + j + 2;
	    }
	}

	r = outer_product( m1 * v1, v2 * m2 ) * ( s * v );

No distinction is made between row and column vectors hence pre and post multiplication of a 
matrix by the same vector is possible provided the matrix is square or otherwise whenever the 
number of vector components equals the number of matrix rows for pre-multiplication or the 
number of matrix columns for post-multiplication. For n matrices, n > 2, it is more efficient 
to produce temporary intermediate results when they are multiplied in succession using the `*` 
operator. Determining when such a chain of multiplications are being applied has proven to be
inefficient thus a temporary matrix is produced for the case n = 2 also. In order to avoid this 
the `product` operator can be applied as shown below.

    const unsigned M = 1000;

    matrix< int, M,M, true, std::allocator< int > > m, m1, m2, m3;

    for( int i = 0; i != M; ++i )
    for( int j = 0; j != M; ++j )
    {	
        m1( i,j ) = 1;
        m2( i,j ) = 2;
        m3( i,j ) = 3;
    }

    m = product( m1, m2 ) + m3;   

For some system dependant value of M the number of cache misses will dramatically reduce the 
performance of the above calculation. In such cases we can reorganize the computation as below, 
although setting up the matrices is not always so easily accomplished.

    const unsigned N = 10;

    matrix< matrix< matrix< int, 
        N,N, true, std::allocator< int > >, 
            N,N, true, std::allocator< int > >, 
                N,N, true, std::allocator< int > > m, m1, m2, m3;
    
    for( int i = 0; i != N; ++i )
    for( int j = 0; j != N; ++j )
    {	
        for( int k = 0; k != N; ++k )
        for( int l = 0; l != N; ++l )
        {	
            for( int m = 0; m != N; ++m )
            for( int n = 0; n != N; ++n )
            {	
                m1( i,j )( k,l )( m,n ) = 1;
                m2( i,j )( k,l )( m,n ) = 2;
                m3( i,j )( k,l )( m,n ) = 3;
            }
        }
    }
	   
    m = product( m1, m2 ) + m3;

Likewise, we can set up blocked computations with non-square matrices.

    matrix< matrix< int, 3,2 >, 2,3 > m1;
    matrix< matrix< int, 3,4 >, 2,3 > m2;
    matrix< matrix< int, 2,4 >, 3,3 > m, m3;

    for( std::size_t i = 0; i != 2; ++i )
    for( std::size_t j = 0; j != 3; ++j )
    for( std::size_t k = 0; k != 3; ++k )
    for( std::size_t l = 0; l != 2; ++l )
        m1[i][j][k][l] = i + j + k + l;

    for( std::size_t i = 0; i != 2; ++i )
    for( std::size_t j = 0; j != 3; ++j )
    for( std::size_t k = 0; k != 3; ++k )
    for( std::size_t l = 0; l != 4; ++l )
        m2[i][j][k][l] = i + j + k + l;

    for( std::size_t i = 0; i != 3; ++i )
    for( std::size_t j = 0; j != 3; ++j )
    for( std::size_t k = 0; k != 2; ++k )
    for( std::size_t l = 0; l != 4; ++l )
        m3[i][j][k][l] = i + j + k + l;

    m = transpose( m1 ) * m2 + m3;

Or similarly with a combination of vectors and matrices.

	vector< vector< int, 3 >, 2 > v1, v2;    
	matrix< matrix< int, 3,4 >, 2,3 > m, m1, m2;

	v1[0][0] = 1; v1[0][1] = 2; v1[0][2] = 3;
	v1[1][0] = 4; v1[1][1] = 5; v1[1][2] = 6;

	v2[0][0] = 6; v2[0][1] = 5; v2[0][2] = 4;
	v2[1][0] = 3; v2[1][1] = 2; v2[1][2] = 1;

	for( std::size_t i = 0; i != 2; ++i )
	for( std::size_t j = 0; j != 3; ++j )
	for( std::size_t k = 0; k != 2; ++k )
	for( std::size_t l = 0; l != 4; ++l )
	    m1[i][j][k][l] = i + j + k + l;

	for( std::size_t i = 0; i != 2; ++i )
	for( std::size_t j = 0; j != 3; ++j )
	for( std::size_t k = 0; k != 2; ++k )
	for( std::size_t l = 0; l != 4; ++l )
	    m2[i][j][k][l] = i + j + k + l;

	m = transpose( outer_product( v1, v2 ) ) * m1 + m2;

[endsect] [/ Scalars, Vectors and Matrices]

[endsect] [/ Tutorial]

[section:reference Reference]

*[link maps.array array]
*[link maps.array_ array_]
*[link maps.pointer pointer]
*[link maps.view view]
*[link maps.view_ view_]

[endsect] [/ Reference]


[section:array array]

[endsect] [/ array]

[section:array_ array_]

[endsect] [/ array_]

[section:pointer pointer]

[endsect] [/ pointer]

[section:view view]

[endsect] [/ view]

[section:view_ view_]

[endsect] [/ view_]
